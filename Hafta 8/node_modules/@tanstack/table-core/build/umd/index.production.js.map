{"version":3,"file":"index.production.js","sources":["../../src/utils.ts","../../src/features/Columns.ts","../../src/features/Rows.ts","../../src/features/Cells.ts","../../src/features/ColumnSizing.ts","../../src/features/Expanding.ts","../../src/filterFns.ts","../../src/features/Filters.ts","../../src/aggregationFns.ts","../../src/features/Grouping.ts","../../src/features/Ordering.ts","../../src/features/Pagination.ts","../../src/features/Pinning.ts","../../src/features/RowSelection.ts","../../src/sortingFns.ts","../../src/features/Sorting.ts","../../src/features/Visibility.ts","../../src/features/Headers.ts","../../src/createTable.ts","../../src/utils/filterRowsUtils.ts","../../src/utils/getExpandedRowModel.ts","../../src/core.ts","../../src/utils/getCoreRowModel.ts","../../src/utils/getFacetedMinMaxValues.ts","../../src/utils/getFacetedRowModel.ts","../../src/utils/getFacetedUniqueValues.ts","../../src/utils/getFilteredRowModel.ts","../../src/utils/getGroupedRowModel.ts","../../src/utils/getPaginationRowModel.ts","../../src/utils/getSortedRowModel.ts"],"sourcesContent":["import { NoInfer, TableState, Updater } from './types'\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\nexport type RequiredKeys<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type Overwrite<T, U extends { [TKey in keyof T]?: any }> = Omit<\n  T,\n  keyof U\n> &\n  U\n\nexport type IfDefined<T, N> = 0 extends 1 & T ? N : T extends {} ? T : N\n\nexport function functionalUpdate<T>(updater: Updater<T>, input: T): T {\n  return typeof updater === 'function'\n    ? (updater as (input: T) => T)(input)\n    : updater\n}\n\nexport function noop() {\n  //\n}\n\nexport function makeStateUpdater(key: keyof TableState, instance: unknown) {\n  return (updater: Updater<any>) => {\n    ;(instance as any).setState(<TTableState>(old: TTableState) => {\n      return {\n        ...old,\n        [key]: functionalUpdate(updater, (old as any)[key]),\n      }\n    })\n  }\n}\n\ntype AnyFunction = (...args: any) => any\n\nexport function isFunction<T extends AnyFunction>(d: any): d is T {\n  return d instanceof Function\n}\n\nexport function flattenBy<TNode>(\n  arr: TNode[],\n  getChildren: (item: TNode) => TNode[]\n) {\n  const flat: TNode[] = []\n\n  const recurse = (subArr: TNode[]) => {\n    subArr.forEach(item => {\n      flat.push(item)\n      const children = getChildren(item)\n      if (children?.length) {\n        recurse(children)\n      }\n    })\n  }\n\n  recurse(arr)\n\n  return flat\n}\n\nexport function memo<TDeps extends readonly any[], TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: any\n    debug?: () => any\n    onChange?: (result: TResult) => void\n  }\n): () => TResult {\n  let deps: any[] = []\n  let result: TResult | undefined\n\n  return () => {\n    let depTime: number\n    if (opts.key && opts.debug) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug) resultTime = Date.now()\n\n    result = fn(...newDeps)\n    opts?.onChange?.(result)\n\n    if (opts.key && opts.debug) {\n      if (opts?.debug()) {\n        const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n        const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n        const resultFpsPercentage = resultEndTime / 16\n\n        const pad = (str: number | string, num: number) => {\n          str = String(str)\n          while (str.length < num) {\n            str = ' ' + str\n          }\n          return str\n        }\n\n        console.info(\n          `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n          `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120)\n            )}deg 100% 31%);`,\n          opts?.key\n        )\n      }\n    }\n\n    return result!\n  }\n}\n","import {\n  Cell,\n  Column,\n  Header,\n  TableGenerics,\n  TableInstance,\n  Row,\n  AccessorFn,\n  ColumnDef,\n  Renderable,\n} from '../types'\nimport { memo } from '../utils'\n\nexport type CoreColumnDefType = 'data' | 'display' | 'group'\n\nexport type CoreColumnDef<TGenerics extends TableGenerics> = {\n  id: string\n  accessorKey?: string & keyof TGenerics['Row']\n  accessorFn?: AccessorFn<TGenerics['Row']>\n  columns?: ColumnDef<TGenerics>[]\n  header?: Renderable<\n    TGenerics,\n    {\n      instance: TableInstance<TGenerics>\n      header: Header<TGenerics>\n      column: Column<TGenerics>\n    }\n  >\n  footer?: Renderable<\n    TGenerics,\n    {\n      instance: TableInstance<TGenerics>\n      header: Header<TGenerics>\n      column: Column<TGenerics>\n    }\n  >\n  cell?: Renderable<\n    TGenerics,\n    {\n      instance: TableInstance<TGenerics>\n      row: Row<TGenerics>\n      column: Column<TGenerics>\n      cell: Cell<TGenerics>\n      getValue: () => TGenerics['Value']\n    }\n  >\n  meta?: TGenerics['ColumnMeta']\n}\n\nexport type CoreColumn<TGenerics extends TableGenerics> = {\n  id: string\n  depth: number\n  accessorFn?: AccessorFn<TGenerics['Row']>\n  columnDef: ColumnDef<TGenerics>\n  columnDefType: CoreColumnDefType\n  columns: Column<TGenerics>[]\n  parent?: Column<TGenerics>\n  getFlatColumns: () => Column<TGenerics>[]\n  getLeafColumns: () => Column<TGenerics>[]\n}\n\nexport type ColumnsOptions<TGenerics extends TableGenerics> = {\n  columns: ColumnDef<TGenerics>[]\n  defaultColumn?: Partial<ColumnDef<TGenerics>>\n}\n\nexport type ColumnsInstance<TGenerics extends TableGenerics> = {\n  getDefaultColumn: () => Partial<ColumnDef<TGenerics>>\n  getColumnDefs: () => ColumnDef<TGenerics>[]\n  createColumn: (\n    columnDef: ColumnDef<TGenerics>,\n    depth: number,\n    parent?: Column<TGenerics>\n  ) => Column<TGenerics>\n  getAllColumns: () => Column<TGenerics>[]\n  getAllFlatColumns: () => Column<TGenerics>[]\n  getAllFlatColumnsById: () => Record<string, Column<TGenerics>>\n  getAllLeafColumns: () => Column<TGenerics>[]\n  getColumn: (columnId: string) => Column<TGenerics>\n}\n\n//\n\nexport const Columns = {\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnsInstance<TGenerics> => {\n    return {\n      getDefaultColumn: memo(\n        () => [instance.options.defaultColumn],\n        defaultColumn => {\n          defaultColumn = (defaultColumn ?? {}) as Partial<ColumnDef<TGenerics>>\n\n          return {\n            header: props => props.header.column.id,\n            footer: props => props.header.column.id,\n            cell: props => props.getValue().toString?.() ?? null,\n            ...instance._features.reduce((obj, feature) => {\n              return Object.assign(obj, feature.getDefaultColumn?.())\n            }, {}),\n            ...defaultColumn,\n          } as Partial<ColumnDef<TGenerics>>\n        },\n        {\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n          key: process.env.NODE_ENV === 'development' && 'getDefaultColumn',\n        }\n      ),\n\n      getColumnDefs: () => instance.options.columns,\n\n      createColumn: (\n        columnDef: ColumnDef<TGenerics> & { columnDefType?: CoreColumnDefType },\n        depth: number,\n        parent\n      ) => {\n        const defaultColumn = instance.getDefaultColumn()\n\n        let id =\n          columnDef.id ??\n          columnDef.accessorKey ??\n          (typeof columnDef.header === 'string' ? columnDef.header : undefined)\n\n        let accessorFn: AccessorFn<TGenerics['Row']> | undefined\n\n        if (columnDef.accessorFn) {\n          accessorFn = columnDef.accessorFn\n        } else if (columnDef.accessorKey) {\n          accessorFn = (originalRow?: TGenerics['Row']) =>\n            (originalRow as any)[columnDef.accessorKey]\n        }\n\n        if (!id) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              columnDef.accessorFn\n                ? `Columns require an id when using an accessorFn`\n                : `Columns require an id when using a non-string header`\n            )\n          }\n          throw new Error()\n        }\n\n        let column: CoreColumn<TGenerics> = {\n          ...defaultColumn,\n          ...columnDef,\n          id: `${id}`,\n          accessorFn,\n          parent: parent as any,\n          depth,\n          columnDef,\n          columnDefType: columnDef.columnDefType as CoreColumnDefType,\n          columns: [],\n          getFlatColumns: memo(\n            () => [true],\n            () => {\n              return [\n                column as Column<TGenerics>,\n                ...column.columns?.flatMap(d => d.getFlatColumns()),\n              ]\n            },\n            {\n              key:\n                process.env.NODE_ENV === 'production' &&\n                'column.getFlatColumns',\n              debug: () =>\n                instance.options.debugAll ?? instance.options.debugColumns,\n            }\n          ),\n          getLeafColumns: memo(\n            () => [instance._getOrderColumnsFn()],\n            orderColumns => {\n              if (column.columns?.length) {\n                let leafColumns = column.columns.flatMap(column =>\n                  column.getLeafColumns()\n                )\n\n                return orderColumns(leafColumns)\n              }\n\n              return [column as Column<TGenerics>]\n            },\n            {\n              key:\n                process.env.NODE_ENV === 'production' &&\n                'column.getLeafColumns',\n              debug: () =>\n                instance.options.debugAll ?? instance.options.debugColumns,\n            }\n          ),\n        }\n\n        column = instance._features.reduce((obj, feature) => {\n          return Object.assign(obj, feature.createColumn?.(column, instance))\n        }, column)\n\n        // Yes, we have to convert instance to uknown, because we know more than the compiler here.\n        return column as Column<TGenerics>\n      },\n\n      getAllColumns: memo(\n        () => [instance.getColumnDefs()],\n        columnDefs => {\n          const recurseColumns = (\n            columnDefs: ColumnDef<TGenerics>[],\n            parent?: Column<TGenerics>,\n            depth = 0\n          ): Column<TGenerics>[] => {\n            return columnDefs.map(columnDef => {\n              const column = instance.createColumn(columnDef, depth, parent)\n\n              column.columns = columnDef.columns\n                ? recurseColumns(columnDef.columns, column, depth + 1)\n                : []\n\n              return column\n            })\n          }\n\n          return recurseColumns(columnDefs)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getAllColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      getAllFlatColumns: memo(\n        () => [instance.getAllColumns()],\n        allColumns => {\n          return allColumns.flatMap(column => {\n            return column.getFlatColumns()\n          })\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getAllFlatColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      getAllFlatColumnsById: memo(\n        () => [instance.getAllFlatColumns()],\n        flatColumns => {\n          return flatColumns.reduce((acc, column) => {\n            acc[column.id] = column\n            return acc\n          }, {} as Record<string, Column<TGenerics>>)\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'development' && 'getAllFlatColumnsById',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      getAllLeafColumns: memo(\n        () => [instance.getAllColumns(), instance._getOrderColumnsFn()],\n        (allColumns, orderColumns) => {\n          let leafColumns = allColumns.flatMap(column =>\n            column.getLeafColumns()\n          )\n          return orderColumns(leafColumns)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getAllLeafColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      getColumn: columnId => {\n        const column = instance.getAllFlatColumnsById()[columnId]\n\n        if (!column) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`[Table] Column with id ${columnId} does not exist.`)\n          }\n          throw new Error()\n        }\n\n        return column\n      },\n    }\n  },\n}\n","import {\n  TableGenerics,\n  TableInstance,\n  Row,\n  RowModel,\n  RowValues,\n} from '../types'\nimport { flattenBy } from '../utils'\n\nexport type CoreRow<TGenerics extends TableGenerics> = {\n  id: string\n  index: number\n  original?: TGenerics['Row']\n  depth: number\n  valuesCache: Record<string, any>\n  getValue: (columnId: string) => any\n  subRows: Row<TGenerics>[]\n  getLeafRows: () => Row<TGenerics>[]\n  originalSubRows?: TGenerics['Row'][]\n}\n\nexport type RowsOptions<TGenerics extends TableGenerics> = {\n  getCoreRowModel: (\n    instance: TableInstance<TGenerics>\n  ) => () => RowModel<TGenerics>\n  getSubRows?: (\n    originalRow: TGenerics['Row'],\n    index: number\n  ) => undefined | TGenerics['Row'][]\n  getRowId?: (\n    originalRow: TGenerics['Row'],\n    index: number,\n    parent?: Row<TGenerics>\n  ) => string\n}\n\nexport type RowsInstance<TGenerics extends TableGenerics> = {\n  getRowId: (\n    _: TGenerics['Row'],\n    index: number,\n    parent?: Row<TGenerics>\n  ) => string\n  createRow: (\n    id: string,\n    original: TGenerics['Row'] | undefined,\n    rowIndex: number,\n    depth: number,\n    subRows?: Row<TGenerics>[]\n  ) => Row<TGenerics>\n  getCoreRowModel: () => RowModel<TGenerics>\n  _getCoreRowModel?: () => RowModel<TGenerics>\n  getRowModel: () => RowModel<TGenerics>\n  getRow: (id: string) => Row<TGenerics>\n}\n\n//\n\nexport const Rows = {\n  // createRow: <TGenerics extends TableGenerics>(\n  //   row: Row<TGenerics>,\n  //   instance: TableInstance<TGenerics>\n  // ): CellsRow<TGenerics> => {\n  //   return {}\n  // },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): RowsInstance<TGenerics> => {\n    return {\n      getRowId: (\n        row: TGenerics['Row'],\n        index: number,\n        parent?: Row<TGenerics>\n      ) =>\n        instance.options.getRowId?.(row, index, parent) ??\n        `${parent ? [parent.id, index].join('.') : index}`,\n      createRow: (id, original, rowIndex, depth, subRows) => {\n        let row: CoreRow<TGenerics> = {\n          id,\n          index: rowIndex,\n          original,\n          depth,\n          valuesCache: {},\n          getValue: columnId => {\n            if (row.valuesCache.hasOwnProperty(columnId)) {\n              return row.valuesCache[columnId]\n            }\n\n            const column = instance.getColumn(columnId)\n\n            if (!column.accessorFn) {\n              return undefined\n            }\n\n            row.valuesCache[columnId] = column.accessorFn(\n              row.original,\n              rowIndex\n            )\n\n            return row.valuesCache[columnId]\n          },\n          subRows: subRows ?? [],\n          getLeafRows: () => flattenBy(row.subRows, d => d.subRows),\n        }\n\n        for (let i = 0; i < instance._features.length; i++) {\n          const feature = instance._features[i]\n          Object.assign(row, feature?.createRow?.(row, instance))\n        }\n\n        return row as Row<TGenerics>\n      },\n\n      getCoreRowModel: () => {\n        if (!instance._getCoreRowModel) {\n          instance._getCoreRowModel = instance.options.getCoreRowModel(instance)\n        }\n\n        return instance._getCoreRowModel()\n      },\n\n      // The final calls start at the bottom of the model,\n      // expanded rows, which then work their way up\n\n      getRowModel: () => {\n        return instance.getPaginationRowModel()\n      },\n      getRow: (id: string) => {\n        const row = instance.getRowModel().rowsById[id]\n\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`getRow expected an ID, but got ${id}`)\n          }\n          throw new Error()\n        }\n\n        return row\n      },\n    }\n  },\n}\n","import {\n  Cell,\n  TableGenerics,\n  TableInstance,\n  Row,\n  Column,\n  CoreCell,\n} from '../types'\nimport { memo } from '../utils'\n\nexport type CellsRow<TGenerics extends TableGenerics> = {\n  getAllCells: () => Cell<TGenerics>[]\n  getAllCellsByColumnId: () => Record<string, Cell<TGenerics>>\n}\n\nexport type CellsInstance<TGenerics extends TableGenerics> = {\n  createCell: (\n    row: Row<TGenerics>,\n    column: Column<TGenerics>,\n    columnId: string\n  ) => Cell<TGenerics>\n  getCell: (rowId: string, columnId: string) => Cell<TGenerics>\n}\n\n//\n\nexport const Cells = {\n  createRow: <TGenerics extends TableGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): CellsRow<TGenerics> => {\n    return {\n      getAllCells: memo(\n        () => [instance.getAllLeafColumns()],\n        leafColumns => {\n          return leafColumns.map(column => {\n            return instance.createCell(row as Row<TGenerics>, column, column.id)\n          })\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'row.getAllCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n\n      getAllCellsByColumnId: memo(\n        () => [row.getAllCells()],\n        allCells => {\n          return allCells.reduce((acc, cell) => {\n            acc[cell.columnId] = cell\n            return acc\n          }, {} as Record<string, Cell<TGenerics>>)\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'production' &&\n            'row.getAllCellsByColumnId',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): CellsInstance<TGenerics> => {\n    return {\n      createCell: (row, column, columnId) => {\n        const cell: CoreCell<TGenerics> = {\n          id: `${row.id}_${column.id}`,\n          rowId: row.id,\n          columnId,\n          row,\n          column,\n          getValue: () => row.getValue(columnId),\n          renderCell: () =>\n            column.cell\n              ? instance._render(column.cell, {\n                  instance,\n                  column,\n                  row,\n                  cell: cell as Cell<TGenerics>,\n                  getValue: cell.getValue,\n                })\n              : null,\n        }\n\n        instance._features.forEach(feature => {\n          Object.assign(\n            cell,\n            feature.createCell?.(\n              cell as Cell<TGenerics>,\n              column,\n              row as Row<TGenerics>,\n              instance\n            )\n          )\n        }, {})\n\n        return cell as Cell<TGenerics>\n      },\n\n      getCell: (rowId: string, columnId: string) => {\n        const row = instance.getRow(rowId)\n\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`[Table] could not find row with id ${rowId}`)\n          }\n          throw new Error()\n        }\n\n        const cell = row.getAllCellsByColumnId()[columnId]\n\n        if (!cell) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `[Table] could not find cell ${columnId} in row ${rowId}`\n            )\n          }\n          throw new Error()\n        }\n\n        return cell\n      },\n    }\n  },\n}\n","import {\n  Column,\n  Header,\n  OnChangeFn,\n  TableGenerics,\n  TableInstance,\n  Updater,\n  TableFeature,\n} from '../types'\nimport { makeStateUpdater } from '../utils'\nimport { ColumnPinningPosition } from './Pinning'\n\n//\n\nexport type ColumnSizingTableState = {\n  columnSizing: ColumnSizingState\n  columnSizingInfo: ColumnSizingInfoState\n}\n\nexport type ColumnSizingState = Record<string, number>\n\nexport type ColumnSizingInfoState = {\n  startOffset: null | number\n  startSize: null | number\n  deltaOffset: null | number\n  deltaPercentage: null | number\n  isResizingColumn: false | string\n  columnSizingStart: [string, number][]\n}\n\nexport type ColumnResizeMode = 'onChange' | 'onEnd'\n\nexport type ColumnSizingOptions = {\n  enableColumnResizing?: boolean\n  columnResizeMode?: ColumnResizeMode\n  onColumnSizingChange?: OnChangeFn<ColumnSizingState>\n  onColumnSizingInfoChange?: OnChangeFn<ColumnSizingInfoState>\n}\n\nexport type ColumnSizingDefaultOptions = {\n  columnResizeMode: ColumnResizeMode\n  onColumnSizingChange: OnChangeFn<ColumnSizingState>\n  onColumnSizingInfoChange: OnChangeFn<ColumnSizingInfoState>\n}\n\nexport type ColumnSizingInstance<TGenerics extends TableGenerics> = {\n  setColumnSizing: (updater: Updater<ColumnSizingState>) => void\n  setColumnSizingInfo: (updater: Updater<ColumnSizingInfoState>) => void\n  resetColumnSizing: (defaultState?: boolean) => void\n  resetHeaderSizeInfo: (defaultState?: boolean) => void\n  getTotalSize: () => number\n  getLeftTotalSize: () => number\n  getCenterTotalSize: () => number\n  getRightTotalSize: () => number\n}\n\nexport type ColumnSizingColumnDef = {\n  enableResizing?: boolean\n  size?: number\n  minSize?: number\n  maxSize?: number\n}\n\nexport type ColumnSizingColumn<TGenerics extends TableGenerics> = {\n  getSize: () => number\n  getStart: (position?: ColumnPinningPosition) => number\n  getCanResize: () => boolean\n  getIsResizing: () => boolean\n  resetSize: () => void\n}\n\nexport type ColumnSizingHeader<TGenerics extends TableGenerics> = {\n  getSize: () => number\n  getStart: (position?: ColumnPinningPosition) => number\n  getResizeHandler: () => (event: unknown) => void\n}\n\n//\n\nexport const defaultColumnSizing = {\n  size: 150,\n  minSize: 20,\n  maxSize: Number.MAX_SAFE_INTEGER,\n}\n\nconst getDefaultColumnSizingInfoState = (): ColumnSizingInfoState => ({\n  startOffset: null,\n  startSize: null,\n  deltaOffset: null,\n  deltaPercentage: null,\n  isResizingColumn: false,\n  columnSizingStart: [],\n})\n\nexport const ColumnSizing: TableFeature = {\n  getDefaultColumn: (): ColumnSizingColumnDef => {\n    return defaultColumnSizing\n  },\n  getInitialState: (state): ColumnSizingTableState => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: getDefaultColumnSizingInfoState(),\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingDefaultOptions => {\n    return {\n      columnResizeMode: 'onEnd',\n      onColumnSizingChange: makeStateUpdater('columnSizing', instance),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', instance),\n    }\n  },\n\n  createColumn: <TGenerics extends TableGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingColumn<TGenerics> => {\n    return {\n      getSize: () => {\n        const columnSize = instance.getState().columnSizing[column.id]\n\n        return Math.min(\n          Math.max(\n            column.minSize ?? defaultColumnSizing.minSize,\n            columnSize ?? column.size ?? defaultColumnSizing.size\n          ),\n          column.maxSize ?? defaultColumnSizing.maxSize\n        )\n      },\n      getStart: position => {\n        const columns = !position\n          ? instance.getVisibleLeafColumns()\n          : position === 'left'\n          ? instance.getLeftVisibleLeafColumns()\n          : instance.getRightVisibleLeafColumns()\n\n        const index = columns.findIndex(d => d.id === column.id)\n\n        if (index > 0) {\n          const prevSiblingColumn = columns[index - 1]!\n\n          return (\n            prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize()\n          )\n        }\n\n        return 0\n      },\n      resetSize: () => {\n        instance.setColumnSizing(({ [column.id]: _, ...rest }) => {\n          return rest\n        })\n      },\n      getCanResize: () => {\n        return (\n          (column.enableResizing ?? true) &&\n          (instance.options.enableColumnResizing ?? true)\n        )\n      },\n      getIsResizing: () => {\n        return (\n          instance.getState().columnSizingInfo.isResizingColumn === column.id\n        )\n      },\n    }\n  },\n\n  createHeader: <TGenerics extends TableGenerics>(\n    header: Header<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingHeader<TGenerics> => {\n    return {\n      getSize: () => {\n        let sum = 0\n\n        const recurse = (header: Header<TGenerics>) => {\n          if (header.subHeaders.length) {\n            header.subHeaders.forEach(recurse)\n          } else {\n            sum += header.column.getSize() ?? 0\n          }\n        }\n\n        recurse(header)\n\n        return sum\n      },\n      getStart: () => {\n        if (header.index > 0) {\n          const prevSiblingHeader =\n            header.headerGroup.headers[header.index - 1]!\n          return prevSiblingHeader.getStart() + prevSiblingHeader.getSize()\n        }\n\n        return 0\n      },\n      getResizeHandler: () => {\n        const column = instance.getColumn(header.column.id)\n        const canResize = column.getCanResize()\n\n        return (e: unknown) => {\n          if (!canResize) {\n            return\n          }\n\n          ;(e as any).persist?.()\n\n          if (isTouchStartEvent(e)) {\n            // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n            if (e.touches && e.touches.length > 1) {\n              return\n            }\n          }\n\n          const startSize = header.getSize()\n\n          const columnSizingStart: [string, number][] = header\n            ? header\n                .getLeafHeaders()\n                .map(d => [d.column.id, d.column.getSize()])\n            : [[column.id, column.getSize()]]\n\n          const clientX = isTouchStartEvent(e)\n            ? Math.round(e.touches[0]!.clientX)\n            : (e as MouseEvent).clientX\n\n          const updateOffset = (\n            eventType: 'move' | 'end',\n            clientXPos?: number\n          ) => {\n            if (typeof clientXPos !== 'number') {\n              return\n            }\n\n            let newColumnSizing: ColumnSizingState = {}\n\n            instance.setColumnSizingInfo(old => {\n              const deltaOffset = clientXPos - (old?.startOffset ?? 0)\n              const deltaPercentage = Math.max(\n                deltaOffset / (old?.startSize ?? 0),\n                -0.999999\n              )\n\n              old.columnSizingStart.forEach(([columnId, headerSize]) => {\n                newColumnSizing[columnId] =\n                  Math.round(\n                    Math.max(headerSize + headerSize * deltaPercentage, 0) * 100\n                  ) / 100\n              })\n\n              return {\n                ...old,\n                deltaOffset,\n                deltaPercentage,\n              }\n            })\n\n            if (\n              instance.options.columnResizeMode === 'onChange' ||\n              eventType === 'end'\n            ) {\n              instance.setColumnSizing(old => ({\n                ...old,\n                ...newColumnSizing,\n              }))\n            }\n          }\n\n          const onMove = (clientXPos?: number) =>\n            updateOffset('move', clientXPos)\n\n          const onEnd = (clientXPos?: number) => {\n            updateOffset('end', clientXPos)\n\n            instance.setColumnSizingInfo(old => ({\n              ...old,\n              isResizingColumn: false,\n              startOffset: null,\n              startSize: null,\n              deltaOffset: null,\n              deltaPercentage: null,\n              columnSizingStart: [],\n            }))\n          }\n\n          const mouseEvents = {\n            moveHandler: (e: MouseEvent) => onMove(e.clientX),\n            upHandler: (e: MouseEvent) => {\n              document.removeEventListener('mousemove', mouseEvents.moveHandler)\n              document.removeEventListener('mouseup', mouseEvents.upHandler)\n              onEnd(e.clientX)\n            },\n          }\n\n          const touchEvents = {\n            moveHandler: (e: TouchEvent) => {\n              if (e.cancelable) {\n                e.preventDefault()\n                e.stopPropagation()\n              }\n              onMove(e.touches[0]!.clientX)\n              return false\n            },\n            upHandler: (e: TouchEvent) => {\n              document.removeEventListener('touchmove', touchEvents.moveHandler)\n              document.removeEventListener('touchend', touchEvents.upHandler)\n              if (e.cancelable) {\n                e.preventDefault()\n                e.stopPropagation()\n              }\n              onEnd(e.touches[0]!.clientX)\n            },\n          }\n\n          const passiveIfSupported = passiveEventSupported()\n            ? { passive: false }\n            : false\n\n          if (isTouchStartEvent(e)) {\n          } else {\n            document.addEventListener(\n              'mousemove',\n              mouseEvents.moveHandler,\n              passiveIfSupported\n            )\n            document.addEventListener(\n              'mouseup',\n              mouseEvents.upHandler,\n              passiveIfSupported\n            )\n          }\n\n          instance.setColumnSizingInfo(old => ({\n            ...old,\n            startOffset: clientX,\n            startSize,\n            deltaOffset: 0,\n            deltaPercentage: 0,\n            columnSizingStart,\n            isResizingColumn: column.id,\n          }))\n        }\n      },\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnSizingInstance<TGenerics> => {\n    return {\n      setColumnSizing: updater =>\n        instance.options.onColumnSizingChange?.(updater),\n      setColumnSizingInfo: updater =>\n        instance.options.onColumnSizingInfoChange?.(updater),\n      resetColumnSizing: defaultState => {\n        instance.setColumnSizing(\n          defaultState ? {} : instance.initialState.columnSizing ?? {}\n        )\n      },\n      resetHeaderSizeInfo: defaultState => {\n        instance.setColumnSizingInfo(\n          defaultState\n            ? getDefaultColumnSizingInfoState()\n            : instance.initialState.columnSizingInfo ??\n                getDefaultColumnSizingInfoState()\n        )\n      },\n      getTotalSize: () =>\n        instance.getHeaderGroups()[0]?.headers.reduce((sum, header) => {\n          return sum + header.getSize()\n        }, 0) ?? 0,\n      getLeftTotalSize: () =>\n        instance.getLeftHeaderGroups()[0]?.headers.reduce((sum, header) => {\n          return sum + header.getSize()\n        }, 0) ?? 0,\n      getCenterTotalSize: () =>\n        instance.getCenterHeaderGroups()[0]?.headers.reduce((sum, header) => {\n          return sum + header.getSize()\n        }, 0) ?? 0,\n      getRightTotalSize: () =>\n        instance.getRightHeaderGroups()[0]?.headers.reduce((sum, header) => {\n          return sum + header.getSize()\n        }, 0) ?? 0,\n    }\n  },\n}\n\nlet passiveSupported: boolean | null = null\nexport function passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported\n\n  let supported = false\n  try {\n    const options = {\n      get passive() {\n        supported = true\n        return false\n      },\n    }\n\n    const noop = () => {}\n\n    window.addEventListener('test', noop, options)\n    window.removeEventListener('test', noop)\n  } catch (err) {\n    supported = false\n  }\n  passiveSupported = supported\n  return passiveSupported\n}\n\nfunction isTouchStartEvent(e: unknown): e is TouchEvent {\n  return (e as TouchEvent).type === 'touchstart'\n}\n","import { RowModel } from '..'\nimport {\n  OnChangeFn,\n  TableGenerics,\n  TableInstance,\n  Row,\n  Updater,\n  TableFeature,\n} from '../types'\nimport { makeStateUpdater } from '../utils'\nimport { Rows } from './Rows'\n\nexport type ExpandedStateList = Record<string, boolean>\nexport type ExpandedState = true | Record<string, boolean>\nexport type ExpandedTableState = {\n  expanded: ExpandedState\n}\n\nexport type ExpandedRow = {\n  toggleExpanded: (expanded?: boolean) => void\n  getIsExpanded: () => boolean\n  getCanExpand: () => boolean\n  getToggleExpandedHandler: () => () => void\n}\n\nexport type ExpandedOptions<TGenerics extends TableGenerics> = {\n  manualExpanding?: boolean\n  onExpandedChange?: OnChangeFn<ExpandedState>\n  autoResetExpanded?: boolean\n  enableExpanding?: boolean\n  getExpandedRowModel?: (\n    instance: TableInstance<TGenerics>\n  ) => () => RowModel<TGenerics>\n  expandSubRows?: boolean\n  getIsRowExpanded?: (row: Row<TGenerics>) => boolean\n  getRowCanExpand?: (row: Row<TGenerics>) => boolean\n  paginateExpandedRows?: boolean\n}\n\nexport type ExpandedInstance<TGenerics extends TableGenerics> = {\n  _autoResetExpanded: () => void\n  setExpanded: (updater: Updater<ExpandedState>) => void\n  toggleAllRowsExpanded: (expanded?: boolean) => void\n  resetExpanded: (defaultState?: boolean) => void\n  getCanSomeRowsExpand: () => boolean\n  getToggleAllRowsExpandedHandler: () => (event: unknown) => void\n  getIsSomeRowsExpanded: () => boolean\n  getIsAllRowsExpanded: () => boolean\n  getExpandedDepth: () => number\n  getExpandedRowModel: () => RowModel<TGenerics>\n  _getExpandedRowModel?: () => RowModel<TGenerics>\n  getPreExpandedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Expanding: TableFeature = {\n  getInitialState: (state): ExpandedTableState => {\n    return {\n      expanded: {},\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ExpandedOptions<TGenerics> => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', instance),\n      autoResetExpanded: true,\n      expandSubRows: true,\n      paginateExpandedRows: true,\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ExpandedInstance<TGenerics> => {\n    let registered = false\n    let queued = false\n\n    return {\n      _autoResetExpanded: () => {\n        if (!registered) {\n          instance._queue(() => {\n            registered = true\n          })\n          return\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return\n        }\n\n        if (\n          instance.options.autoResetAll === true ||\n          instance.options.autoResetExpanded\n        ) {\n          if (queued) return\n          queued = true\n          instance._queue(() => {\n            instance.resetExpanded()\n            queued = false\n          })\n        }\n      },\n      setExpanded: updater => instance.options.onExpandedChange?.(updater),\n      toggleAllRowsExpanded: expanded => {\n        if (expanded ?? !instance.getIsAllRowsExpanded()) {\n          instance.setExpanded(true)\n        } else {\n          instance.setExpanded({})\n        }\n      },\n      resetExpanded: defaultState => {\n        instance.setExpanded(\n          defaultState ? {} : instance.initialState?.expanded ?? {}\n        )\n      },\n      getCanSomeRowsExpand: () => {\n        return instance.getRowModel().flatRows.some(row => row.getCanExpand())\n      },\n      getToggleAllRowsExpandedHandler: () => {\n        return (e: unknown) => {\n          ;(e as any).persist?.()\n          instance.toggleAllRowsExpanded()\n        }\n      },\n      getIsSomeRowsExpanded: () => {\n        const expanded = instance.getState().expanded\n        return expanded === true || Object.values(expanded).some(Boolean)\n      },\n      getIsAllRowsExpanded: () => {\n        const expanded = instance.getState().expanded\n\n        // If expanded is true, save some cycles and return true\n        if (expanded === true) {\n          return true\n        }\n\n        // If any row is not expanded, return false\n        if (instance.getRowModel().flatRows.some(row => row.getIsExpanded())) {\n          return false\n        }\n\n        // They must all be expanded :shrug:\n        return true\n      },\n      getExpandedDepth: () => {\n        let maxDepth = 0\n\n        const rowIds =\n          instance.getState().expanded === true\n            ? Object.keys(instance.getRowModel().rowsById)\n            : Object.keys(instance.getState().expanded)\n\n        rowIds.forEach(id => {\n          const splitId = id.split('.')\n          maxDepth = Math.max(maxDepth, splitId.length)\n        })\n\n        return maxDepth\n      },\n      getPreExpandedRowModel: () => instance.getGroupedRowModel(),\n      getExpandedRowModel: () => {\n        if (\n          !instance._getExpandedRowModel &&\n          instance.options.getExpandedRowModel\n        ) {\n          instance._getExpandedRowModel =\n            instance.options.getExpandedRowModel(instance)\n        }\n\n        if (\n          instance.options.manualExpanding ||\n          !instance._getExpandedRowModel\n        ) {\n          return instance.getPreExpandedRowModel()\n        }\n\n        return instance._getExpandedRowModel()\n      },\n    }\n  },\n\n  createRow: <TGenerics extends TableGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ExpandedRow => {\n    return {\n      toggleExpanded: expanded => {\n        instance.setExpanded(old => {\n          const exists = old === true ? true : !!old?.[row.id]\n\n          let oldExpanded: ExpandedStateList = {}\n\n          if (old === true) {\n            Object.keys(instance.getRowModel().rowsById).forEach(rowId => {\n              oldExpanded[rowId] = true\n            })\n          } else {\n            oldExpanded = old\n          }\n\n          expanded = expanded ?? !exists\n\n          if (!exists && expanded) {\n            return {\n              ...oldExpanded,\n              [row.id]: true,\n            }\n          }\n\n          if (exists && !expanded) {\n            const { [row.id]: _, ...rest } = oldExpanded\n            return rest\n          }\n\n          return old\n        })\n      },\n      getIsExpanded: () => {\n        const expanded = instance.getState().expanded\n\n        return !!(\n          instance.options.getIsRowExpanded?.(row) ??\n          (expanded === true || expanded?.[row.id])\n        )\n      },\n      getCanExpand: () => {\n        return (\n          (instance.options.getRowCanExpand?.(row) ?? true) &&\n          (instance.options.enableExpanding ?? true) &&\n          !!row.subRows?.length\n        )\n      },\n      getToggleExpandedHandler: () => {\n        const canExpand = row.getCanExpand()\n\n        return () => {\n          if (!canExpand) return\n          row.toggleExpanded()\n        }\n      },\n    }\n  },\n}\n","import { FilterFn } from './features/Filters'\n\nconst includesString: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: string\n) => {\n  const search = filterValue.toLowerCase()\n  return row.getValue(columnId).toLowerCase().includes(search)\n}\n\nincludesString.autoRemove = (val: any) => testFalsey(val)\n\nconst includesStringSensitive: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: string\n) => {\n  return row.getValue(columnId).includes(filterValue)\n}\n\nincludesStringSensitive.autoRemove = (val: any) => testFalsey(val)\n\nconst equalsString: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: string\n) => {\n  return row.getValue(columnId).toLowerCase() === filterValue.toLowerCase()\n}\n\nequalsString.autoRemove = (val: any) => testFalsey(val)\n\nconst arrIncludes: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: unknown\n) => {\n  return row.getValue(columnId).includes(filterValue)\n}\n\narrIncludes.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nconst arrIncludesAll: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: unknown[]\n) => {\n  return !filterValue.some(val => !row.getValue(columnId).includes(val))\n}\n\narrIncludesAll.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nconst arrIncludesSome: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: unknown[]\n) => {\n  return filterValue.some(val => row.getValue(columnId).includes(val))\n}\n\narrIncludesSome.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nconst equals: FilterFn<any> = (row, columnId: string, filterValue: unknown) => {\n  return row.getValue(columnId) === filterValue\n}\n\nequals.autoRemove = (val: any) => testFalsey(val)\n\nconst weakEquals: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: unknown\n) => {\n  return row.getValue(columnId) == filterValue\n}\n\nweakEquals.autoRemove = (val: any) => testFalsey(val)\n\nconst inNumberRange: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: [number, number]\n) => {\n  let [min, max] = filterValue\n\n  const rowValue = row.getValue(columnId)\n  return rowValue >= min && rowValue <= max\n}\n\ninNumberRange.resolveFilterValue = (val: [any, any]) => {\n  let [unsafeMin, unsafeMax] = val\n\n  let parsedMin =\n    typeof unsafeMin !== 'number' ? parseFloat(unsafeMin as string) : unsafeMin\n  let parsedMax =\n    typeof unsafeMax !== 'number' ? parseFloat(unsafeMax as string) : unsafeMax\n\n  let min =\n    unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax\n\n  if (min > max) {\n    const temp = min\n    min = max\n    max = temp\n  }\n\n  return [min, max] as const\n}\n\ninNumberRange.autoRemove = (val: any) =>\n  testFalsey(val) || (testFalsey(val[0]) && testFalsey(val[1]))\n\n// Export\n\nexport const filterFns = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  arrIncludes,\n  arrIncludesAll,\n  arrIncludesSome,\n  equals,\n  weakEquals,\n  inNumberRange,\n}\n\nexport type BuiltInFilterFn = keyof typeof filterFns\n\n// Utils\n\nfunction testFalsey(val: any) {\n  return val === undefined || val === null || val === ''\n}\n","import { RowModel } from '..'\nimport { BuiltInFilterFn, filterFns } from '../filterFns'\nimport {\n  Column,\n  OnChangeFn,\n  TableGenerics,\n  TableInstance,\n  Row,\n  Updater,\n  TableFeature,\n} from '../types'\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  Overwrite,\n} from '../utils'\n\nexport type FiltersTableState = {\n  columnFilters: ColumnFiltersState\n  globalFilter: any\n  // filtersProgress: number\n  // facetProgress: Record<string, number>\n}\n\nexport type ColumnFiltersState = ColumnFilter[]\n\nexport type ColumnFilter = {\n  id: string\n  value: unknown\n}\n\nexport type ResolvedColumnFilter<TGenerics extends TableGenerics> = {\n  id: string\n  resolvedValue: unknown\n  filterFn: FilterFn<TGenerics>\n}\n\nexport type FilterFn<TGenerics extends TableGenerics> = {\n  (\n    row: Row<TGenerics>,\n    columnId: string,\n    filterValue: any,\n    addMeta: (meta: TGenerics['FilterMeta']) => void\n  ): boolean\n\n  resolveFilterValue?: TransformFilterValueFn<TGenerics>\n  autoRemove?: ColumnFilterAutoRemoveTestFn<TGenerics>\n}\n\nexport type TransformFilterValueFn<TGenerics extends TableGenerics> = (\n  value: any,\n  column?: Column<TGenerics>\n) => unknown\n\nexport type ColumnFilterAutoRemoveTestFn<TGenerics extends TableGenerics> = (\n  value: any,\n  column?: Column<TGenerics>\n) => boolean\n\nexport type CustomFilterFns<TGenerics extends TableGenerics> = Record<\n  string,\n  FilterFn<TGenerics>\n>\n\nexport type FilterFnOption<TGenerics extends TableGenerics> =\n  | 'auto'\n  | BuiltInFilterFn\n  | keyof TGenerics['FilterFns']\n  | FilterFn<TGenerics>\n\nexport type FiltersColumnDef<TGenerics extends TableGenerics> = {\n  filterFn?: FilterFnOption<Overwrite<TGenerics, { Value: any }>>\n  enableColumnFilter?: boolean\n  enableGlobalFilter?: boolean\n  enableFaceting?: boolean\n}\n\nexport type FiltersColumn<TGenerics extends TableGenerics> = {\n  filterFn: FilterFnOption<Overwrite<TGenerics, { Value: any }>>\n  getAutoFilterFn: () => FilterFn<TGenerics> | undefined\n  getFilterFn: () => FilterFn<TGenerics> | undefined\n  setFilterValue: (updater: Updater<any>) => void\n  getCanFilter: () => boolean\n  getCanGlobalFilter: () => boolean\n  getFacetedRowModel: () => RowModel<TGenerics>\n  _getFacetedRowModel?: () => RowModel<TGenerics>\n  getIsFiltered: () => boolean\n  getFilterValue: () => unknown\n  getFilterIndex: () => number\n  getFacetedUniqueValues: () => Map<any, number>\n  _getFacetedUniqueValues?: () => Map<any, number>\n  getFacetedMinMaxValues: () => undefined | [number, number]\n  _getFacetedMinMaxValues?: () => undefined | [number, number]\n}\n\nexport type FiltersRow<TGenerics extends TableGenerics> = {\n  columnFilters: Record<string, boolean>\n  columnFiltersMeta: Record<string, TGenerics['FilterMeta']>\n  subRowsByFacetId: Record<string, Row<TGenerics>[]>\n}\n\nexport type FiltersOptions<TGenerics extends TableGenerics> = {\n  enableFilters?: boolean\n  manualFiltering?: boolean\n  filterFromLeafRows?: boolean\n  filterFns?: TGenerics['FilterFns']\n  getFilteredRowModel?: (\n    instance: TableInstance<TGenerics>\n  ) => () => RowModel<TGenerics>\n\n  // Column\n  onColumnFiltersChange?: OnChangeFn<ColumnFiltersState>\n  enableColumnFilters?: boolean\n\n  // Global\n  globalFilterFn?: FilterFnOption<TGenerics>\n  onGlobalFilterChange?: OnChangeFn<any>\n  enableGlobalFilter?: boolean\n  getColumnCanGlobalFilter?: (column: Column<TGenerics>) => boolean\n\n  // Faceting\n  getFacetedRowModel?: (\n    instance: TableInstance<TGenerics>,\n    columnId: string\n  ) => () => RowModel<TGenerics>\n  getFacetedUniqueValues?: (\n    instance: TableInstance<TGenerics>,\n    columnId: string\n  ) => () => Map<any, number>\n  getFacetedMinMaxValues?: (\n    instance: TableInstance<TGenerics>,\n    columnId: string\n  ) => () => undefined | [number, number]\n}\n\nexport type FiltersInstance<TGenerics extends TableGenerics> = {\n  setColumnFilters: (updater: Updater<ColumnFiltersState>) => void\n\n  resetColumnFilters: (defaultState?: boolean) => void\n\n  // Column Filters\n  getPreFilteredRowModel: () => RowModel<TGenerics>\n  getFilteredRowModel: () => RowModel<TGenerics>\n  _getFilteredRowModel?: () => RowModel<TGenerics>\n\n  // Global Filters\n  setGlobalFilter: (updater: Updater<any>) => void\n  resetGlobalFilter: (defaultState?: boolean) => void\n  getGlobalAutoFilterFn: () => FilterFn<TGenerics> | undefined\n  getGlobalFilterFn: () => FilterFn<TGenerics> | undefined\n  getGlobalFacetedRowModel: () => RowModel<TGenerics>\n  _getGlobalFacetedRowModel?: () => RowModel<TGenerics>\n  getGlobalFacetedUniqueValues: () => Map<any, number>\n  _getGlobalFacetedUniqueValues?: () => Map<any, number>\n  getGlobalFacetedMinMaxValues: () => undefined | [number, number]\n  _getGlobalFacetedMinMaxValues?: () => undefined | [number, number]\n}\n\n//\n\nexport const Filters: TableFeature = {\n  getDefaultColumn: <\n    TGenerics extends TableGenerics\n  >(): FiltersColumnDef<TGenerics> => {\n    return {\n      filterFn: 'auto',\n    }\n  },\n\n  getInitialState: (state): FiltersTableState => {\n    return {\n      columnFilters: [],\n      globalFilter: undefined,\n      // filtersProgress: 1,\n      // facetProgress: {},\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): FiltersOptions<TGenerics> => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', instance),\n      onGlobalFilterChange: makeStateUpdater('globalFilter', instance),\n      filterFromLeafRows: false,\n      globalFilterFn: 'auto',\n      getColumnCanGlobalFilter: column => {\n        const value = instance\n          .getCoreRowModel()\n          .flatRows[0]?.getAllCellsByColumnId()\n          [column.id]?.getValue()\n\n        return typeof value === 'string'\n      },\n    }\n  },\n\n  createColumn: <TGenerics extends TableGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): FiltersColumn<TGenerics> => {\n    return {\n      filterFn: column.filterFn,\n      getAutoFilterFn: () => {\n        const firstRow = instance.getCoreRowModel().flatRows[0]\n\n        const value = firstRow?.getValue(column.id)\n\n        if (typeof value === 'string') {\n          return filterFns.includesString\n        }\n\n        if (typeof value === 'number') {\n          return filterFns.inNumberRange\n        }\n\n        if (value !== null && typeof value === 'object') {\n          return filterFns.equals\n        }\n\n        if (Array.isArray(value)) {\n          return filterFns.arrIncludes\n        }\n\n        return filterFns.weakEquals\n      },\n      getFilterFn: () => {\n        const userFilterFns = instance.options.filterFns\n\n        return isFunction(column.filterFn)\n          ? column.filterFn\n          : column.filterFn === 'auto'\n          ? column.getAutoFilterFn()\n          : (userFilterFns as Record<string, any>)?.[\n              column.filterFn as string\n            ] ??\n            (filterFns[\n              column.filterFn as BuiltInFilterFn\n            ] as FilterFn<TGenerics>)\n      },\n      getCanFilter: () => {\n        return (\n          (column.enableColumnFilter ?? true) &&\n          (instance.options.enableColumnFilters ?? true) &&\n          (instance.options.enableFilters ?? true) &&\n          !!column.accessorFn\n        )\n      },\n\n      getCanGlobalFilter: () => {\n        return (\n          (column.enableGlobalFilter ?? true) &&\n          (instance.options.enableGlobalFilter ?? true) &&\n          (instance.options.enableFilters ?? true) &&\n          (instance.options.getColumnCanGlobalFilter?.(column) ?? true) &&\n          !!column.accessorFn\n        )\n      },\n\n      getIsFiltered: () => column.getFilterIndex() > -1,\n\n      getFilterValue: () =>\n        instance.getState().columnFilters?.find(d => d.id === column.id)?.value,\n\n      getFilterIndex: () =>\n        instance.getState().columnFilters?.findIndex(d => d.id === column.id) ??\n        -1,\n\n      setFilterValue: value => {\n        instance.setColumnFilters(old => {\n          const filterFn = column.getFilterFn()\n          const previousfilter = old?.find(d => d.id === column.id)\n\n          const newFilter = functionalUpdate(\n            value,\n            previousfilter ? previousfilter.value : undefined\n          )\n\n          //\n          if (\n            shouldAutoRemoveFilter(\n              filterFn as FilterFn<TGenerics>,\n              newFilter,\n              column\n            )\n          ) {\n            return old?.filter(d => d.id !== column.id) ?? []\n          }\n\n          const newFilterObj = { id: column.id, value: newFilter }\n\n          if (previousfilter) {\n            return (\n              old?.map(d => {\n                if (d.id === column.id) {\n                  return newFilterObj\n                }\n                return d\n              }) ?? []\n            )\n          }\n\n          if (old?.length) {\n            return [...old, newFilterObj]\n          }\n\n          return [newFilterObj]\n        })\n      },\n      _getFacetedRowModel:\n        instance.options.getFacetedRowModel &&\n        instance.options.getFacetedRowModel(instance, column.id),\n      getFacetedRowModel: () => {\n        if (!column._getFacetedRowModel) {\n          return instance.getPreFilteredRowModel()\n        }\n\n        return column._getFacetedRowModel()\n      },\n      _getFacetedUniqueValues:\n        instance.options.getFacetedUniqueValues &&\n        instance.options.getFacetedUniqueValues(instance, column.id),\n      getFacetedUniqueValues: () => {\n        if (!column._getFacetedUniqueValues) {\n          return new Map()\n        }\n\n        return column._getFacetedUniqueValues()\n      },\n      _getFacetedMinMaxValues:\n        instance.options.getFacetedMinMaxValues &&\n        instance.options.getFacetedMinMaxValues(instance, column.id),\n      getFacetedMinMaxValues: () => {\n        if (!column._getFacetedMinMaxValues) {\n          return undefined\n        }\n\n        return column._getFacetedMinMaxValues()\n      },\n      // () => [column.getFacetedRowModel()],\n      // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n    }\n  },\n\n  createRow: <TGenerics extends TableGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): FiltersRow<TGenerics> => {\n    return {\n      columnFilters: {},\n      columnFiltersMeta: {},\n      subRowsByFacetId: {},\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): FiltersInstance<TGenerics> => {\n    return {\n      getGlobalAutoFilterFn: () => {\n        return filterFns.includesString\n      },\n\n      getGlobalFilterFn: () => {\n        const { filterFns: userFilterFns, globalFilterFn: globalFilterFn } =\n          instance.options\n\n        return isFunction(globalFilterFn)\n          ? globalFilterFn\n          : globalFilterFn === 'auto'\n          ? instance.getGlobalAutoFilterFn()\n          : (userFilterFns as Record<string, any>)?.[\n              globalFilterFn as string\n            ] ??\n            (filterFns[\n              globalFilterFn as BuiltInFilterFn\n            ] as FilterFn<TGenerics>)\n      },\n\n      setColumnFilters: (updater: Updater<ColumnFiltersState>) => {\n        const leafColumns = instance.getAllLeafColumns()\n\n        const updateFn = (old: ColumnFiltersState) => {\n          return functionalUpdate(updater, old)?.filter(filter => {\n            const column = leafColumns.find(d => d.id === filter.id)\n\n            if (column) {\n              const filterFn = column.getFilterFn()\n\n              if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                return false\n              }\n            }\n\n            return true\n          })\n        }\n\n        instance.options.onColumnFiltersChange?.(updateFn)\n      },\n\n      setGlobalFilter: updater => {\n        instance.options.onGlobalFilterChange?.(updater)\n      },\n\n      resetGlobalFilter: defaultState => {\n        instance.setGlobalFilter(\n          defaultState ? undefined : instance.initialState.globalFilter\n        )\n      },\n\n      resetColumnFilters: defaultState => {\n        instance.setColumnFilters(\n          defaultState ? [] : instance.initialState?.columnFilters ?? []\n        )\n      },\n\n      getPreFilteredRowModel: () => instance.getCoreRowModel(),\n      _getFilteredRowModel:\n        instance.options.getFilteredRowModel &&\n        instance.options.getFilteredRowModel(instance),\n      getFilteredRowModel: () => {\n        if (\n          instance.options.manualFiltering ||\n          !instance._getFilteredRowModel\n        ) {\n          return instance.getPreFilteredRowModel()\n        }\n\n        return instance._getFilteredRowModel()\n      },\n\n      _getGlobalFacetedRowModel:\n        instance.options.getFacetedRowModel &&\n        instance.options.getFacetedRowModel(instance, '__global__'),\n\n      getGlobalFacetedRowModel: () => {\n        if (\n          instance.options.manualFiltering ||\n          !instance._getGlobalFacetedRowModel\n        ) {\n          return instance.getPreFilteredRowModel()\n        }\n\n        return instance._getGlobalFacetedRowModel()\n      },\n\n      _getGlobalFacetedUniqueValues:\n        instance.options.getFacetedUniqueValues &&\n        instance.options.getFacetedUniqueValues(instance, '__global__'),\n      getGlobalFacetedUniqueValues: () => {\n        if (!instance._getGlobalFacetedUniqueValues) {\n          return new Map()\n        }\n\n        return instance._getGlobalFacetedUniqueValues()\n      },\n\n      _getGlobalFacetedMinMaxValues:\n        instance.options.getFacetedMinMaxValues &&\n        instance.options.getFacetedMinMaxValues(instance, '__global__'),\n      getGlobalFacetedMinMaxValues: () => {\n        if (!instance._getGlobalFacetedMinMaxValues) {\n          return\n        }\n\n        return instance._getGlobalFacetedMinMaxValues()\n      },\n    }\n  },\n}\n\nexport function shouldAutoRemoveFilter<TGenerics extends TableGenerics>(\n  filterFn?: FilterFn<TGenerics>,\n  value?: any,\n  column?: Column<TGenerics>\n) {\n  return (\n    (filterFn && filterFn.autoRemove\n      ? filterFn.autoRemove(value, column)\n      : false) ||\n    typeof value === 'undefined' ||\n    (typeof value === 'string' && !value)\n  )\n}\n","export const aggregationFns = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count,\n}\n\nexport type BuiltInAggregationFn = keyof typeof aggregationFns\n\nfunction sum(_getLeafValues: () => unknown[], getChildValues: () => unknown[]) {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return getChildValues().reduce(\n    (sum: number, next: unknown) => sum + (typeof next === 'number' ? next : 0),\n    0\n  )\n}\n\nfunction min(_getLeafValues: () => unknown[], getChildValues: () => unknown[]) {\n  let min: number | undefined\n\n  for (const value of getChildValues() as number[]) {\n    if (\n      value != null &&\n      (min! > value || (min === undefined && value >= value))\n    ) {\n      min = value\n    }\n  }\n\n  return min\n}\n\nfunction max(_getLeafValues: () => unknown[], getChildValues: () => unknown[]) {\n  let max: number | undefined\n\n  for (const value of getChildValues() as number[]) {\n    if (\n      value != null &&\n      (max! < value || (max === undefined && value >= value))\n    ) {\n      max = value\n    }\n  }\n\n  return max\n}\n\nfunction extent(\n  _getLeafValues: () => unknown[],\n  getChildValues: () => unknown[]\n) {\n  let min: number | undefined\n  let max: number | undefined\n\n  for (const value of getChildValues() as number[]) {\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value\n      } else {\n        if (min > value) min = value\n        if (max! < value) max = value\n      }\n    }\n  }\n\n  return [min, max]\n}\n\nexport function mean(getLeafValues: () => unknown[]) {\n  let count = 0\n  let sum = 0\n\n  for (let value of getLeafValues() as number[]) {\n    if (value != null && (value = +value) >= value) {\n      ++count, (sum += value)\n    }\n  }\n\n  if (count) return sum / count\n\n  return\n}\n\nfunction median(getLeafValues: () => unknown[]) {\n  const leafValues = getLeafValues()\n  if (!leafValues.length) {\n    return\n  }\n\n  let min = 0\n  let max = 0\n\n  leafValues.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value)\n      max = Math.max(max, value)\n    }\n  })\n\n  return (min + max) / 2\n}\n\nfunction unique<T>(getLeafValues: () => T[]) {\n  return Array.from(new Set(getLeafValues()).values())\n}\n\nfunction uniqueCount(getLeafValues: () => unknown[]) {\n  return new Set(getLeafValues()).size\n}\n\nfunction count(getLeafValues: () => unknown[]) {\n  return getLeafValues().length\n}\n","import { RowModel } from '..'\nimport { BuiltInAggregationFn, aggregationFns } from '../aggregationFns'\nimport {\n  Cell,\n  Column,\n  OnChangeFn,\n  TableInstance,\n  Row,\n  Updater,\n  Renderable,\n  TableGenerics,\n  TableFeature,\n} from '../types'\nimport { isFunction, makeStateUpdater, Overwrite } from '../utils'\n\nexport type GroupingState = string[]\n\nexport type AggregationFn<TGenerics extends TableGenerics> = (\n  getLeafValues: () => TGenerics['Value'][],\n  getChildValues: () => TGenerics['Value'][]\n) => any\n\nexport type CustomAggregationFns<TGenerics extends TableGenerics> = Record<\n  string,\n  AggregationFn<TGenerics>\n>\n\nexport type AggregationFnOption<TGenerics extends TableGenerics> =\n  | 'auto'\n  | BuiltInAggregationFn\n  | keyof TGenerics['AggregationFns']\n  | AggregationFn<TGenerics>\n\nexport type GroupingTableState = {\n  grouping: GroupingState\n}\n\nexport type GroupingColumnDef<TGenerics extends TableGenerics> = {\n  aggregationFn?: AggregationFnOption<Overwrite<TGenerics, { Value: any }>>\n  aggregateValue?: (columnValue: unknown) => any\n  aggregatedCell?: Renderable<\n    TGenerics,\n    {\n      instance: TableInstance<TGenerics>\n      row: Row<TGenerics>\n      column: Column<TGenerics>\n      cell: Cell<TGenerics>\n      getValue: () => TGenerics['Value']\n    }\n  >\n  enableGrouping?: boolean\n}\n\nexport type GroupingColumn<TGenerics extends TableGenerics> = {\n  aggregationFn?: AggregationFnOption<Overwrite<TGenerics, { Value: any }>>\n  getCanGroup: () => boolean\n  getIsGrouped: () => boolean\n  getGroupedIndex: () => number\n  toggleGrouping: () => void\n  getToggleGroupingHandler: () => () => void\n  getColumnAutoAggregationFn: () => AggregationFn<TGenerics> | undefined\n  getColumnAggregationFn: () => AggregationFn<TGenerics> | undefined\n}\n\nexport type GroupingRow = {\n  groupingColumnId?: string\n  groupingValue?: any\n  getIsGrouped: () => boolean\n  groupingValuesCache: Record<string, any>\n}\n\nexport type GroupingCell<TGenerics extends TableGenerics> = {\n  getIsGrouped: () => boolean\n  getIsPlaceholder: () => boolean\n  getIsAggregated: () => boolean\n  renderAggregatedCell: () => string | null | TGenerics['Rendered']\n}\n\nexport type ColumnDefaultOptions = {\n  // Column\n  onGroupingChange: OnChangeFn<GroupingState>\n  enableGrouping: boolean\n}\n\nexport type GroupingOptions<TGenerics extends TableGenerics> = {\n  manualGrouping?: boolean\n  aggregationFns?: TGenerics['AggregationFns']\n  onGroupingChange?: OnChangeFn<GroupingState>\n  enableGrouping?: boolean\n  enableGroupingRemoval?: boolean\n  getGroupedRowModel?: (\n    instance: TableInstance<TGenerics>\n  ) => () => RowModel<TGenerics>\n\n  groupedColumnMode?: false | 'reorder' | 'remove'\n}\n\nexport type GroupingColumnMode = false | 'reorder' | 'remove'\n\nexport type GroupingInstance<TGenerics extends TableGenerics> = {\n  setGrouping: (updater: Updater<GroupingState>) => void\n  resetGrouping: (defaultState?: boolean) => void\n  getPreGroupedRowModel: () => RowModel<TGenerics>\n  getGroupedRowModel: () => RowModel<TGenerics>\n  _getGroupedRowModel?: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Grouping: TableFeature = {\n  getDefaultColumn: <\n    TGenerics extends TableGenerics\n  >(): GroupingColumnDef<TGenerics> => {\n    return {\n      aggregationFn: 'auto',\n    }\n  },\n\n  getInitialState: (state): GroupingTableState => {\n    return {\n      grouping: [],\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): GroupingOptions<TGenerics> => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', instance),\n      groupedColumnMode: 'reorder',\n    }\n  },\n\n  createColumn: <TGenerics extends TableGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): GroupingColumn<TGenerics> => {\n    return {\n      toggleGrouping: () => {\n        instance.setGrouping(old => {\n          // Find any existing grouping for this column\n          if (old?.includes(column.id)) {\n            return old.filter(d => d !== column.id)\n          }\n\n          return [...(old ?? []), column.id]\n        })\n      },\n\n      getCanGroup: () => {\n        return (\n          column.enableGrouping ??\n          true ??\n          instance.options.enableGrouping ??\n          true ??\n          !!column.accessorFn\n        )\n      },\n\n      getIsGrouped: () => {\n        return instance.getState().grouping?.includes(column.id)\n      },\n\n      getGroupedIndex: () => instance.getState().grouping?.indexOf(column.id),\n\n      getToggleGroupingHandler: () => {\n        const canGroup = column.getCanGroup()\n\n        return () => {\n          if (!canGroup) return\n          column.toggleGrouping()\n        }\n      },\n      getColumnAutoAggregationFn: () => {\n        const firstRow = instance.getCoreRowModel().flatRows[0]\n\n        const value = firstRow?.getValue(column.id)\n\n        if (typeof value === 'number') {\n          return aggregationFns.sum\n        }\n\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return aggregationFns.extent\n        }\n\n        return aggregationFns.count\n      },\n      getColumnAggregationFn: () => {\n        const userAggregationFns = instance.options.aggregationFns\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return isFunction(column.aggregationFn)\n          ? column.aggregationFn\n          : column.aggregationFn === 'auto'\n          ? column.getColumnAutoAggregationFn()\n          : (userAggregationFns as Record<string, any>)?.[\n              column.aggregationFn as string\n            ] ??\n            (aggregationFns[\n              column.aggregationFn as BuiltInAggregationFn\n            ] as AggregationFn<TGenerics>)\n      },\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): GroupingInstance<TGenerics> => {\n    return {\n      setGrouping: updater => instance.options.onGroupingChange?.(updater),\n\n      resetGrouping: defaultState => {\n        instance.setGrouping(\n          defaultState ? [] : instance.initialState?.grouping ?? []\n        )\n      },\n\n      getPreGroupedRowModel: () => instance.getSortedRowModel(),\n      getGroupedRowModel: () => {\n        if (\n          !instance._getGroupedRowModel &&\n          instance.options.getGroupedRowModel\n        ) {\n          instance._getGroupedRowModel =\n            instance.options.getGroupedRowModel(instance)\n        }\n\n        if (instance.options.manualGrouping || !instance._getGroupedRowModel) {\n          return instance.getPreGroupedRowModel()\n        }\n\n        return instance._getGroupedRowModel()\n      },\n    }\n  },\n\n  createRow: <TGenerics extends TableGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): GroupingRow => {\n    return {\n      getIsGrouped: () => !!row.groupingColumnId,\n      groupingValuesCache: {},\n    }\n  },\n\n  createCell: <TGenerics extends TableGenerics>(\n    cell: Cell<TGenerics>,\n    column: Column<TGenerics>,\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): GroupingCell<TGenerics> => {\n    return {\n      getIsGrouped: () =>\n        column.getIsGrouped() && column.id === row.groupingColumnId,\n      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),\n      getIsAggregated: () =>\n        !cell.getIsGrouped() &&\n        !cell.getIsPlaceholder() &&\n        row.subRows?.length > 1,\n      renderAggregatedCell: () => {\n        const template = column.aggregatedCell ?? column.cell\n\n        return template\n          ? instance._render(template, {\n              instance,\n              column,\n              row,\n              cell,\n              getValue: cell.getValue,\n            })\n          : null\n      },\n    }\n  },\n}\n\nexport function orderColumns<TGenerics extends TableGenerics>(\n  leafColumns: Column<TGenerics>[],\n  grouping: string[],\n  groupedColumnMode?: GroupingColumnMode\n) {\n  if (!grouping?.length || !groupedColumnMode) {\n    return leafColumns\n  }\n\n  const nonGroupingColumns = leafColumns.filter(\n    col => !grouping.includes(col.id)\n  )\n\n  if (groupedColumnMode === 'remove') {\n    return nonGroupingColumns\n  }\n\n  const groupingColumns = grouping\n    .map(g => leafColumns.find(col => col.id === g)!)\n    .filter(Boolean)\n\n  return [...groupingColumns, ...nonGroupingColumns]\n}\n","import { makeStateUpdater, memo } from '../utils'\n\nimport {\n  TableInstance,\n  OnChangeFn,\n  Updater,\n  Column,\n  TableGenerics,\n  TableFeature,\n} from '../types'\n\nimport { Grouping, orderColumns } from './Grouping'\n\nexport type ColumnOrderTableState = {\n  columnOrder: ColumnOrderState\n}\n\nexport type ColumnOrderState = string[]\n\nexport type ColumnOrderOptions = {\n  onColumnOrderChange?: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderDefaultOptions = {\n  onColumnOrderChange: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderInstance<TGenerics extends TableGenerics> = {\n  setColumnOrder: (updater: Updater<ColumnOrderState>) => void\n  resetColumnOrder: (defaultState?: boolean) => void\n  _getOrderColumnsFn: () => (\n    columns: Column<TGenerics>[]\n  ) => Column<TGenerics>[]\n}\n\n//\n\nexport const Ordering: TableFeature = {\n  getInitialState: (state): ColumnOrderTableState => {\n    return {\n      columnOrder: [],\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnOrderDefaultOptions => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', instance),\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnOrderInstance<TGenerics> => {\n    return {\n      setColumnOrder: updater =>\n        instance.options.onColumnOrderChange?.(updater),\n      resetColumnOrder: defaultState => {\n        instance.setColumnOrder(\n          defaultState ? [] : instance.initialState.columnOrder ?? []\n        )\n      },\n      _getOrderColumnsFn: memo(\n        () => [\n          instance.getState().columnOrder,\n          instance.getState().grouping,\n          instance.options.groupedColumnMode,\n        ],\n        (columnOrder, grouping, groupedColumnMode) => columns => {\n          // Sort grouped columns to the start of the column list\n          // before the headers are built\n          let orderedColumns: Column<TGenerics>[] = []\n\n          // If there is no order, return the normal columns\n          if (!columnOrder?.length) {\n            orderedColumns = columns\n          } else {\n            const columnOrderCopy = [...columnOrder]\n\n            // If there is an order, make a copy of the columns\n            const columnsCopy = [...columns]\n\n            // And make a new ordered array of the columns\n\n            // Loop over the columns and place them in order into the new array\n            while (columnsCopy.length && columnOrderCopy.length) {\n              const targetColumnId = columnOrderCopy.shift()\n              const foundIndex = columnsCopy.findIndex(\n                d => d.id === targetColumnId\n              )\n              if (foundIndex > -1) {\n                orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]!)\n              }\n            }\n\n            // If there are any columns left, add them to the end\n            orderedColumns = [...orderedColumns, ...columnsCopy]\n          }\n\n          return orderColumns(orderedColumns, grouping, groupedColumnMode)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getOrderColumnsFn',\n          // debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n    }\n  },\n}\n","import {\n  OnChangeFn,\n  TableGenerics,\n  TableInstance,\n  RowModel,\n  Updater,\n  TableFeature,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo } from '../utils'\n\nexport type PaginationState = {\n  pageIndex: number\n  pageSize: number\n  pageCount?: number\n}\n\nexport type PaginationTableState = {\n  pagination: PaginationState\n}\n\nexport type PaginationInitialTableState = {\n  pagination?: Partial<PaginationState>\n}\n\nexport type PaginationOptions<TGenerics extends TableGenerics> = {\n  manualPagination?: boolean\n  onPaginationChange?: OnChangeFn<PaginationState>\n  autoResetPageIndex?: boolean\n  getPaginationRowModel?: (\n    instance: TableInstance<TGenerics>\n  ) => () => RowModel<TGenerics>\n}\n\nexport type PaginationDefaultOptions = {\n  onPaginationChange: OnChangeFn<PaginationState>\n}\n\nexport type PaginationInstance<TGenerics extends TableGenerics> = {\n  _autoResetPageIndex: () => void\n  setPagination: (updater: Updater<PaginationState>) => void\n  resetPagination: (defaultState?: boolean) => void\n  setPageIndex: (updater: Updater<number>) => void\n  resetPageIndex: (defaultState?: boolean) => void\n  setPageSize: (updater: Updater<number>) => void\n  resetPageSize: (defaultState?: boolean) => void\n  setPageCount: (updater: Updater<number>) => void\n  getPageOptions: () => number[]\n  getCanPreviousPage: () => boolean\n  getCanNextPage: () => boolean\n  previousPage: () => void\n  nextPage: () => void\n  getPrePaginationRowModel: () => RowModel<TGenerics>\n  getPaginationRowModel: () => RowModel<TGenerics>\n  _getPaginationRowModel?: () => RowModel<TGenerics>\n  getPageCount: () => number\n}\n\n//\n\nconst defaultPageIndex = 0\nconst defaultPageSize = 10\n\nconst getDefaultPaginationState = (): PaginationState => ({\n  pageIndex: defaultPageIndex,\n  pageSize: defaultPageSize,\n})\n\nexport const Pagination: TableFeature = {\n  getInitialState: (state): PaginationTableState => {\n    return {\n      ...state,\n      pagination: {\n        ...getDefaultPaginationState(),\n        ...state?.pagination,\n      },\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): PaginationDefaultOptions => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', instance),\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): PaginationInstance<TGenerics> => {\n    let registered = false\n    let queued = false\n\n    return {\n      _autoResetPageIndex: () => {\n        if (!registered) {\n          instance._queue(() => {\n            registered = true\n          })\n          return\n        }\n\n        if (\n          instance.options.autoResetAll ??\n          instance.options.autoResetPageIndex ??\n          !instance.options.manualPagination\n        ) {\n          if (queued) return\n          queued = true\n          instance._queue(() => {\n            instance.resetPageIndex()\n            queued = false\n          })\n        }\n      },\n      setPagination: updater => {\n        const safeUpdater: Updater<PaginationState> = old => {\n          let newState = functionalUpdate(updater, old)\n\n          return newState\n        }\n\n        return instance.options.onPaginationChange?.(safeUpdater)\n      },\n      resetPagination: defaultState => {\n        instance.setPagination(\n          defaultState\n            ? getDefaultPaginationState()\n            : instance.initialState.pagination ?? getDefaultPaginationState()\n        )\n      },\n      setPageIndex: updater => {\n        instance.setPagination(old => {\n          let pageIndex = functionalUpdate(updater, old.pageIndex)\n\n          const maxPageIndex =\n            typeof old.pageCount !== 'undefined'\n              ? old.pageCount - 1\n              : Number.MAX_SAFE_INTEGER\n\n          pageIndex = Math.min(Math.max(0, pageIndex), maxPageIndex)\n\n          return {\n            ...old,\n            pageIndex,\n          }\n        })\n      },\n      resetPageIndex: defaultState => {\n        instance.setPageIndex(\n          defaultState\n            ? defaultPageIndex\n            : instance.initialState?.pagination?.pageIndex ?? defaultPageIndex\n        )\n      },\n      resetPageSize: defaultState => {\n        instance.setPageSize(\n          defaultState\n            ? defaultPageSize\n            : instance.initialState?.pagination?.pageSize ?? defaultPageSize\n        )\n      },\n      setPageSize: updater => {\n        instance.setPagination(old => {\n          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize))\n          const topRowIndex = old.pageSize * old.pageIndex!\n          const pageIndex = Math.floor(topRowIndex / pageSize)\n\n          return {\n            ...old,\n            pageIndex,\n            pageSize,\n          }\n        })\n      },\n      setPageCount: updater =>\n        instance.setPagination(old => {\n          let newPageCount = functionalUpdate(updater, old.pageCount ?? -1)\n\n          if (typeof newPageCount === 'number') {\n            newPageCount = Math.max(-1, newPageCount)\n          }\n\n          return {\n            ...old,\n            pageCount: newPageCount,\n          }\n        }),\n\n      getPageOptions: memo(\n        () => [\n          instance.getState().pagination.pageSize,\n          instance.getState().pagination.pageCount,\n        ],\n        (pageSize, pageCount) => {\n          let pageOptions: number[] = []\n          if (pageCount && pageCount > 0) {\n            pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i)\n          }\n          return pageOptions\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getPageOptions',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      getCanPreviousPage: () => instance.getState().pagination.pageIndex > 0,\n\n      getCanNextPage: () => {\n        const { pageIndex } = instance.getState().pagination\n\n        const pageCount = instance.getPageCount()\n\n        if (pageCount === -1) {\n          return true\n        }\n\n        if (pageCount === 0) {\n          return false\n        }\n\n        return pageIndex < pageCount - 1\n      },\n\n      previousPage: () => {\n        return instance.setPageIndex(old => old - 1)\n      },\n\n      nextPage: () => {\n        return instance.setPageIndex(old => {\n          return old + 1\n        })\n      },\n\n      getPrePaginationRowModel: () => instance.getExpandedRowModel(),\n      getPaginationRowModel: () => {\n        if (\n          !instance._getPaginationRowModel &&\n          instance.options.getPaginationRowModel\n        ) {\n          instance._getPaginationRowModel =\n            instance.options.getPaginationRowModel(instance)\n        }\n\n        if (\n          instance.options.manualPagination ||\n          !instance._getPaginationRowModel\n        ) {\n          return instance.getPrePaginationRowModel()\n        }\n\n        return instance._getPaginationRowModel()\n      },\n\n      getPageCount: () => {\n        const { pageCount } = instance.getState().pagination\n\n        if (typeof pageCount !== 'undefined') {\n          return pageCount\n        }\n\n        return Math.ceil(\n          instance.getPrePaginationRowModel().rows.length /\n            instance.getState().pagination.pageSize\n        )\n      },\n    }\n  },\n}\n","import {\n  OnChangeFn,\n  Updater,\n  TableInstance,\n  Column,\n  TableGenerics,\n  Row,\n  Cell,\n  TableFeature,\n} from '../types'\nimport { makeStateUpdater, memo } from '../utils'\n\nexport type ColumnPinningPosition = false | 'left' | 'right'\n\nexport type ColumnPinningState = {\n  left?: string[]\n  right?: string[]\n}\n\nexport type ColumnPinningTableState = {\n  columnPinning: ColumnPinningState\n}\n\nexport type ColumnPinningOptions = {\n  onColumnPinningChange?: OnChangeFn<ColumnPinningState>\n  enablePinning?: boolean\n}\n\nexport type ColumnPinningDefaultOptions = {\n  onColumnPinningChange: OnChangeFn<ColumnPinningState>\n}\n\nexport type ColumnPinningColumnDef = {\n  enablePinning?: boolean\n}\n\nexport type ColumnPinningColumn = {\n  getCanPin: () => boolean\n  getPinnedIndex: () => number\n  getIsPinned: () => ColumnPinningPosition\n  pin: (position: ColumnPinningPosition) => void\n}\n\nexport type ColumnPinningRow<TGenerics extends TableGenerics> = {\n  getLeftVisibleCells: () => Cell<TGenerics>[]\n  getCenterVisibleCells: () => Cell<TGenerics>[]\n  getRightVisibleCells: () => Cell<TGenerics>[]\n}\n\nexport type ColumnPinningInstance<TGenerics extends TableGenerics> = {\n  setColumnPinning: (updater: Updater<ColumnPinningState>) => void\n  resetColumnPinning: (defaultState?: boolean) => void\n  getIsSomeColumnsPinned: () => boolean\n  getLeftLeafColumns: () => Column<TGenerics>[]\n  getRightLeafColumns: () => Column<TGenerics>[]\n  getCenterLeafColumns: () => Column<TGenerics>[]\n}\n\n//\n\nconst getDefaultPinningState = (): ColumnPinningState => ({\n  left: [],\n  right: [],\n})\n\nexport const Pinning: TableFeature = {\n  getInitialState: (state): ColumnPinningTableState => {\n    return {\n      columnPinning: getDefaultPinningState(),\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningDefaultOptions => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', instance),\n    }\n  },\n\n  createColumn: <TGenerics extends TableGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningColumn => {\n    return {\n      pin: position => {\n        const columnIds = column\n          .getLeafColumns()\n          .map(d => d.id)\n          .filter(Boolean) as string[]\n\n        instance.setColumnPinning(old => {\n          if (position === 'right') {\n            return {\n              left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n              right: [\n                ...(old?.right ?? []).filter(d => !columnIds?.includes(d)),\n                ...columnIds,\n              ],\n            }\n          }\n\n          if (position === 'left') {\n            return {\n              left: [\n                ...(old?.left ?? []).filter(d => !columnIds?.includes(d)),\n                ...columnIds,\n              ],\n              right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n            }\n          }\n\n          return {\n            left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n            right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n          }\n        })\n      },\n\n      getCanPin: () => {\n        const leafColumns = column.getLeafColumns()\n\n        return leafColumns.some(\n          d =>\n            (d.enablePinning ?? true) &&\n            (instance.options.enablePinning ?? true)\n        )\n      },\n\n      getIsPinned: () => {\n        const leafColumnIds = column.getLeafColumns().map(d => d.id)\n\n        const { left, right } = instance.getState().columnPinning\n\n        const isLeft = leafColumnIds.some(d => left?.includes(d))\n        const isRight = leafColumnIds.some(d => right?.includes(d))\n\n        return isLeft ? 'left' : isRight ? 'right' : false\n      },\n\n      getPinnedIndex: () => {\n        const position = column.getIsPinned()\n\n        return position\n          ? instance.getState().columnPinning?.[position]?.indexOf(column.id) ??\n              -1\n          : 0\n      },\n    }\n  },\n\n  createRow: <TGenerics extends TableGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningRow<TGenerics> => {\n    return {\n      getCenterVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allCells, left, right) => {\n          const leftAndRight: string[] = [...(left ?? []), ...(right ?? [])]\n\n          return allCells.filter(d => !leftAndRight.includes(d.columnId))\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'production' &&\n            'row.getCenterVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getLeftVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.left,\n          ,\n        ],\n        (allCells, left) => {\n          const cells = (left ?? [])\n            .map(columnId => allCells.find(cell => cell.columnId === columnId)!)\n            .filter(Boolean)\n            .map(d => ({ ...d, position: 'left' } as Cell<TGenerics>))\n\n          return cells\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'production' && 'row.getLeftVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getRightVisibleCells: memo(\n        () => [\n          row._getAllVisibleCells(),\n          instance.getState().columnPinning.right,\n        ],\n        (allCells, right) => {\n          const cells = (right ?? [])\n            .map(columnId => allCells.find(cell => cell.columnId === columnId)!)\n            .filter(Boolean)\n            .map(d => ({ ...d, position: 'left' } as Cell<TGenerics>))\n\n          return cells\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'production' && 'row.getRightVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): ColumnPinningInstance<TGenerics> => {\n    return {\n      setColumnPinning: updater =>\n        instance.options.onColumnPinningChange?.(updater),\n\n      resetColumnPinning: defaultState =>\n        instance.setColumnPinning(\n          defaultState\n            ? getDefaultPinningState()\n            : instance.initialState?.columnPinning ?? getDefaultPinningState()\n        ),\n\n      getIsSomeColumnsPinned: () => {\n        const { left, right } = instance.getState().columnPinning\n\n        return Boolean(left?.length || right?.length)\n      },\n\n      getLeftLeafColumns: memo(\n        () => [\n          instance.getAllLeafColumns(),\n          instance.getState().columnPinning.left,\n        ],\n        (allColumns, left) => {\n          return (left ?? [])\n            .map(columnId => allColumns.find(column => column.id === columnId)!)\n            .filter(Boolean)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getLeftLeafColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      getRightLeafColumns: memo(\n        () => [\n          instance.getAllLeafColumns(),\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, right) => {\n          return (right ?? [])\n            .map(columnId => allColumns.find(column => column.id === columnId)!)\n            .filter(Boolean)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getRightLeafColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n\n      getCenterLeafColumns: memo(\n        () => [\n          instance.getAllLeafColumns(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, left, right) => {\n          const leftAndRight: string[] = [...(left ?? []), ...(right ?? [])]\n\n          return allColumns.filter(d => !leftAndRight.includes(d.id))\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getCenterLeafColumns',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      ),\n    }\n  },\n}\n","import {\n  OnChangeFn,\n  TableGenerics,\n  TableInstance,\n  Row,\n  RowModel,\n  Updater,\n  TableFeature,\n} from '../types'\nimport { makeStateUpdater, memo } from '../utils'\n\nexport type RowSelectionState = Record<string, boolean>\n\nexport type RowSelectionTableState = {\n  rowSelection: RowSelectionState\n}\n\nexport type RowSelectionOptions<TGenerics extends TableGenerics> = {\n  enableRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  enableMultiRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  enableSubRowSelection?: boolean | ((row: Row<TGenerics>) => boolean)\n  onRowSelectionChange?: OnChangeFn<RowSelectionState>\n  // enableGroupingRowSelection?:\n  //   | boolean\n  //   | ((\n  //       row: Row<TGenerics>\n  //     ) => boolean)\n  // isAdditiveSelectEvent?: (e: unknown) => boolean\n  // isInclusiveSelectEvent?: (e: unknown) => boolean\n  // selectRowsFn?: (\n  //   instance: TableInstance<\n  //     TData,\n  //     TValue,\n  //     TFilterFns,\n  //     TSortingFns,\n  //     TAggregationFns\n  //   >,\n  //   rowModel: RowModel<TGenerics>\n  // ) => RowModel<TGenerics>\n}\n\nexport type RowSelectionRow = {\n  getIsSelected: () => boolean\n  getIsSomeSelected: () => boolean\n  getCanSelect: () => boolean\n  getCanMultiSelect: () => boolean\n  getCanSelectSubRows: () => boolean\n  toggleSelected: (value?: boolean) => void\n  getToggleSelectedHandler: () => (event: unknown) => void\n}\n\nexport type RowSelectionInstance<TGenerics extends TableGenerics> = {\n  getToggleAllRowsSelectedHandler: () => (event: unknown) => void\n  getToggleAllPageRowsSelectedHandler: () => (event: unknown) => void\n  setRowSelection: (updater: Updater<RowSelectionState>) => void\n  resetRowSelection: (defaultState?: boolean) => void\n  getIsAllRowsSelected: () => boolean\n  getIsAllPageRowsSelected: () => boolean\n  getIsSomeRowsSelected: () => boolean\n  getIsSomePageRowsSelected: () => boolean\n  toggleAllRowsSelected: (value: boolean) => void\n  toggleAllPageRowsSelected: (value: boolean) => void\n  getPreSelectedRowModel: () => RowModel<TGenerics>\n  getSelectedRowModel: () => RowModel<TGenerics>\n  getFilteredSelectedRowModel: () => RowModel<TGenerics>\n  getGroupedSelectedRowModel: () => RowModel<TGenerics>\n}\n\n//\n\nexport const RowSelection: TableFeature = {\n  getInitialState: (state): RowSelectionTableState => {\n    return {\n      rowSelection: {},\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): RowSelectionOptions<TGenerics> => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', instance),\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true,\n      // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): RowSelectionInstance<TGenerics> => {\n    return {\n      setRowSelection: updater =>\n        instance.options.onRowSelectionChange?.(updater),\n      resetRowSelection: defaultState =>\n        instance.setRowSelection(\n          defaultState ? {} : instance.initialState.rowSelection ?? {}\n        ),\n      toggleAllRowsSelected: value => {\n        instance.setRowSelection(old => {\n          value =\n            typeof value !== 'undefined'\n              ? value\n              : !instance.getIsAllRowsSelected()\n\n          const rowSelection = { ...old }\n\n          const preGroupedFlatRows = instance.getPreGroupedRowModel().flatRows\n\n          // We don't use `mutateRowIsSelected` here for performance reasons.\n          // All of the rows are flat already, so it wouldn't be worth it\n          if (value) {\n            preGroupedFlatRows.forEach(row => {\n              rowSelection[row.id] = true\n            })\n          } else {\n            preGroupedFlatRows.forEach(row => {\n              delete rowSelection[row.id]\n            })\n          }\n\n          return rowSelection\n        })\n      },\n      toggleAllPageRowsSelected: value =>\n        instance.setRowSelection(old => {\n          const selectAll =\n            typeof value !== 'undefined'\n              ? value\n              : !instance.getIsAllPageRowsSelected()\n\n          const rowSelection: RowSelectionState = { ...old }\n\n          instance.getRowModel().rows.forEach(row => {\n            mutateRowIsSelected(rowSelection, row.id, value, instance)\n          })\n\n          return rowSelection\n        }),\n\n      // addRowSelectionRange: rowId => {\n      //   const {\n      //     rows,\n      //     rowsById,\n      //     options: { selectGroupingRows, selectSubRows },\n      //   } = instance\n\n      //   const findSelectedRow = (rows: Row[]) => {\n      //     let found\n      //     rows.find(d => {\n      //       if (d.getIsSelected()) {\n      //         found = d\n      //         return true\n      //       }\n      //       const subFound = findSelectedRow(d.subRows || [])\n      //       if (subFound) {\n      //         found = subFound\n      //         return true\n      //       }\n      //       return false\n      //     })\n      //     return found\n      //   }\n\n      //   const firstRow = findSelectedRow(rows) || rows[0]\n      //   const lastRow = rowsById[rowId]\n\n      //   let include = false\n      //   const selectedRowIds = {}\n\n      //   const addRow = (row: Row) => {\n      //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n      //       rowsById,\n      //       selectGroupingRows: selectGroupingRows!,\n      //       selectSubRows: selectSubRows!,\n      //     })\n      //   }\n\n      //   instance.rows.forEach(row => {\n      //     const isFirstRow = row.id === firstRow.id\n      //     const isLastRow = row.id === lastRow.id\n\n      //     if (isFirstRow || isLastRow) {\n      //       if (!include) {\n      //         include = true\n      //       } else if (include) {\n      //         addRow(row)\n      //         include = false\n      //       }\n      //     }\n\n      //     if (include) {\n      //       addRow(row)\n      //     }\n      //   })\n\n      //   instance.setRowSelection(selectedRowIds)\n      // },\n      getPreSelectedRowModel: () => instance.getCoreRowModel(),\n      getSelectedRowModel: memo(\n        () => [instance.getState().rowSelection, instance.getCoreRowModel()],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      getFilteredSelectedRowModel: memo(\n        () => [\n          instance.getState().rowSelection,\n          instance.getFilteredRowModel(),\n        ],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'production' &&\n            'getFilteredSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      getGroupedSelectedRowModel: memo(\n        () => [instance.getState().rowSelection, instance.getGroupedRowModel()],\n        (rowSelection, rowModel) => {\n          if (!Object.keys(rowSelection).length) {\n            return {\n              rows: [],\n              flatRows: [],\n              rowsById: {},\n            }\n          }\n\n          return selectRowsFn(instance, rowModel)\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'production' &&\n            'getGroupedSelectedRowModel',\n          debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        }\n      ),\n\n      ///\n\n      // getGroupingRowCanSelect: rowId => {\n      //   const row = instance.getRow(rowId)\n\n      //   if (!row) {\n      //     throw new Error()\n      //   }\n\n      //   if (typeof instance.options.enableGroupingRowSelection === 'function') {\n      //     return instance.options.enableGroupingRowSelection(row)\n      //   }\n\n      //   return instance.options.enableGroupingRowSelection ?? false\n      // },\n\n      getIsAllRowsSelected: () => {\n        const preFilteredFlatRows = instance.getPreFilteredRowModel().flatRows\n        const { rowSelection } = instance.getState()\n\n        let isAllRowsSelected = Boolean(\n          preFilteredFlatRows.length && Object.keys(rowSelection).length\n        )\n\n        if (isAllRowsSelected) {\n          if (preFilteredFlatRows.some(row => !rowSelection[row.id])) {\n            isAllRowsSelected = false\n          }\n        }\n\n        return isAllRowsSelected\n      },\n\n      getIsAllPageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows\n        const { rowSelection } = instance.getState()\n\n        let isAllPageRowsSelected = !!paginationFlatRows.length\n\n        if (\n          isAllPageRowsSelected &&\n          paginationFlatRows.some(row => !rowSelection[row.id])\n        ) {\n          isAllPageRowsSelected = false\n        }\n\n        return isAllPageRowsSelected\n      },\n\n      getIsSomeRowsSelected: () => {\n        return (\n          !instance.getIsAllRowsSelected() &&\n          !!Object.keys(instance.getState().rowSelection ?? {}).length\n        )\n      },\n\n      getIsSomePageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows\n        return instance.getIsAllPageRowsSelected()\n          ? false\n          : !!paginationFlatRows?.length\n      },\n\n      getToggleAllRowsSelectedHandler: () => {\n        return (e: unknown) => {\n          instance.toggleAllRowsSelected(\n            ((e as MouseEvent).target as HTMLInputElement).checked\n          )\n        }\n      },\n\n      getToggleAllPageRowsSelectedHandler: () => {\n        return (e: unknown) => {\n          instance.toggleAllPageRowsSelected(\n            ((e as MouseEvent).target as HTMLInputElement).checked\n          )\n        }\n      },\n    }\n  },\n\n  createRow: <TGenerics extends TableGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): RowSelectionRow => {\n    return {\n      toggleSelected: value => {\n        const isSelected = row.getIsSelected()\n\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !isSelected\n\n          if (isSelected === value) {\n            return old\n          }\n\n          const selectedRowIds = { ...old }\n\n          mutateRowIsSelected(selectedRowIds, row.id, value, instance)\n\n          return selectedRowIds\n        })\n      },\n      getIsSelected: () => {\n        const { rowSelection } = instance.getState()\n        return isRowSelected(row, rowSelection, instance) === true\n      },\n\n      getIsSomeSelected: () => {\n        const { rowSelection } = instance.getState()\n        return isRowSelected(row, rowSelection, instance) === 'some'\n      },\n\n      getCanSelect: () => {\n        if (typeof instance.options.enableRowSelection === 'function') {\n          return instance.options.enableRowSelection(row)\n        }\n\n        return instance.options.enableRowSelection ?? true\n      },\n\n      getCanSelectSubRows: () => {\n        if (typeof instance.options.enableSubRowSelection === 'function') {\n          return instance.options.enableSubRowSelection(row)\n        }\n\n        return instance.options.enableSubRowSelection ?? true\n      },\n\n      getCanMultiSelect: () => {\n        if (typeof instance.options.enableMultiRowSelection === 'function') {\n          return instance.options.enableMultiRowSelection(row)\n        }\n\n        return instance.options.enableMultiRowSelection ?? true\n      },\n      getToggleSelectedHandler: () => {\n        const canSelect = row.getCanSelect()\n\n        return (e: unknown) => {\n          if (!canSelect) return\n          row.toggleSelected(\n            ((e as MouseEvent).target as HTMLInputElement)?.checked\n          )\n        }\n      },\n    }\n  },\n}\n\nconst mutateRowIsSelected = <TGenerics extends TableGenerics>(\n  selectedRowIds: Record<string, boolean>,\n  id: string,\n  value: boolean,\n  instance: TableInstance<TGenerics>\n) => {\n  const row = instance.getRow(id)\n\n  const isGrouped = row.getIsGrouped()\n\n  // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && instance.options.enableGroupingRowSelection)\n  // ) {\n  if (value) {\n    selectedRowIds[id] = true\n  } else {\n    delete selectedRowIds[id]\n  }\n  // }\n\n  if (row.subRows?.length && row.getCanSelectSubRows()) {\n    row.subRows.forEach(row =>\n      mutateRowIsSelected(selectedRowIds, row.id, value, instance)\n    )\n  }\n}\n\nexport function selectRowsFn<TGenerics extends TableGenerics>(\n  instance: TableInstance<TGenerics>,\n  rowModel: RowModel<TGenerics>\n): RowModel<TGenerics> {\n  const rowSelection = instance.getState().rowSelection\n\n  const newSelectedFlatRows: Row<TGenerics>[] = []\n  const newSelectedRowsById: Record<string, Row<TGenerics>> = {}\n\n  // Filters top level and nested rows\n  const recurseRows = (rows: Row<TGenerics>[], depth = 0): Row<TGenerics>[] => {\n    return rows\n      .map(row => {\n        const isSelected = isRowSelected(row, rowSelection, instance) === true\n\n        if (isSelected) {\n          newSelectedFlatRows.push(row)\n          newSelectedRowsById[row.id] = row\n        }\n\n        if (row.subRows?.length) {\n          row = {\n            ...row,\n            subRows: recurseRows(row.subRows, depth + 1),\n          }\n        }\n\n        if (isSelected) {\n          return row\n        }\n      })\n      .filter(Boolean) as Row<TGenerics>[]\n  }\n\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById,\n  }\n}\n\nexport function isRowSelected<TGenerics extends TableGenerics>(\n  row: Row<TGenerics>,\n  selection: Record<string, boolean>,\n  instance: TableInstance<TGenerics>\n): boolean | 'some' {\n  if (selection[row.id]) {\n    return true\n  }\n\n  if (row.subRows && row.subRows.length) {\n    let allChildrenSelected = true\n    let someSelected = false\n\n    row.subRows.forEach(subRow => {\n      // Bail out early if we know both of these\n      if (someSelected && !allChildrenSelected) {\n        return\n      }\n\n      if (isRowSelected(subRow, selection, instance)) {\n        someSelected = true\n      } else {\n        allChildrenSelected = false\n      }\n    })\n\n    return allChildrenSelected ? true : someSelected ? 'some' : false\n  }\n\n  return false\n}\n","import { TableGenerics, Row } from './types'\n\nexport const reSplitAlphaNumeric = /([0-9]+)/gm\n\nexport const sortingFns = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic,\n}\n\nexport type BuiltInSortingFn = keyof typeof sortingFns\n\nfunction alphanumeric<TGenerics extends TableGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareAlphanumeric(\n    toString(rowA.getValue(columnId)).toLowerCase(),\n    toString(rowB.getValue(columnId)).toLowerCase()\n  )\n}\n\nfunction alphanumericCaseSensitive<TGenerics extends TableGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareAlphanumeric(\n    toString(rowA.getValue(columnId)),\n    toString(rowB.getValue(columnId))\n  )\n}\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr: string, bStr: string) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean)\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean)\n\n  // While\n  while (a.length && b.length) {\n    const aa = a.shift()!\n    const bb = b.shift()!\n\n    const an = parseInt(aa, 10)\n    const bn = parseInt(bb, 10)\n\n    const combo = [an, bn].sort()\n\n    // Both are string\n    if (isNaN(combo[0]!)) {\n      if (aa > bb) {\n        return 1\n      }\n      if (bb > aa) {\n        return -1\n      }\n      continue\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1]!)) {\n      return isNaN(an) ? -1 : 1\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1\n    }\n    if (bn > an) {\n      return -1\n    }\n  }\n\n  return a.length - b.length\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nfunction text<TGenerics extends TableGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    toString(rowA.getValue(columnId)).toLowerCase(),\n    toString(rowB.getValue(columnId)).toLowerCase()\n  )\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nfunction textCaseSensitive<TGenerics extends TableGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    toString(rowA.getValue(columnId)),\n    toString(rowB.getValue(columnId))\n  )\n}\n\nfunction datetime<TGenerics extends TableGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(\n    (rowA.getValue(columnId) as Date).getTime(),\n    (rowB.getValue(columnId) as Date).getTime()\n  )\n}\n\nfunction basic<TGenerics extends TableGenerics>(\n  rowA: Row<TGenerics>,\n  rowB: Row<TGenerics>,\n  columnId: string\n) {\n  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId))\n}\n\n// Utils\n\nfunction compareBasic(a: any, b: any) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\nfunction toString(a: any) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return ''\n    }\n    return String(a)\n  }\n  if (typeof a === 'string') {\n    return a\n  }\n  return ''\n}\n","import { RowModel } from '..'\nimport {\n  BuiltInSortingFn,\n  reSplitAlphaNumeric,\n  sortingFns,\n} from '../sortingFns'\n\nimport {\n  Column,\n  OnChangeFn,\n  TableGenerics,\n  TableInstance,\n  Row,\n  Updater,\n  TableFeature,\n} from '../types'\n\nimport { isFunction, makeStateUpdater, Overwrite } from '../utils'\n\nexport type SortDirection = 'asc' | 'desc'\n\nexport type ColumnSort = {\n  id: string\n  desc: boolean\n}\n\nexport type SortingState = ColumnSort[]\n\nexport type SortingFn<TGenerics extends TableGenerics> = {\n  (rowA: Row<TGenerics>, rowB: Row<TGenerics>, columnId: string): number\n}\n\nexport type CustomSortingFns<TGenerics extends TableGenerics> = Record<\n  string,\n  SortingFn<TGenerics>\n>\n\nexport type SortingTableState = {\n  sorting: SortingState\n}\n\nexport type SortingFnOption<TGenerics extends TableGenerics> =\n  | 'auto'\n  | BuiltInSortingFn\n  | keyof TGenerics['SortingFns']\n  | SortingFn<TGenerics>\n\nexport type SortingColumnDef<TGenerics extends TableGenerics> = {\n  sortingFn?: SortingFnOption<Overwrite<TGenerics, { Value: any }>>\n  sortDescFirst?: boolean\n  enableSorting?: boolean\n  enableMultiSort?: boolean\n  invertSorting?: boolean\n  sortUndefined?: false | -1 | 1\n}\n\nexport type SortingColumn<TGenerics extends TableGenerics> = {\n  getAutoSortingFn: () => SortingFn<TGenerics>\n  getAutoSortDir: () => SortDirection\n  getSortingFn: () => SortingFn<TGenerics>\n  getCanSort: () => boolean\n  getCanMultiSort: () => boolean\n  getSortIndex: () => number\n  getIsSorted: () => false | SortDirection\n  clearSorting: () => void\n  toggleSorting: (desc?: boolean, isMulti?: boolean) => void\n  getToggleSortingHandler: () => undefined | ((event: unknown) => void)\n}\n\nexport type SortingOptions<TGenerics extends TableGenerics> = {\n  manualSorting?: boolean\n  sortingFns?: TGenerics['SortingFns']\n  onSortingChange?: OnChangeFn<SortingState>\n  enableSorting?: boolean\n  enableSortingRemoval?: boolean\n  enableMultiRemove?: boolean\n  enableMultiSort?: boolean\n  sortDescFirst?: boolean\n  getSortedRowModel?: (\n    instance: TableInstance<TGenerics>\n  ) => () => RowModel<TGenerics>\n  maxMultiSortColCount?: number\n  isMultiSortEvent?: (e: unknown) => boolean\n}\n\nexport type SortingInstance<TGenerics extends TableGenerics> = {\n  setSorting: (updater: Updater<SortingState>) => void\n  resetSorting: (defaultState?: boolean) => void\n  getPreSortedRowModel: () => RowModel<TGenerics>\n  getSortedRowModel: () => RowModel<TGenerics>\n  _getSortedRowModel?: () => RowModel<TGenerics>\n}\n\n//\n\nexport const Sorting: TableFeature = {\n  getInitialState: (state): SortingTableState => {\n    return {\n      sorting: [],\n      ...state,\n    }\n  },\n\n  getDefaultColumn: <\n    TGenerics extends TableGenerics\n  >(): SortingColumnDef<TGenerics> => {\n    return {\n      sortingFn: 'auto',\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): SortingOptions<TGenerics> => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', instance),\n      isMultiSortEvent: (e: unknown) => {\n        return (e as MouseEvent).shiftKey\n      },\n    }\n  },\n\n  createColumn: <TGenerics extends TableGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): SortingColumn<TGenerics> => {\n    return {\n      getAutoSortingFn: () => {\n        const firstRows = instance.getFilteredRowModel().flatRows.slice(10)\n\n        let isString = false\n\n        for (const row of firstRows) {\n          const value = row?.getValue(column.id)\n\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            return sortingFns.datetime\n          }\n\n          if (typeof value === 'string') {\n            isString = true\n\n            if (value.split(reSplitAlphaNumeric).length > 1) {\n              return sortingFns.alphanumeric\n            }\n          }\n        }\n\n        if (isString) {\n          return sortingFns.text\n        }\n\n        return sortingFns.basic\n      },\n      getAutoSortDir: () => {\n        const firstRow = instance.getFilteredRowModel().flatRows[0]\n\n        const value = firstRow?.getValue(column.id)\n\n        if (typeof value === 'string') {\n          return 'asc'\n        }\n\n        return 'desc'\n      },\n      getSortingFn: () => {\n        const userSortingFn = instance.options.sortingFns\n\n        if (!column) {\n          throw new Error()\n        }\n\n        return isFunction(column.sortingFn)\n          ? column.sortingFn\n          : column.sortingFn === 'auto'\n          ? column.getAutoSortingFn()\n          : (userSortingFn as Record<string, any>)?.[\n              column.sortingFn as string\n            ] ??\n            (sortingFns[\n              column.sortingFn as BuiltInSortingFn\n            ] as SortingFn<TGenerics>)\n      },\n      toggleSorting: (desc, multi) => {\n        // if (column.columns.length) {\n        //   column.columns.forEach((c, i) => {\n        //     if (c.id) {\n        //       instance.toggleColumnSorting(c.id, undefined, multi || !!i)\n        //     }\n        //   })\n        //   return\n        // }\n\n        instance.setSorting(old => {\n          // Find any existing sorting for this column\n          const existingSorting = old?.find(d => d.id === column.id)\n          const existingIndex = old?.findIndex(d => d.id === column.id)\n          const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n          let newSorting: SortingState = []\n\n          // What should we do with this sort action?\n          let sortAction\n\n          if (column.getCanMultiSort() && multi) {\n            if (existingSorting) {\n              sortAction = 'toggle'\n            } else {\n              sortAction = 'add'\n            }\n          } else {\n            // Normal mode\n            if (old?.length && existingIndex !== old.length - 1) {\n              sortAction = 'replace'\n            } else if (existingSorting) {\n              sortAction = 'toggle'\n            } else {\n              sortAction = 'replace'\n            }\n          }\n\n          const sortDescFirst =\n            column.sortDescFirst ??\n            instance.options.sortDescFirst ??\n            column.getAutoSortDir() === 'desc'\n\n          // Handle toggle states that will remove the sorting\n          if (\n            sortAction === 'toggle' && // Must be toggling\n            (instance.options.enableSortingRemoval ?? true) && // If enableSortRemove, enable in general\n            !hasDescDefined && // Must not be setting desc\n            (multi ? instance.options.enableMultiRemove ?? true : true) && // If multi, don't allow if enableMultiRemove\n            (existingSorting?.desc // Finally, detect if it should indeed be removed\n              ? !sortDescFirst\n              : sortDescFirst)\n          ) {\n            sortAction = 'remove'\n          }\n\n          if (sortAction === 'replace') {\n            newSorting = [\n              {\n                id: column.id,\n                desc: hasDescDefined ? desc! : !!sortDescFirst,\n              },\n            ]\n          } else if (sortAction === 'add' && old?.length) {\n            newSorting = [\n              ...old,\n              {\n                id: column.id,\n                desc: hasDescDefined ? desc! : !!sortDescFirst,\n              },\n            ]\n            // Take latest n columns\n            newSorting.splice(\n              0,\n              newSorting.length -\n                (instance.options.maxMultiSortColCount ??\n                  Number.MAX_SAFE_INTEGER)\n            )\n          } else if (sortAction === 'toggle' && old?.length) {\n            // This flips (or sets) the\n            newSorting = old.map(d => {\n              if (d.id === column.id) {\n                return {\n                  ...d,\n                  desc: hasDescDefined ? desc! : !existingSorting?.desc,\n                }\n              }\n              return d\n            })\n          } else if (sortAction === 'remove' && old?.length) {\n            newSorting = old.filter(d => d.id !== column.id)\n          }\n\n          return newSorting\n        })\n      },\n\n      getCanSort: () => {\n        return (\n          (column.enableSorting ?? true) &&\n          (instance.options.enableSorting ?? true) &&\n          !!column.accessorFn\n        )\n      },\n\n      getCanMultiSort: () => {\n        return (\n          column.enableMultiSort ??\n          instance.options.enableMultiSort ??\n          !!column.accessorFn\n        )\n      },\n\n      getIsSorted: () => {\n        const columnSort = instance\n          .getState()\n          .sorting?.find(d => d.id === column.id)\n\n        return !columnSort ? false : columnSort.desc ? 'desc' : 'asc'\n      },\n\n      getSortIndex: () =>\n        instance.getState().sorting?.findIndex(d => d.id === column.id) ?? -1,\n\n      clearSorting: () => {\n        //clear sorting for just 1 column\n        instance.setSorting(old =>\n          old?.length ? old.filter(d => d.id !== column.id) : []\n        )\n      },\n\n      getToggleSortingHandler: () => {\n        const canSort = column.getCanSort()\n\n        return (e: unknown) => {\n          if (!canSort) return\n          ;(e as any).persist?.()\n          column.toggleSorting?.(\n            undefined,\n            column.getCanMultiSort()\n              ? instance.options.isMultiSortEvent?.(e)\n              : false\n          )\n        }\n      },\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): SortingInstance<TGenerics> => {\n    let registered = false\n\n    return {\n      setSorting: updater => instance.options.onSortingChange?.(updater),\n      resetSorting: defaultState => {\n        instance.setSorting(\n          defaultState ? [] : instance.initialState?.sorting ?? []\n        )\n      },\n      getPreSortedRowModel: () => instance.getFilteredRowModel(),\n      getSortedRowModel: () => {\n        if (\n          !instance._getSortedRowModel &&\n          instance.options.getSortedRowModel\n        ) {\n          instance._getSortedRowModel =\n            instance.options.getSortedRowModel(instance)\n        }\n\n        if (instance.options.manualSorting || !instance._getSortedRowModel) {\n          return instance.getPreSortedRowModel()\n        }\n\n        return instance._getSortedRowModel()\n      },\n    }\n  },\n}\n","import {\n  Cell,\n  Column,\n  OnChangeFn,\n  TableGenerics,\n  TableInstance,\n  Updater,\n  Row,\n  TableFeature,\n} from '../types'\nimport { makeStateUpdater, memo } from '../utils'\n\nexport type VisibilityOptions = {\n  onColumnVisibilityChange?: OnChangeFn<VisibilityState>\n  enableHiding?: boolean\n}\n\nexport type VisibilityDefaultOptions = {\n  onColumnVisibilityChange: OnChangeFn<VisibilityState>\n}\n\nexport type VisibilityState = Record<string, boolean>\n\nexport type VisibilityTableState = {\n  columnVisibility: VisibilityState\n}\n\nexport type VisibilityInstance<TGenerics extends TableGenerics> = {\n  getVisibleFlatColumns: () => Column<TGenerics>[]\n  getVisibleLeafColumns: () => Column<TGenerics>[]\n  getLeftVisibleLeafColumns: () => Column<TGenerics>[]\n  getRightVisibleLeafColumns: () => Column<TGenerics>[]\n  getCenterVisibleLeafColumns: () => Column<TGenerics>[]\n  setColumnVisibility: (updater: Updater<VisibilityState>) => void\n  resetColumnVisibility: (defaultState?: boolean) => void\n  toggleAllColumnsVisible: (value?: boolean) => void\n  getIsAllColumnsVisible: () => boolean\n  getIsSomeColumnsVisible: () => boolean\n  getToggleAllColumnsVisibilityHandler: () =>\n    | undefined\n    | ((event: unknown) => void)\n}\n\nexport type VisibilityColumnDef = {\n  enableHiding?: boolean\n  defaultIsVisible?: boolean\n}\n\nexport type VisibilityRow<TGenerics extends TableGenerics> = {\n  _getAllVisibleCells: () => Cell<TGenerics>[]\n  getVisibleCells: () => Cell<TGenerics>[]\n}\n\nexport type VisibilityColumn = {\n  getCanHide: () => boolean\n  getIsVisible: () => boolean\n  toggleVisibility: (value?: boolean) => void\n  getToggleVisibilityHandler: () => (event: unknown) => void\n}\n\n//\n\nexport const Visibility: TableFeature = {\n  getInitialState: (state): VisibilityTableState => {\n    return {\n      columnVisibility: {},\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): VisibilityDefaultOptions => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', instance),\n    }\n  },\n\n  getDefaultColumn: () => {\n    return {\n      defaultIsVisible: true,\n    }\n  },\n\n  createColumn: <TGenerics extends TableGenerics>(\n    column: Column<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): VisibilityColumn => {\n    return {\n      toggleVisibility: value => {\n        if (column.getCanHide()) {\n          instance.setColumnVisibility(old => ({\n            ...old,\n            [column.id]: value ?? !column.getIsVisible(),\n          }))\n        }\n      },\n      getIsVisible: () => {\n        return instance.getState().columnVisibility?.[column.id] ?? true\n      },\n\n      getCanHide: () => {\n        return (\n          (column.enableHiding ?? true) &&\n          (instance.options.enableHiding ?? true)\n        )\n      },\n      getToggleVisibilityHandler: () => {\n        return (e: unknown) => {\n          column.toggleVisibility?.(\n            ((e as MouseEvent).target as HTMLInputElement).checked\n          )\n        }\n      },\n    }\n  },\n\n  createRow: <TGenerics extends TableGenerics>(\n    row: Row<TGenerics>,\n    instance: TableInstance<TGenerics>\n  ): VisibilityRow<TGenerics> => {\n    return {\n      _getAllVisibleCells: memo(\n        () => [\n          row\n            .getAllCells()\n            .filter(cell => cell.column.getIsVisible())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        _ => {\n          return row.getAllCells().filter(cell => cell.column.getIsVisible())\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'production' && 'row._getAllVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n      getVisibleCells: memo(\n        () => [\n          row.getLeftVisibleCells(),\n          row.getCenterVisibleCells(),\n          row.getRightVisibleCells(),\n        ],\n        (left, center, right) => [...left, ...center, ...right],\n        {\n          key: process.env.NODE_ENV === 'development' && 'row.getVisibleCells',\n          debug: () => instance.options.debugAll ?? instance.options.debugRows,\n        }\n      ),\n    }\n  },\n\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): VisibilityInstance<TGenerics> => {\n    const makeVisibleColumnsMethod = (\n      key: string,\n      getColumns: () => Column<TGenerics>[]\n    ): (() => Column<TGenerics>[]) => {\n      return memo(\n        () => [\n          getColumns(),\n          getColumns()\n            .filter(d => d.getIsVisible())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        columns => {\n          return columns.filter(d => d.getIsVisible?.())\n        },\n        {\n          key,\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugColumns,\n        }\n      )\n    }\n\n    return {\n      getVisibleFlatColumns: makeVisibleColumnsMethod(\n        'getVisibleFlatColumns',\n        () => instance.getAllFlatColumns()\n      ),\n      getVisibleLeafColumns: makeVisibleColumnsMethod(\n        'getVisibleLeafColumns',\n        () => instance.getAllLeafColumns()\n      ),\n      getLeftVisibleLeafColumns: makeVisibleColumnsMethod(\n        'getLeftVisibleLeafColumns',\n        () => instance.getLeftLeafColumns()\n      ),\n      getRightVisibleLeafColumns: makeVisibleColumnsMethod(\n        'getRightVisibleLeafColumns',\n        () => instance.getRightLeafColumns()\n      ),\n      getCenterVisibleLeafColumns: makeVisibleColumnsMethod(\n        'getCenterVisibleLeafColumns',\n        () => instance.getCenterLeafColumns()\n      ),\n\n      setColumnVisibility: updater =>\n        instance.options.onColumnVisibilityChange?.(updater),\n\n      resetColumnVisibility: defaultState => {\n        instance.setColumnVisibility(\n          defaultState ? {} : instance.initialState.columnVisibility ?? {}\n        )\n      },\n\n      toggleAllColumnsVisible: value => {\n        value = value ?? !instance.getIsAllColumnsVisible()\n\n        instance.setColumnVisibility(\n          instance.getAllLeafColumns().reduce(\n            (obj, column) => ({\n              ...obj,\n              [column.id]: !value ? !column.getCanHide?.() : value,\n            }),\n            {}\n          )\n        )\n      },\n\n      getIsAllColumnsVisible: () =>\n        !instance.getAllLeafColumns().some(column => !column.getIsVisible?.()),\n\n      getIsSomeColumnsVisible: () =>\n        instance.getAllLeafColumns().some(column => column.getIsVisible?.()),\n\n      getToggleAllColumnsVisibilityHandler: () => {\n        return (e: unknown) => {\n          instance.toggleAllColumnsVisible(\n            ((e as MouseEvent).target as HTMLInputElement)?.checked\n          )\n        }\n      },\n    }\n  },\n}\n","import {\n  Column,\n  CoreHeader,\n  Header,\n  HeaderGroup,\n  TableGenerics,\n  TableInstance,\n} from '../types'\nimport { memo } from '../utils'\n\nexport type HeadersInstance<TGenerics extends TableGenerics> = {\n  createHeader: (\n    column: Column<TGenerics>,\n    options: {\n      id?: string\n      isPlaceholder?: boolean\n      placeholderId?: string\n      index: number\n      depth: number\n    }\n  ) => Header<TGenerics>\n  getHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getLeftHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getCenterHeaderGroups: () => HeaderGroup<TGenerics>[]\n  getRightHeaderGroups: () => HeaderGroup<TGenerics>[]\n\n  getFooterGroups: () => HeaderGroup<TGenerics>[]\n  getLeftFooterGroups: () => HeaderGroup<TGenerics>[]\n  getCenterFooterGroups: () => HeaderGroup<TGenerics>[]\n  getRightFooterGroups: () => HeaderGroup<TGenerics>[]\n\n  getFlatHeaders: () => Header<TGenerics>[]\n  getLeftFlatHeaders: () => Header<TGenerics>[]\n  getCenterFlatHeaders: () => Header<TGenerics>[]\n  getRightFlatHeaders: () => Header<TGenerics>[]\n\n  getLeafHeaders: () => Header<TGenerics>[]\n  getLeftLeafHeaders: () => Header<TGenerics>[]\n  getCenterLeafHeaders: () => Header<TGenerics>[]\n  getRightLeafHeaders: () => Header<TGenerics>[]\n\n  getHeader: (id: string) => Header<TGenerics>\n}\n\n//\n\nexport const Headers = {\n  createInstance: <TGenerics extends TableGenerics>(\n    instance: TableInstance<TGenerics>\n  ): HeadersInstance<TGenerics> => {\n    return {\n      createHeader: (\n        column: Column<TGenerics>,\n        options: {\n          id?: string\n          isPlaceholder?: boolean\n          placeholderId?: string\n          index: number\n          depth: number\n        }\n      ) => {\n        const id = options.id ?? column.id\n\n        let header: CoreHeader<TGenerics> = {\n          id,\n          column,\n          index: options.index,\n          isPlaceholder: options.isPlaceholder,\n          placeholderId: options.placeholderId,\n          depth: options.depth,\n          subHeaders: [],\n          colSpan: 0,\n          rowSpan: 0,\n          headerGroup: null!,\n          getLeafHeaders: (): Header<TGenerics>[] => {\n            const leafHeaders: CoreHeader<TGenerics>[] = []\n\n            const recurseHeader = (h: CoreHeader<TGenerics>) => {\n              if (h.subHeaders && h.subHeaders.length) {\n                h.subHeaders.map(recurseHeader)\n              }\n              leafHeaders.push(h)\n            }\n\n            recurseHeader(header)\n\n            return leafHeaders as Header<TGenerics>[]\n          },\n          renderHeader: () =>\n            column.header\n              ? instance._render(column.header, {\n                  instance,\n                  header: header as Header<TGenerics>,\n                  column,\n                })\n              : null,\n          renderFooter: () =>\n            column.footer\n              ? instance._render(column.footer, {\n                  instance,\n                  header: header as Header<TGenerics>,\n                  column,\n                })\n              : null,\n        }\n\n        instance._features.forEach(feature => {\n          Object.assign(header, feature.createHeader?.(header, instance))\n        })\n\n        return header as Header<TGenerics>\n      },\n\n      // Header Groups\n\n      getHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, left, right) => {\n          const leftColumns =\n            left\n              ?.map(columnId => leafColumns.find(d => d.id === columnId)!)\n              .filter(Boolean) ?? []\n\n          const rightColumns =\n            right\n              ?.map(columnId => leafColumns.find(d => d.id === columnId)!)\n              .filter(Boolean) ?? []\n\n          const centerColumns = leafColumns.filter(\n            column => !left?.includes(column.id) && !right?.includes(column.id)\n          )\n\n          const headerGroups = buildHeaderGroups(\n            allColumns,\n            [...leftColumns, ...centerColumns, ...rightColumns],\n            instance\n          )\n\n          return headerGroups\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, left, right) => {\n          leafColumns = leafColumns.filter(\n            column => !left?.includes(column.id) && !right?.includes(column.id)\n          )\n          return buildHeaderGroups(allColumns, leafColumns, instance, 'center')\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'development' && 'getCenterHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.left,\n        ],\n        (allColumns, leafColumns, left) => {\n          const orderedLeafColumns =\n            left\n              ?.map(columnId => leafColumns.find(d => d.id === columnId)!)\n              .filter(Boolean) ?? []\n\n          return buildHeaderGroups(\n            allColumns,\n            orderedLeafColumns,\n            instance,\n            'left'\n          )\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getLeftHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightHeaderGroups: memo(\n        () => [\n          instance.getAllColumns(),\n          instance.getVisibleLeafColumns(),\n          instance.getState().columnPinning.right,\n        ],\n        (allColumns, leafColumns, right) => {\n          const orderedLeafColumns =\n            right\n              ?.map(columnId => leafColumns.find(d => d.id === columnId)!)\n              .filter(Boolean) ?? []\n\n          return buildHeaderGroups(\n            allColumns,\n            orderedLeafColumns,\n            instance,\n            'right'\n          )\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getRightHeaderGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Footer Groups\n\n      getFooterGroups: memo(\n        () => [instance.getHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftFooterGroups: memo(\n        () => [instance.getLeftHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getLeftFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterFooterGroups: memo(\n        () => [instance.getCenterHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key:\n            process.env.NODE_ENV === 'development' && 'getCenterFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightFooterGroups: memo(\n        () => [instance.getRightHeaderGroups()],\n        headerGroups => {\n          return [...headerGroups].reverse()\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getRightFooterGroups',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Flat Headers\n\n      getFlatHeaders: memo(\n        () => [instance.getHeaderGroups()],\n        headerGroups => {\n          return headerGroups\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftFlatHeaders: memo(\n        () => [instance.getLeftHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getLeftFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getCenterFlatHeaders: memo(\n        () => [instance.getCenterHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getCenterFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightFlatHeaders: memo(\n        () => [instance.getRightHeaderGroups()],\n        left => {\n          return left\n            .map(headerGroup => {\n              return headerGroup.headers\n            })\n            .flat()\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getRightFlatHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      // Leaf Headers\n\n      getCenterLeafHeaders: memo(\n        () => [instance.getCenterFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getCenterLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeftLeafHeaders: memo(\n        () => [instance.getLeftFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getLeftLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getRightLeafHeaders: memo(\n        () => [instance.getRightFlatHeaders()],\n        flatHeaders => {\n          return flatHeaders.filter(header => !header.subHeaders?.length)\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getRightLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getLeafHeaders: memo(\n        () => [\n          instance.getLeftHeaderGroups(),\n          instance.getCenterHeaderGroups(),\n          instance.getRightHeaderGroups(),\n        ],\n        (left, center, right) => {\n          return [\n            ...(left[0]?.headers ?? []),\n            ...(center[0]?.headers ?? []),\n            ...(right[0]?.headers ?? []),\n          ]\n            .map(header => {\n              return header.getLeafHeaders()\n            })\n            .flat()\n        },\n        {\n          key: process.env.NODE_ENV === 'development' && 'getLeafHeaders',\n          debug: () =>\n            instance.options.debugAll ?? instance.options.debugHeaders,\n        }\n      ),\n\n      getHeader: (id: string) => {\n        const header = [\n          ...instance.getFlatHeaders(),\n          ...instance.getCenterFlatHeaders(),\n          ...instance.getLeftFlatHeaders(),\n          ...instance.getRightFlatHeaders(),\n        ].find(d => d.id === id)\n\n        if (!header) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`Could not find header with id: ${id}`)\n          }\n          throw new Error()\n        }\n\n        return header\n      },\n    }\n  },\n}\n\nexport function buildHeaderGroups<TGenerics extends TableGenerics>(\n  allColumns: Column<TGenerics>[],\n  columnsToGroup: Column<TGenerics>[],\n  instance: TableInstance<TGenerics>,\n  headerFamily?: 'center' | 'left' | 'right'\n) {\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n\n  let maxDepth = 0\n\n  const findMaxDepth = (columns: Column<TGenerics>[], depth = 1) => {\n    maxDepth = Math.max(maxDepth, depth)\n\n    columns\n      .filter(column => column.getIsVisible())\n      .forEach(column => {\n        if (column.columns?.length) {\n          findMaxDepth(column.columns, depth + 1)\n        }\n      }, 0)\n  }\n\n  findMaxDepth(allColumns)\n\n  let headerGroups: HeaderGroup<TGenerics>[] = []\n\n  const createHeaderGroup = (\n    headersToGroup: Header<TGenerics>[],\n    depth: number\n  ) => {\n    // The header group we are creating\n    const headerGroup: HeaderGroup<TGenerics> = {\n      depth,\n      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),\n      headers: [],\n    }\n\n    // The parent columns we're going to scan next\n    const pendingParentHeaders: Header<TGenerics>[] = []\n\n    // Scan each column for parents\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n\n      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0]\n\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth\n\n      let column: Column<TGenerics>\n      let isPlaceholder = false\n\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column\n        isPlaceholder = true\n      }\n\n      if (latestPendingParentHeader?.column === column) {\n        // This column is repeated. Add it as a sub header to the next batch\n        latestPendingParentHeader.subHeaders.push(headerToGroup)\n      } else {\n        // This is a new header. Let's create it\n        const header = instance.createHeader(column, {\n          id: [headerFamily, depth, column.id, headerToGroup?.id]\n            .filter(Boolean)\n            .join('_'),\n          isPlaceholder,\n          placeholderId: isPlaceholder\n            ? `${pendingParentHeaders.filter(d => d.column === column).length}`\n            : undefined,\n          depth,\n          index: pendingParentHeaders.length,\n        })\n\n        // Add the headerToGroup as a subHeader of the new header\n        header.subHeaders.push(headerToGroup)\n        // Add the new header to the pendingParentHeaders to get grouped\n        // in the next batch\n        pendingParentHeaders.push(header)\n      }\n\n      headerGroup.headers.push(headerToGroup)\n      headerToGroup.headerGroup = headerGroup\n    })\n\n    headerGroups.push(headerGroup)\n\n    if (depth > 0) {\n      createHeaderGroup(pendingParentHeaders, depth - 1)\n    }\n  }\n\n  const bottomHeaders = columnsToGroup.map((column, index) =>\n    instance.createHeader(column, {\n      depth: maxDepth,\n      index,\n    })\n  )\n\n  createHeaderGroup(bottomHeaders, maxDepth - 1)\n\n  headerGroups.reverse()\n\n  // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = (headers: Header<TGenerics>[]) => {\n    const filteredHeaders = headers.filter(header =>\n      header.column.getIsVisible()\n    )\n\n    return filteredHeaders.map(header => {\n      let colSpan = 0\n      let rowSpan = 0\n      let childRowSpans = [0]\n\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = []\n\n        recurseHeadersForSpans(header.subHeaders).forEach(\n          ({ colSpan: childColSpan, rowSpan: childRowSpan }) => {\n            colSpan += childColSpan\n            childRowSpans.push(childRowSpan)\n          }\n        )\n      } else {\n        colSpan = 1\n      }\n\n      const minChildRowSpan = Math.min(...childRowSpans)\n      rowSpan = rowSpan + minChildRowSpan\n\n      header.colSpan = colSpan > 0 ? colSpan : undefined\n      header.rowSpan = rowSpan > 0 ? rowSpan : undefined\n\n      return { colSpan, rowSpan }\n    })\n  }\n\n  recurseHeadersForSpans(headerGroups[0]?.headers ?? [])\n\n  return headerGroups\n}\n","import { CustomFilterFns, FilterFn } from './features/Filters'\nimport { AggregationFn, CustomAggregationFns } from './features/Grouping'\nimport { CustomSortingFns, SortingFn } from './features/Sorting'\nimport {\n  ColumnDef,\n  AccessorFn,\n  AnyRender,\n  TableGenerics,\n  TableOptions,\n} from './types'\nimport { IfDefined, Overwrite } from './utils'\n\nexport type TableFactory<TGenerics extends TableGenerics> =\n  () => Table<TGenerics>\n\nexport type CreateTableOptions<\n  TRender extends AnyRender,\n  TFilterFns extends CustomFilterFns<any>,\n  TSortingFns extends CustomSortingFns<any>,\n  TAggregationFns extends CustomAggregationFns<any>,\n  TGenerics extends TableGenerics\n> = Partial<\n  {\n    render?: TRender\n    filterFns?: TFilterFns\n    sortingFns?: TSortingFns\n    aggregationFns?: TAggregationFns\n  } & Omit<\n    TableOptions<TGenerics>,\n    'filterFns' | 'sortingFns' | 'aggregationFns'\n  >\n>\n\nexport type Table<TGenerics extends TableGenerics> = {\n  generics: TGenerics\n  options: Partial<TableOptions<TGenerics>>\n  setGenerics: <T extends TableGenerics>() => Table<T>\n  setRowType: <TRow>() => Table<Overwrite<TGenerics, { Row: TRow }>>\n  setTableMetaType: <TTableMeta>() => Table<\n    Overwrite<TGenerics, { TableMeta: TTableMeta }>\n  >\n  setColumnMetaType: <TColumnMeta>() => Table<\n    Overwrite<TGenerics, { ColumnMeta: TColumnMeta }>\n  >\n  setFilterMetaType: <TFilterMeta>() => Table<\n    Overwrite<TGenerics, { FilterMeta: TFilterMeta }>\n  >\n  setOptions: <\n    TFilterFns extends Record<string, FilterFn<TGenerics>>,\n    TSortingFns extends Record<string, SortingFn<TGenerics>>,\n    TAggregationFns extends Record<string, AggregationFn<TGenerics>>\n  >(\n    options: CreateTableOptions<\n      any,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns,\n      TGenerics\n    >\n  ) => Table<\n    Overwrite<\n      TGenerics,\n      {\n        FilterFns: IfDefined<TFilterFns, TGenerics['FilterFns']>\n        SortingFns: IfDefined<TSortingFns, TGenerics['SortingFns']>\n        AggregationFns: IfDefined<TAggregationFns, TGenerics['AggregationFns']>\n      }\n    >\n  >\n  createGroup: (\n    column: Overwrite<\n      | Overwrite<\n          ColumnDef<any>,\n          {\n            header: string\n            id?: string\n          }\n        >\n      | Overwrite<\n          ColumnDef<any>,\n          {\n            id: string\n            header?: string | ((...any: any) => any)\n          }\n        >,\n      {\n        accessorFn?: never\n        accessorKey?: never\n        columns?: ColumnDef<any>[]\n      }\n    >\n  ) => ColumnDef<TGenerics>\n  createDisplayColumn: (\n    column: Omit<ColumnDef<TGenerics>, 'columns'>\n  ) => ColumnDef<TGenerics>\n  createDataColumn: <\n    TAccessor extends AccessorFn<TGenerics['Row']> | keyof TGenerics['Row']\n  >(\n    accessor: TAccessor,\n    column: Overwrite<\n      TAccessor extends (...args: any[]) => any\n        ? // Accessor Fn\n          ColumnDef<Overwrite<TGenerics, { Value: ReturnType<TAccessor> }>>\n        : TAccessor extends keyof TGenerics['Row']\n        ? // Accessor Key\n          Overwrite<\n            ColumnDef<\n              Overwrite<TGenerics, { Value: TGenerics['Row'][TAccessor] }>\n            >,\n            {\n              id?: string\n            }\n          >\n        : never,\n      {\n        accessorFn?: never\n        accessorKey?: never\n        columns?: ColumnDef<any>[]\n      }\n    >\n  ) => ColumnDef<TGenerics>\n}\n\n//\n\nexport function createTableFactory<TRenderer extends AnyRender>(opts: {\n  render: TRenderer\n}): () => Table<{ Renderer: TRenderer; Rendered: ReturnType<TRenderer> }> {\n  return () => createTable(undefined, undefined, opts)\n}\n\n// A lot of returns in here are `as any` for a reason. Unless you\n// can find a better way to do this, then don't worry about them\nfunction createTable<TGenerics extends TableGenerics>(\n  _?: undefined,\n  __?: undefined,\n  options?: CreateTableOptions<any, any, any, any, TGenerics>\n): Table<TGenerics> {\n  const table: Table<TGenerics> = {\n    generics: undefined!,\n    options: options ?? {\n      render: (() => {\n        throw new Error('')\n      })(),\n    },\n    setGenerics: () => table as any,\n    setRowType: () => table as any,\n    setTableMetaType: () => table as any,\n    setColumnMetaType: () => table as any,\n    setFilterMetaType: () => table as any,\n    setOptions: newOptions =>\n      createTable(_, __, {\n        ...options,\n        ...newOptions,\n      } as any),\n    createDisplayColumn: column => ({ ...column, columnDefType: 'display' }),\n    createGroup: column => ({ ...column, columnDefType: 'group' } as any),\n    createDataColumn: (accessor, column): any => {\n      column = {\n        ...column,\n        columnDefType: 'data',\n        id: column.id,\n      }\n\n      if (typeof accessor === 'string') {\n        return {\n          ...column,\n          id: column.id ?? accessor,\n          accessorKey: accessor,\n        }\n      }\n\n      if (typeof accessor === 'function') {\n        return {\n          ...column,\n          accessorFn: accessor,\n        }\n      }\n\n      throw new Error('Invalid accessor')\n    },\n  }\n\n  return table\n}\n","import { TableGenerics, Row, RowModel, TableInstance } from '../types'\n\nexport function filterRows<TGenerics extends TableGenerics>(\n  rows: Row<TGenerics>[],\n  filterRowImpl: (row: Row<TGenerics>) => any,\n  instance: TableInstance<TGenerics>\n) {\n  if (instance.options.filterFromLeafRows) {\n    return filterRowModelFromLeafs(rows, filterRowImpl, instance)\n  }\n\n  return filterRowModelFromRoot(rows, filterRowImpl, instance)\n}\n\nexport function filterRowModelFromLeafs<TGenerics extends TableGenerics>(\n  rowsToFilter: Row<TGenerics>[],\n  filterRow: (row: Row<TGenerics>) => Row<TGenerics>[],\n  instance: TableInstance<TGenerics>\n): RowModel<TGenerics> {\n  const newFilteredFlatRows: Row<TGenerics>[] = []\n  const newFilteredRowsById: Record<string, Row<TGenerics>> = {}\n\n  let row\n  let newRow\n\n  const recurseFilterRows = (rowsToFilter: Row<TGenerics>[], depth = 0) => {\n    const rows: Row<TGenerics>[] = []\n\n    // Filter from children up first\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      row = rowsToFilter[i]!\n\n      if (row.subRows?.length) {\n        newRow = instance.createRow(row.id, row.original, row.index, row.depth)\n        newRow.columnFilters = row.columnFilters\n        newRow.subRows = recurseFilterRows(row.subRows, depth + 1)\n        if (!newRow.subRows.length) {\n          continue\n        }\n        row = newRow\n      }\n\n      if (filterRow(row)) {\n        rows.push(row)\n        newFilteredRowsById[row.id] = row\n        newFilteredRowsById[i] = row\n      }\n    }\n\n    return rows\n  }\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n\nexport function filterRowModelFromRoot<TGenerics extends TableGenerics>(\n  rowsToFilter: Row<TGenerics>[],\n  filterRow: (row: Row<TGenerics>) => any,\n  instance: TableInstance<TGenerics>\n): RowModel<TGenerics> {\n  const newFilteredFlatRows: Row<TGenerics>[] = []\n  const newFilteredRowsById: Record<string, Row<TGenerics>> = {}\n\n  let rows\n  let row\n  let newRow\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (rowsToFilter: Row<TGenerics>[], depth = 0) => {\n    // Filter from parents downward first\n\n    rows = []\n\n    // Apply the filter to any subRows\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      row = rowsToFilter[i]!\n\n      const pass = filterRow(row)\n\n      if (pass) {\n        if (row.subRows?.length) {\n          newRow = instance.createRow(\n            row.id,\n            row.original,\n            row.index,\n            row.depth\n          )\n          newRow.subRows = recurseFilterRows(row.subRows, depth + 1)\n          row = newRow\n        }\n\n        rows.push(row)\n        newFilteredFlatRows.push(row)\n        newFilteredRowsById[row.id] = row\n      }\n    }\n\n    return rows\n  }\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n","import { TableInstance, Row, RowModel, TableGenerics } from '../types'\nimport { memo } from '../utils'\n\nexport function getExpandedRowModel<TGenerics extends TableGenerics>(): (\n  instance: TableInstance<TGenerics>\n) => () => RowModel<TGenerics> {\n  return instance =>\n    memo(\n      () => [\n        instance.getState().expanded,\n        instance.getPreExpandedRowModel(),\n        instance.options.paginateExpandedRows,\n      ],\n      (expanded, rowModel, paginateExpandedRows) => {\n        if (\n          !rowModel.rows.length ||\n          // Do not expand if rows are not included in pagination\n          !paginateExpandedRows ||\n          (expanded !== true && !Object.keys(expanded ?? {}).length)\n        ) {\n          return rowModel\n        }\n\n        return expandRows(rowModel, instance)\n      },\n      {\n        key: process.env.NODE_ENV === 'development' && 'getExpandedRowModel',\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n      }\n    )\n}\n\nexport function expandRows<TGenerics extends TableGenerics>(\n  rowModel: RowModel<TGenerics>,\n  instance: TableInstance<TGenerics>\n) {\n  const expandedRows: Row<TGenerics>[] = []\n\n  const handleRow = (row: Row<TGenerics>) => {\n    expandedRows.push(row)\n\n    if (\n      instance.options.expandSubRows &&\n      row.subRows?.length &&\n      row.getIsExpanded()\n    ) {\n      row.subRows.forEach(handleRow)\n    }\n  }\n\n  rowModel.rows.forEach(handleRow)\n\n  return {\n    rows: expandedRows,\n    flatRows: rowModel.flatRows,\n    rowsById: rowModel.rowsById,\n  }\n}\n","import { functionalUpdate, RequiredKeys } from './utils'\n\nimport {\n  Updater,\n  TableOptions,\n  TableState,\n  TableInstance,\n  Renderable,\n  TableFeature,\n  TableGenerics,\n  InitialTableState,\n} from './types'\n\nimport { Columns } from './features/Columns'\nimport { Rows } from './features/Rows'\nimport { Cells } from './features/Cells'\nimport { ColumnSizing } from './features/ColumnSizing'\nimport { Expanding } from './features/Expanding'\nimport { Filters } from './features/Filters'\nimport { Grouping } from './features/Grouping'\nimport { Ordering } from './features/Ordering'\nimport { Pagination } from './features/Pagination'\nimport { Pinning } from './features/Pinning'\nimport { RowSelection } from './features/RowSelection'\nimport { Sorting } from './features/Sorting'\nimport { Visibility } from './features/Visibility'\nimport { Headers } from './features/Headers'\n//\n\nexport type CoreTableState = {\n  // coreProgress: number\n}\n\nexport type CoreOptions<TGenerics extends TableGenerics> = {\n  data: TGenerics['Row'][]\n  state: Partial<TableState>\n  onStateChange: (updater: Updater<TableState>) => void\n  render: TGenerics['Renderer']\n  debugAll?: boolean\n  debugTable?: boolean\n  debugHeaders?: boolean\n  debugColumns?: boolean\n  debugRows?: boolean\n  initialState?: InitialTableState\n  autoResetAll?: boolean\n  mergeOptions?: <T>(defaultOptions: T, options: Partial<T>) => T\n  meta?: TGenerics['TableMeta']\n  // keepPreviousData?: boolean\n}\n\nexport type CoreInstance<TGenerics extends TableGenerics> = {\n  // generics: TGenerics\n  initialState: TableState\n  reset: () => void\n  options: RequiredKeys<TableOptions<TGenerics>, 'state'>\n  setOptions: (newOptions: Updater<TableOptions<TGenerics>>) => void\n  getState: () => TableState\n  setState: (updater: Updater<TableState>) => void\n  _queue: (cb: () => void) => void\n  _render: <TProps>(\n    template: Renderable<TGenerics, TProps>,\n    props: TProps\n  ) => string | null | TGenerics['Rendered']\n  _features: readonly TableFeature[]\n  // getOverallProgress: () => number\n  // getProgressStage: () =>\n  //   | undefined\n  //   | 'coreRowModel'\n  //   | 'filteredRowModel'\n  //   | 'facetedRowModel'\n  // createBatch: (priority: keyof CoreBatches) => Batch\n  // init: () => void\n  // willUpdate: () => void\n  // destroy: () => void\n  // batches: CoreBatches\n}\n\n// export type Batch = {\n//   id: number\n//   priority: keyof CoreBatches\n//   tasks: (() => void)[]\n//   schedule: (cb: () => void) => void\n//   cancel: () => void\n// }\n\n// type CoreBatches = {\n//   data: Batch[]\n//   facets: Batch[]\n// }\n\nexport function createTableInstance<TGenerics extends TableGenerics>(\n  options: TableOptions<TGenerics>\n): TableInstance<TGenerics> {\n  if (options.debugAll || options.debugTable) {\n    console.info('Creating Table Instance...')\n  }\n\n  let instance = {\n    _features: [\n      Columns,\n      Rows,\n      Cells,\n      Headers,\n      Visibility,\n      Ordering,\n      Pinning,\n      Filters,\n      Sorting,\n      Grouping,\n      Expanding,\n      Pagination,\n      RowSelection,\n      ColumnSizing,\n    ] as const,\n  } as unknown as CoreInstance<TGenerics>\n\n  const defaultOptions = instance._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.getDefaultOptions?.(instance))\n  }, {}) as TableOptions<TGenerics>\n\n  const mergeOptions = (options: TableOptions<TGenerics>) => {\n    if (instance.options.mergeOptions) {\n      return instance.options.mergeOptions(defaultOptions, options)\n    }\n\n    return {\n      ...defaultOptions,\n      ...options,\n    }\n  }\n\n  const coreInitialState: CoreTableState = {\n    // coreProgress: 1,\n  }\n\n  let initialState = {\n    ...coreInitialState,\n    ...(options.initialState ?? {}),\n  } as TableState\n\n  instance._features.forEach(feature => {\n    initialState = feature.getInitialState?.(initialState) ?? initialState\n  })\n\n  const queued: (() => void)[] = []\n  let queuedTimeout = false\n\n  const midInstance: CoreInstance<TGenerics> = {\n    ...instance,\n    // init: () => {\n    //   startWork()\n    // },\n    // willUpdate: () => {\n    //   startWork()\n    // },\n    // destroy: () => {\n    //   stopWork()\n    // },\n    options: {\n      ...defaultOptions,\n      ...options,\n    },\n    initialState,\n    _queue: cb => {\n      queued.push(cb)\n\n      if (!queuedTimeout) {\n        queuedTimeout = true\n\n        // Schedule a microtask to run the queued callbacks after\n        // the current call stack (render, etc) has finished.\n        Promise.resolve()\n          .then(() => {\n            while (queued.length) {\n              queued.shift()!()\n            }\n            queuedTimeout = false\n          })\n          .catch(error =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n      }\n    },\n    reset: () => {\n      instance.setState(instance.initialState)\n    },\n    setOptions: updater => {\n      const newOptions = functionalUpdate(updater, instance.options)\n      instance.options = mergeOptions(newOptions)\n    },\n    _render: (template, props) => {\n      if (typeof instance.options.render === 'function') {\n        return instance.options.render(template, props)\n      }\n\n      if (typeof template === 'function') {\n        return (template as Function)(props)\n      }\n\n      return template\n    },\n\n    getState: () => {\n      return instance.options.state as TableState\n    },\n\n    setState: (updater: Updater<TableState>) => {\n      instance.options.onStateChange?.(updater)\n    },\n\n    // getOverallProgress: () => {\n    //   const { coreProgress, filtersProgress, facetProgress } =\n    //     instance.getState()\n\n    //   return mean(() =>\n    //     [coreProgress, filtersProgress].filter(d => d < 1)\n    //   ) as number\n    // },\n    // getProgressStage: () => {\n    //   const { coreProgress, filtersProgress, facetProgress } =\n    //     instance.getState()\n\n    //   if (coreProgress < 1) {\n    //     return 'coreRowModel'\n    //   }\n\n    //   if (filtersProgress < 1) {\n    //     return 'filteredRowModel'\n    //   }\n\n    //   if (Object.values(facetProgress).some(d => d < 1)) {\n    //     return 'facetedRowModel'\n    //   }\n    // },\n  }\n\n  instance = Object.assign(instance, midInstance)\n\n  instance._features.forEach(feature => {\n    return Object.assign(instance, feature.createInstance?.(instance))\n  })\n\n  return instance as TableInstance<TGenerics>\n}\n","import { TableInstance, Row, RowModel, TableGenerics } from '../types'\nimport { memo } from '../utils'\n\nexport function getCoreRowModel<TGenerics extends TableGenerics>(): (\n  instance: TableInstance<TGenerics>\n) => () => RowModel<TGenerics> {\n  return instance =>\n    memo(\n      () => [instance.options.data],\n      (\n        data\n      ): {\n        rows: Row<TGenerics>[]\n        flatRows: Row<TGenerics>[]\n        rowsById: Record<string, Row<TGenerics>>\n      } => {\n        const rowModel: RowModel<TGenerics> = {\n          rows: [],\n          flatRows: [],\n          rowsById: {},\n        }\n\n        let rows\n        let row\n        let originalRow\n\n        const accessRows = (\n          originalRows: TGenerics['Row'][],\n          depth = 0,\n          parent?: Row<TGenerics>\n        ): Row<TGenerics>[] => {\n          rows = []\n\n          for (let i = 0; i < originalRows.length; i++) {\n            originalRow = originalRows[i]\n\n            // This could be an expensive check at scale, so we should move it somewhere else, but where?\n            // if (!id) {\n            //   if (process.env.NODE_ENV !== 'production') {\n            //     throw new Error(`getRowId expected an ID, but got ${id}`)\n            //   }\n            // }\n\n            // Make the row\n            row = instance.createRow(\n              instance.getRowId(originalRow, i, parent),\n              originalRow,\n              i,\n              depth\n            )\n\n            // Keep track of every row in a flat array\n            rowModel.flatRows.push(row)\n            // Also keep track of every row by its ID\n            rowModel.rowsById[row.id] = row\n            // Push instance row into parent\n            rows.push(row)\n\n            // Get the original subrows\n            if (instance.options.getSubRows) {\n              row.originalSubRows = instance.options.getSubRows(originalRow, i)\n\n              // Then recursively access them\n              if (row.originalSubRows?.length) {\n                row.subRows = accessRows(row.originalSubRows, depth + 1, row)\n              }\n            }\n          }\n\n          return rows\n        }\n\n        rowModel.rows = accessRows(data)\n\n        return rowModel\n      },\n      {\n        key: process.env.NODE_ENV === 'development' && 'getRowModel',\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {\n          instance._autoResetPageIndex()\n        },\n      }\n    )\n}\n","import { TableInstance, TableGenerics } from '../types'\nimport { memo } from '../utils'\n\nexport function getFacetedMinMaxValues<TGenerics extends TableGenerics>(): (\n  instance: TableInstance<TGenerics>,\n  columnId: string\n) => () => undefined | [number, number] {\n  return (instance, columnId) =>\n    memo(\n      () => [instance.getColumn(columnId).getFacetedRowModel()],\n      facetedRowModel => {\n        const firstValue = facetedRowModel.flatRows[0]?.getValue(columnId)\n\n        if (typeof firstValue === 'undefined') {\n          return undefined\n        }\n\n        let facetedMinMaxValues: [any, any] = [firstValue, firstValue]\n\n        for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n          const value = facetedRowModel.flatRows[i]?.getValue(columnId)\n\n          if (value < facetedMinMaxValues[0]) {\n            facetedMinMaxValues[0] = value\n          } else if (value > facetedMinMaxValues[1]) {\n            facetedMinMaxValues[1] = value\n          }\n        }\n\n        return facetedMinMaxValues\n      },\n      {\n        key:\n          process.env.NODE_ENV === 'development' &&\n          'getFacetedMinMaxValues_' + columnId,\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {},\n      }\n    )\n}\n","import { TableInstance, RowModel, TableGenerics, Row } from '../types'\nimport { memo } from '../utils'\nimport { filterRows } from './filterRowsUtils'\n\nexport function getFacetedRowModel<TGenerics extends TableGenerics>(): (\n  instance: TableInstance<TGenerics>,\n  columnId: string\n) => () => RowModel<TGenerics> {\n  return (instance, columnId) =>\n    memo(\n      () => [\n        instance.getPreFilteredRowModel(),\n        instance.getState().columnFilters,\n        instance.getState().globalFilter,\n        instance.getFilteredRowModel(),\n      ],\n      (preRowModel, columnFilters, globalFilter) => {\n        if (\n          !preRowModel.rows.length ||\n          (!columnFilters?.length && !globalFilter)\n        ) {\n          return preRowModel\n        }\n\n        const filterableIds = [\n          ...columnFilters.map(d => d.id).filter(d => d !== columnId),\n          globalFilter ? '__global__' : undefined,\n        ].filter(Boolean) as string[]\n\n        const filterRowsImpl = (row: Row<TGenerics>) => {\n          // Horizontally filter rows through each column\n          for (let i = 0; i < filterableIds.length; i++) {\n            if (row.columnFilters[filterableIds[i]!] === false) {\n              return false\n            }\n          }\n          return true\n        }\n\n        return filterRows(preRowModel.rows, filterRowsImpl, instance)\n      },\n      {\n        key:\n          process.env.NODE_ENV === 'development' &&\n          'getFacetedRowModel_' + columnId,\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {},\n      }\n    )\n}\n","import { TableInstance, TableGenerics } from '../types'\nimport { memo } from '../utils'\n\nexport function getFacetedUniqueValues<TGenerics extends TableGenerics>(): (\n  instance: TableInstance<TGenerics>,\n  columnId: string\n) => () => Map<any, number> {\n  return (instance, columnId) =>\n    memo(\n      () => [instance.getColumn(columnId).getFacetedRowModel()],\n      facetedRowModel => {\n        let facetedUniqueValues = new Map<any, number>()\n\n        for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n          const value = facetedRowModel.flatRows[i]?.getValue(columnId)\n\n          if (facetedUniqueValues.has(value)) {\n            facetedUniqueValues.set(\n              value,\n              (facetedUniqueValues.get(value) ?? 0) + 1\n            )\n          } else {\n            facetedUniqueValues.set(value, 1)\n          }\n        }\n\n        return facetedUniqueValues\n      },\n      {\n        key:\n          process.env.NODE_ENV === 'development' &&\n          'getFacetedUniqueValues_' + columnId,\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {},\n      }\n    )\n}\n","import { ResolvedColumnFilter } from '../features/Filters'\nimport { TableInstance, RowModel, TableGenerics, Row } from '../types'\nimport { memo } from '../utils'\nimport { filterRows } from './filterRowsUtils'\n\nexport function getFilteredRowModel<TGenerics extends TableGenerics>(): (\n  instance: TableInstance<TGenerics>\n) => () => RowModel<TGenerics> {\n  return instance =>\n    memo(\n      () => [\n        instance.getPreFilteredRowModel(),\n        instance.getState().columnFilters,\n        instance.getState().globalFilter,\n      ],\n      (rowModel, columnFilters, globalFilter) => {\n        if (\n          !rowModel.rows.length ||\n          (!columnFilters?.length && !globalFilter)\n        ) {\n          for (let i = 0; i < rowModel.flatRows.length; i++) {\n            rowModel.flatRows[i]!.columnFilters = {}\n            rowModel.flatRows[i]!.columnFiltersMeta = {}\n          }\n          return rowModel\n        }\n\n        const resolvedColumnFilters: ResolvedColumnFilter<TGenerics>[] = []\n        const resolvedGlobalFilters: ResolvedColumnFilter<TGenerics>[] = []\n\n        ;(columnFilters ?? []).forEach(d => {\n          const column = instance.getColumn(d.id)\n\n          if (!column) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn(\n                `Table: Could not find a column to filter with columnId: ${d.id}`\n              )\n            }\n          }\n\n          const filterFn = column.getFilterFn()\n\n          if (!filterFn) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn(\n                `Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`\n              )\n            }\n            return\n          }\n\n          resolvedColumnFilters.push({\n            id: d.id,\n            filterFn,\n            resolvedValue: filterFn.resolveFilterValue?.(d.value) ?? d.value,\n          })\n        })\n\n        const filterableIds = columnFilters.map(d => d.id)\n\n        const globalFilterFn = instance.getGlobalFilterFn()\n\n        const globallyFilterableColumns = instance\n          .getAllLeafColumns()\n          .filter(column => column.getCanGlobalFilter())\n\n        if (\n          globalFilter &&\n          globalFilterFn &&\n          globallyFilterableColumns.length\n        ) {\n          filterableIds.push('__global__')\n\n          globallyFilterableColumns.forEach(column => {\n            resolvedGlobalFilters.push({\n              id: column.id,\n              filterFn: globalFilterFn,\n              resolvedValue:\n                globalFilterFn.resolveFilterValue?.(globalFilter) ??\n                globalFilter,\n            })\n          })\n        }\n\n        let currentColumnFilter\n        let currentGlobalFilter\n\n        // Flag the prefiltered row model with each filter state\n        for (let j = 0; j < rowModel.flatRows.length; j++) {\n          const row = rowModel.flatRows[j]!\n\n          row.columnFilters = {}\n\n          if (resolvedColumnFilters.length) {\n            for (let i = 0; i < resolvedColumnFilters.length; i++) {\n              currentColumnFilter = resolvedColumnFilters[i]!\n              const id = currentColumnFilter.id\n\n              // Tag the row with the column filter state\n              row.columnFilters[id] = currentColumnFilter.filterFn(\n                row,\n                id,\n                currentColumnFilter.resolvedValue,\n                filterMeta => {\n                  row.columnFiltersMeta[id] = filterMeta\n                }\n              )\n            }\n          }\n\n          if (resolvedGlobalFilters.length) {\n            for (let i = 0; i < resolvedGlobalFilters.length; i++) {\n              currentGlobalFilter = resolvedGlobalFilters[i]!\n              const id = currentGlobalFilter.id\n              // Tag the row with the first truthy global filter state\n              if (\n                currentGlobalFilter.filterFn(\n                  row,\n                  id,\n                  currentGlobalFilter.resolvedValue,\n                  filterMeta => {\n                    row.columnFiltersMeta[id] = filterMeta\n                  }\n                )\n              ) {\n                row.columnFilters.__global__ = true\n                break\n              }\n            }\n\n            if (row.columnFilters.__global__ !== true) {\n              row.columnFilters.__global__ = false\n            }\n          }\n        }\n\n        const filterRowsImpl = (row: Row<TGenerics>) => {\n          // Horizontally filter rows through each column\n          for (let i = 0; i < filterableIds.length; i++) {\n            if (row.columnFilters[filterableIds[i]!] === false) {\n              return false\n            }\n          }\n          return true\n        }\n\n        // Filter final rows using all of the active filters\n        return filterRows(rowModel.rows, filterRowsImpl, instance)\n      },\n      {\n        key: process.env.NODE_ENV === 'development' && 'getFilteredRowModel',\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {\n          instance._autoResetPageIndex()\n        },\n      }\n    )\n}\n","import { CoreRow } from '../features/Rows'\nimport { TableInstance, Row, RowModel, TableGenerics } from '../types'\nimport { flattenBy, memo } from '../utils'\n\nexport function getGroupedRowModel<TGenerics extends TableGenerics>(): (\n  instance: TableInstance<TGenerics>\n) => () => RowModel<TGenerics> {\n  return instance =>\n    memo(\n      () => [instance.getState().grouping, instance.getPreGroupedRowModel()],\n      (grouping, rowModel) => {\n        if (!rowModel.rows.length || !grouping.length) {\n          return rowModel\n        }\n\n        // Filter the grouping list down to columns that exist\n        const existingGrouping = grouping.filter(columnId =>\n          instance.getColumn(columnId)\n        )\n\n        const groupedFlatRows: Row<TGenerics>[] = []\n        const groupedRowsById: Record<string, Row<TGenerics>> = {}\n        // const onlyGroupedFlatRows: Row[] = [];\n        // const onlyGroupedRowsById: Record<RowId, Row> = {};\n        // const nonGroupedFlatRows: Row[] = [];\n        // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n        // Recursively group the data\n        const groupUpRecursively = (\n          rows: Row<TGenerics>[],\n          depth = 0,\n          parentId: string\n        ) => {\n          // This is the last level, just return the rows\n          if (depth === existingGrouping.length) {\n            return rows\n          }\n\n          const columnId = existingGrouping[depth]!\n\n          // Group the rows together for this level\n          const rowGroupsMap = groupBy(rows, columnId)\n\n          // Peform aggregations for each group\n          const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map(\n            ([groupingValue, groupedRows], index) => {\n              let id = `${columnId}:${groupingValue}`\n              id = parentId ? `${parentId}>${id}` : id\n\n              // First, Recurse to group sub rows before aggregation\n              const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n              // Flatten the leaf rows of the rows in this group\n              const leafRows = depth\n                ? flattenBy(groupedRows, row => row.subRows)\n                : groupedRows\n\n              const row = instance.createRow(id, undefined, index, depth)\n\n              Object.assign(row, {\n                groupingColumnId: columnId,\n                groupingValue,\n                subRows,\n                leafRows,\n                getValue: (columnId: string) => {\n                  // Don't aggregate columns that are in the grouping\n                  if (existingGrouping.includes(columnId)) {\n                    if (row.valuesCache.hasOwnProperty(columnId)) {\n                      return row.valuesCache[columnId]\n                    }\n\n                    if (groupedRows[0]) {\n                      row.valuesCache[columnId] =\n                        groupedRows[0].getValue(columnId) ?? undefined\n                    }\n\n                    return row.valuesCache[columnId]\n                  }\n\n                  if (row.groupingValuesCache.hasOwnProperty(columnId)) {\n                    return row.groupingValuesCache[columnId]\n                  }\n\n                  // Aggregate the values\n                  const column = instance.getColumn(columnId)\n                  const aggregateFn = column.getColumnAggregationFn()\n\n                  if (aggregateFn) {\n                    row.groupingValuesCache[columnId] = aggregateFn(\n                      () =>\n                        leafRows.map(row => {\n                          let columnValue = row.getValue(columnId)\n\n                          if (!depth && column.aggregateValue) {\n                            columnValue = column.aggregateValue(columnValue)\n                          }\n\n                          return columnValue\n                        }),\n                      () => groupedRows.map(row => row.getValue(columnId))\n                    )\n\n                    return row.groupingValuesCache[columnId]\n                  } else if (column.aggregationFn) {\n                    console.info({ column })\n                    throw new Error(\n                      process.env.NODE_ENV !== 'production'\n                        ? `Table: Invalid column.aggregateType option for column listed above`\n                        : ''\n                    )\n                  }\n                },\n              })\n\n              subRows.forEach(subRow => {\n                groupedFlatRows.push(subRow)\n                groupedRowsById[subRow.id] = subRow\n                // if (subRow.getIsGrouped?.()) {\n                //   onlyGroupedFlatRows.push(subRow);\n                //   onlyGroupedRowsById[subRow.id] = subRow;\n                // } else {\n                //   nonGroupedFlatRows.push(subRow);\n                //   nonGroupedRowsById[subRow.id] = subRow;\n                // }\n              })\n\n              return row\n            }\n          )\n\n          return aggregatedGroupedRows\n        }\n\n        const groupedRows = groupUpRecursively(rowModel.rows, 0, '')\n\n        groupedRows.forEach(subRow => {\n          groupedFlatRows.push(subRow)\n          groupedRowsById[subRow.id] = subRow\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        })\n\n        return {\n          rows: groupedRows,\n          flatRows: groupedFlatRows,\n          rowsById: groupedRowsById,\n        }\n      },\n      {\n        key: process.env.NODE_ENV === 'development' && 'getGroupedRowModel',\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {\n          instance._queue(() => {\n            instance._autoResetExpanded()\n            instance._autoResetPageIndex()\n          })\n        },\n      }\n    )\n}\n\nfunction groupBy<TGenerics extends TableGenerics>(\n  rows: Row<TGenerics>[],\n  columnId: string\n) {\n  const groupMap = new Map<any, Row<TGenerics>[]>()\n\n  return rows.reduce((map, row) => {\n    const resKey = `${row.getValue(columnId)}`\n    const previous = map.get(resKey)\n    if (!previous) {\n      map.set(resKey, [row])\n    } else {\n      map.set(resKey, [...previous, row])\n    }\n    return map\n  }, groupMap)\n}\n","import { TableInstance, RowModel, TableGenerics } from '../types'\nimport { memo } from '../utils'\nimport { expandRows } from './getExpandedRowModel'\n\nexport function getPaginationRowModel<TGenerics extends TableGenerics>(opts?: {\n  initialSync: boolean\n}): (instance: TableInstance<TGenerics>) => () => RowModel<TGenerics> {\n  return instance =>\n    memo(\n      () => [\n        instance.getState().pagination,\n        instance.getPrePaginationRowModel(),\n      ],\n      (pagination, rowModel) => {\n        if (!rowModel.rows.length) {\n          return rowModel\n        }\n\n        const { pageSize, pageIndex } = pagination\n        let { rows, flatRows, rowsById } = rowModel\n        const pageStart = pageSize * pageIndex\n        const pageEnd = pageStart + pageSize\n\n        rows = rows.slice(pageStart, pageEnd)\n\n        if (!instance.options.paginateExpandedRows) {\n          return expandRows(\n            {\n              rows,\n              flatRows,\n              rowsById,\n            },\n            instance\n          )\n        }\n\n        return {\n          rows,\n          flatRows,\n          rowsById,\n        }\n      },\n      {\n        key: process.env.NODE_ENV === 'development' && 'getPaginationRowModel',\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n      }\n    )\n}\n","import { TableInstance, Row, RowModel, TableGenerics } from '../types'\nimport { SortingFn } from '../features/Sorting'\nimport { memo } from '../utils'\n\nexport function getSortedRowModel<TGenerics extends TableGenerics>(): (\n  instance: TableInstance<TGenerics>\n) => () => RowModel<TGenerics> {\n  return instance =>\n    memo(\n      () => [instance.getState().sorting, instance.getPreSortedRowModel()],\n      (sorting, rowModel) => {\n        if (!rowModel.rows.length || !sorting?.length) {\n          return rowModel\n        }\n\n        const sortingState = instance.getState().sorting\n\n        const sortedFlatRows: Row<TGenerics>[] = []\n\n        // Filter out sortings that correspond to non existing columns\n        const availableSorting = sortingState.filter(sort =>\n          instance.getColumn(sort.id).getCanSort()\n        )\n\n        const columnInfoById: Record<\n          string,\n          {\n            sortUndefined?: false | -1 | 1\n            invertSorting?: boolean\n            sortingFn: SortingFn<TGenerics>\n          }\n        > = {}\n\n        availableSorting.forEach(sortEntry => {\n          const column = instance.getColumn(sortEntry.id)\n\n          columnInfoById[sortEntry.id] = {\n            sortUndefined: column.sortUndefined,\n            invertSorting: column.invertSorting,\n            sortingFn: column.getSortingFn(),\n          }\n        })\n\n        const sortData = (rows: Row<TGenerics>[]) => {\n          // This will also perform a stable sorting using the row index\n          // if needed.\n          const sortedData = rows.slice()\n\n          sortedData.sort((rowA, rowB) => {\n            for (let i = 0; i < availableSorting.length; i += 1) {\n              const sortEntry = availableSorting[i]!\n              const columnInfo = columnInfoById[sortEntry.id]!\n              const isDesc = sortEntry?.desc ?? false\n\n              if (columnInfo.sortUndefined) {\n                const aValue = rowA.getValue(sortEntry.id)\n                const bValue = rowB.getValue(sortEntry.id)\n\n                const aUndefined = typeof aValue === 'undefined'\n                const bUndefined = typeof bValue === 'undefined'\n\n                if (aUndefined || bUndefined) {\n                  return aUndefined && bUndefined\n                    ? 0\n                    : aUndefined\n                    ? columnInfo.sortUndefined\n                    : -columnInfo.sortUndefined\n                }\n              }\n\n              // This function should always return in ascending order\n              let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id)\n\n              if (sortInt !== 0) {\n                if (isDesc) {\n                  sortInt *= -1\n                }\n\n                if (columnInfo.invertSorting) {\n                  sortInt *= -1\n                }\n\n                return sortInt\n              }\n            }\n\n            return rowA.index - rowB.index\n          })\n\n          // If there are sub-rows, sort them\n          sortedData.forEach(row => {\n            sortedFlatRows.push(row)\n            if (!row.subRows || row.subRows.length <= 1) {\n              return\n            }\n            row.subRows = sortData(row.subRows)\n          })\n\n          return sortedData\n        }\n\n        return {\n          rows: sortData(rowModel.rows),\n          flatRows: sortedFlatRows,\n          rowsById: rowModel.rowsById,\n        }\n      },\n      {\n        key: process.env.NODE_ENV === 'development' && 'getSortedRowModel',\n        debug: () => instance.options.debugAll ?? instance.options.debugTable,\n        onChange: () => {\n          instance._autoResetPageIndex()\n        },\n      }\n    )\n}\n"],"names":["functionalUpdate","updater","input","makeStateUpdater","key","instance","setState","old","isFunction","d","Function","flattenBy","arr","getChildren","flat","recurse","subArr","forEach","item","push","children","length","memo","getDeps","fn","opts","deps","result","depTime","debug","Date","now","newDeps","some","dep","index","resultTime","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","Columns","createInstance","getDefaultColumn","options","defaultColumn","_defaultColumn","header","props","column","id","footer","cell","_props$getValue$toStr","_props$getValue$toStr2","_props$getValue","getValue","toString","call","_features","reduce","obj","feature","Object","assign","_instance$options$deb","debugAll","debugColumns","process","getColumnDefs","columns","createColumn","columnDef","depth","parent","_ref","_columnDef$id","accessorFn","accessorKey","undefined","originalRow","Error","columnDefType","getFlatColumns","_column$columns","flatMap","_instance$options$deb2","getLeafColumns","_getOrderColumnsFn","orderColumns","_column$columns2","leafColumns","_instance$options$deb3","getAllColumns","columnDefs","recurseColumns","map","_instance$options$deb4","getAllFlatColumns","allColumns","_instance$options$deb5","getAllFlatColumnsById","flatColumns","acc","_instance$options$deb6","getAllLeafColumns","_instance$options$deb7","getColumn","columnId","Rows","getRowId","row","_instance$options$get","join","createRow","original","rowIndex","subRows","valuesCache","hasOwnProperty","getLeafRows","i","getCoreRowModel","_getCoreRowModel","getRowModel","getPaginationRowModel","getRow","rowsById","Cells","getAllCells","createCell","debugRows","getAllCellsByColumnId","allCells","rowId","renderCell","_render","getCell","defaultColumnSizing","size","minSize","maxSize","Number","MAX_SAFE_INTEGER","ColumnSizing","getInitialState","state","columnSizing","columnSizingInfo","startOffset","startSize","deltaOffset","deltaPercentage","isResizingColumn","columnSizingStart","getDefaultOptions","columnResizeMode","onColumnSizingChange","onColumnSizingInfoChange","getSize","_column$minSize","_column$maxSize","columnSize","getState","getStart","position","getLeftVisibleLeafColumns","getRightVisibleLeafColumns","getVisibleLeafColumns","findIndex","prevSiblingColumn","resetSize","setColumnSizing","_ref2","_","rest","getCanResize","_column$enableResizin","_instance$options$ena","enableResizing","enableColumnResizing","getIsResizing","createHeader","sum","_header$column$getSiz","subHeaders","prevSiblingHeader","headerGroup","headers","getResizeHandler","canResize","e","persist","isTouchStartEvent","touches","getLeafHeaders","clientX","updateOffset","eventType","clientXPos","newColumnSizing","setColumnSizingInfo","_old$startOffset","_old$startSize","_ref3","headerSize","mouseEvents","moveHandler","onMove","upHandler","document","removeEventListener","passiveIfSupported","passiveEventSupported","passive","addEventListener","resetColumnSizing","defaultState","_instance$initialStat","initialState","resetHeaderSizeInfo","_instance$initialStat2","getTotalSize","_instance$getHeaderGr","_instance$getHeaderGr2","getHeaderGroups","getLeftTotalSize","_instance$getLeftHead","_instance$getLeftHead2","getLeftHeaderGroups","getCenterTotalSize","_instance$getCenterHe","_instance$getCenterHe2","getCenterHeaderGroups","getRightTotalSize","_instance$getRightHea","_instance$getRightHea2","getRightHeaderGroups","passiveSupported","supported","noop","window","err","type","Expanding","expanded","onExpandedChange","autoResetExpanded","expandSubRows","paginateExpandedRows","registered","queued","_autoResetExpanded","autoResetAll","_queue","resetExpanded","setExpanded","toggleAllRowsExpanded","getIsAllRowsExpanded","getCanSomeRowsExpand","flatRows","getCanExpand","getToggleAllRowsExpandedHandler","getIsSomeRowsExpanded","values","Boolean","getIsExpanded","getExpandedDepth","maxDepth","keys","splitId","split","getPreExpandedRowModel","getGroupedRowModel","getExpandedRowModel","_getExpandedRowModel","manualExpanding","toggleExpanded","_expanded","exists","oldExpanded","getIsRowExpanded","_instance$options$get2","_row$subRows","getRowCanExpand","enableExpanding","getToggleExpandedHandler","canExpand","includesString","filterValue","search","toLowerCase","includes","autoRemove","val","testFalsey","includesStringSensitive","equalsString","arrIncludes","arrIncludesAll","arrIncludesSome","equals","weakEquals","inNumberRange","rowValue","resolveFilterValue","unsafeMin","unsafeMax","parsedMin","parseFloat","parsedMax","isNaN","Infinity","temp","filterFns","Filters","filterFn","columnFilters","globalFilter","onColumnFiltersChange","onGlobalFilterChange","filterFromLeafRows","globalFilterFn","getColumnCanGlobalFilter","_instance$getCoreRowM","_instance$getCoreRowM2","getAutoFilterFn","firstRow","value","Array","isArray","getFilterFn","userFilterFns","getCanFilter","_column$enableColumnF","_instance$options$ena2","enableColumnFilter","enableColumnFilters","enableFilters","getCanGlobalFilter","_column$enableGlobalF","_instance$options$ena3","_instance$options$ena4","enableGlobalFilter","getIsFiltered","getFilterIndex","getFilterValue","_instance$getState$co","_instance$getState$co2","find","_instance$getState$co3","_instance$getState$co4","setFilterValue","setColumnFilters","previousfilter","newFilter","_old$filter","shouldAutoRemoveFilter","filter","newFilterObj","_old$map","_getFacetedRowModel","getFacetedRowModel","getPreFilteredRowModel","_getFacetedUniqueValues","getFacetedUniqueValues","Map","_getFacetedMinMaxValues","getFacetedMinMaxValues","columnFiltersMeta","subRowsByFacetId","getGlobalAutoFilterFn","getGlobalFilterFn","_functionalUpdate","setGlobalFilter","resetGlobalFilter","resetColumnFilters","_getFilteredRowModel","getFilteredRowModel","manualFiltering","_getGlobalFacetedRowModel","getGlobalFacetedRowModel","_getGlobalFacetedUniqueValues","getGlobalFacetedUniqueValues","_getGlobalFacetedMinMaxValues","getGlobalFacetedMinMaxValues","aggregationFns","_getLeafValues","getChildValues","next","extent","mean","median","getLeafValues","leafValues","unique","from","Set","uniqueCount","count","Grouping","aggregationFn","grouping","onGroupingChange","groupedColumnMode","toggleGrouping","setGrouping","getCanGroup","_column$enableGroupin","enableGrouping","getIsGrouped","_instance$getState$gr","getGroupedIndex","_instance$getState$gr2","indexOf","getToggleGroupingHandler","canGroup","getColumnAutoAggregationFn","prototype","getColumnAggregationFn","_ref4","userAggregationFns","resetGrouping","getPreGroupedRowModel","getSortedRowModel","_getGroupedRowModel","manualGrouping","groupingColumnId","groupingValuesCache","getIsPlaceholder","getIsAggregated","renderAggregatedCell","_column$aggregatedCel","template","aggregatedCell","nonGroupingColumns","col","g","Ordering","columnOrder","onColumnOrderChange","setColumnOrder","resetColumnOrder","orderedColumns","columnOrderCopy","columnsCopy","targetColumnId","shift","foundIndex","splice","Pagination","pagination","pageIndex","pageSize","onPaginationChange","_autoResetPageIndex","_instance$options$aut","autoResetPageIndex","manualPagination","resetPageIndex","setPagination","resetPagination","setPageIndex","maxPageIndex","pageCount","_instance$initialStat3","_instance$initialStat4","resetPageSize","_instance$initialStat5","_instance$initialStat6","_instance$initialStat7","setPageSize","topRowIndex","floor","setPageCount","_old$pageCount","newPageCount","getPageOptions","pageOptions","fill","debugTable","getCanPreviousPage","getCanNextPage","getPageCount","previousPage","nextPage","getPrePaginationRowModel","_getPaginationRowModel","ceil","rows","Pinning","columnPinning","left","right","onColumnPinningChange","pin","columnIds","setColumnPinning","_old$left3","_old$right3","_old$left","_old$right","_old$left2","_old$right2","getCanPin","_d$enablePinning","enablePinning","getIsPinned","leafColumnIds","isLeft","isRight","getPinnedIndex","getCenterVisibleCells","_getAllVisibleCells","leftAndRight","getLeftVisibleCells","getRightVisibleCells","resetColumnPinning","getDefaultPinningState","getIsSomeColumnsPinned","getLeftLeafColumns","getRightLeafColumns","getCenterLeafColumns","RowSelection","rowSelection","onRowSelectionChange","enableRowSelection","enableMultiRowSelection","enableSubRowSelection","setRowSelection","resetRowSelection","toggleAllRowsSelected","getIsAllRowsSelected","preGroupedFlatRows","toggleAllPageRowsSelected","getIsAllPageRowsSelected","mutateRowIsSelected","getPreSelectedRowModel","getSelectedRowModel","rowModel","selectRowsFn","getFilteredSelectedRowModel","getGroupedSelectedRowModel","preFilteredFlatRows","isAllRowsSelected","paginationFlatRows","isAllPageRowsSelected","getIsSomeRowsSelected","_instance$getState$ro","getIsSomePageRowsSelected","getToggleAllRowsSelectedHandler","target","checked","getToggleAllPageRowsSelectedHandler","toggleSelected","isSelected","getIsSelected","selectedRowIds","isRowSelected","getIsSomeSelected","getCanSelect","getCanSelectSubRows","getCanMultiSelect","getToggleSelectedHandler","canSelect","_target","newSelectedFlatRows","newSelectedRowsById","recurseRows","_row$subRows2","selection","allChildrenSelected","someSelected","subRow","reSplitAlphaNumeric","sortingFns","alphanumeric","rowA","rowB","compareAlphanumeric","alphanumericCaseSensitive","text","compareBasic","textCaseSensitive","datetime","getTime","basic","aStr","bStr","a","b","aa","bb","an","parseInt","bn","combo","sort","Sorting","sorting","sortingFn","onSortingChange","isMultiSortEvent","shiftKey","getAutoSortingFn","firstRows","slice","isString","getAutoSortDir","getSortingFn","userSortingFn","toggleSorting","desc","multi","setSorting","_column$sortDescFirst","existingSorting","existingIndex","hasDescDefined","sortAction","newSorting","getCanMultiSort","sortDescFirst","enableSortingRemoval","enableMultiRemove","_instance$options$max","maxMultiSortColCount","getCanSort","_column$enableSorting","enableSorting","_column$enableMultiSo","enableMultiSort","getIsSorted","_instance$getState$so","columnSort","getSortIndex","_instance$getState$so2","_instance$getState$so3","clearSorting","getToggleSortingHandler","canSort","resetSorting","getPreSortedRowModel","_getSortedRowModel","manualSorting","Visibility","columnVisibility","onColumnVisibilityChange","defaultIsVisible","toggleVisibility","getCanHide","setColumnVisibility","getIsVisible","_column$enableHiding","enableHiding","getToggleVisibilityHandler","getVisibleCells","center","makeVisibleColumnsMethod","getColumns","getVisibleFlatColumns","getCenterVisibleLeafColumns","resetColumnVisibility","toggleAllColumnsVisible","_value","getIsAllColumnsVisible","getIsSomeColumnsVisible","getToggleAllColumnsVisibilityHandler","Headers","_options$id","isPlaceholder","placeholderId","colSpan","rowSpan","leafHeaders","recurseHeader","h","renderHeader","renderFooter","_left$map$filter","_right$map$filter","leftColumns","rightColumns","buildHeaderGroups","debugHeaders","_left$map$filter2","_right$map$filter2","getFooterGroups","headerGroups","reverse","getLeftFooterGroups","getCenterFooterGroups","getRightFooterGroups","_instance$options$deb8","getFlatHeaders","_instance$options$deb9","getLeftFlatHeaders","_instance$options$deb10","getCenterFlatHeaders","_instance$options$deb11","getRightFlatHeaders","_instance$options$deb12","getCenterLeafHeaders","flatHeaders","_header$subHeaders","_instance$options$deb13","getLeftLeafHeaders","_header$subHeaders2","_instance$options$deb14","getRightLeafHeaders","_header$subHeaders3","_instance$options$deb15","_left$0$headers","_left$","_center$0$headers","_center$","_right$0$headers","_right$","_instance$options$deb16","getHeader","columnsToGroup","headerFamily","_headerGroups$0$heade","_headerGroups$","findMaxDepth","createHeaderGroup","headersToGroup","pendingParentHeaders","headerToGroup","latestPendingParentHeader","bottomHeaders","recurseHeadersForSpans","childRowSpans","childColSpan","childRowSpan","createTable","__","table","generics","render","setGenerics","setRowType","setTableMetaType","setColumnMetaType","setFilterMetaType","setOptions","newOptions","createDisplayColumn","createGroup","createDataColumn","accessor","_column$id","filterRows","filterRowImpl","rowsToFilter","filterRow","newFilteredFlatRows","newFilteredRowsById","newRow","recurseFilterRows","filterRowModelFromLeafs","filterRowModelFromRoot","expandRows","expandedRows","handleRow","_options$initialState","defaultOptions","_feature$getInitialSt","queuedTimeout","midInstance","cb","Promise","resolve","then","catch","error","setTimeout","reset","mergeOptions","onStateChange","data","accessRows","originalRows","_row$originalSubRows","getSubRows","originalSubRows","facetedRowModel","_facetedRowModel$flat","firstValue","facetedMinMaxValues","_facetedRowModel$flat2","preRowModel","filterableIds","facetedUniqueValues","_facetedUniqueValues$","has","set","get","resolvedColumnFilters","resolvedGlobalFilters","_filterFn$resolveFilt","resolvedValue","globallyFilterableColumns","currentColumnFilter","currentGlobalFilter","_globalFilterFn$resol","j","filterMeta","__global__","existingGrouping","groupedFlatRows","groupedRowsById","groupUpRecursively","parentId","rowGroupsMap","groupMap","resKey","previous","groupBy","aggregatedGroupedRows","entries","groupingValue","groupedRows","leafRows","_groupedRows$0$getVal","aggregateFn","columnValue","aggregateValue","pageStart","pageEnd","sortingState","sortedFlatRows","availableSorting","columnInfoById","sortEntry","sortUndefined","invertSorting","sortData","sortedData","_sortEntry$desc","columnInfo","isDesc","aValue","aUndefined","bUndefined","sortInt"],"mappings":"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"}