/**
 * table-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('./utils.js');
var Columns = require('./features/Columns.js');
var Rows = require('./features/Rows.js');
var Cells = require('./features/Cells.js');
var ColumnSizing = require('./features/ColumnSizing.js');
var Expanding = require('./features/Expanding.js');
var Filters = require('./features/Filters.js');
var Grouping = require('./features/Grouping.js');
var Ordering = require('./features/Ordering.js');
var Pagination = require('./features/Pagination.js');
var Pinning = require('./features/Pinning.js');
var RowSelection = require('./features/RowSelection.js');
var Sorting = require('./features/Sorting.js');
var Visibility = require('./features/Visibility.js');
var Headers = require('./features/Headers.js');

// export type Batch = {
//   id: number
//   priority: keyof CoreBatches
//   tasks: (() => void)[]
//   schedule: (cb: () => void) => void
//   cancel: () => void
// }
// type CoreBatches = {
//   data: Batch[]
//   facets: Batch[]
// }
function createTableInstance(options) {
  var _options$initialState;

  if (options.debugAll || options.debugTable) {
    console.info('Creating Table Instance...');
  }

  let instance = {
    _features: [Columns.Columns, Rows.Rows, Cells.Cells, Headers.Headers, Visibility.Visibility, Ordering.Ordering, Pinning.Pinning, Filters.Filters, Sorting.Sorting, Grouping.Grouping, Expanding.Expanding, Pagination.Pagination, RowSelection.RowSelection, ColumnSizing.ColumnSizing]
  };

  const defaultOptions = instance._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(instance));
  }, {});

  const mergeOptions = options => {
    if (instance.options.mergeOptions) {
      return instance.options.mergeOptions(defaultOptions, options);
    }

    return { ...defaultOptions,
      ...options
    };
  };

  const coreInitialState = {// coreProgress: 1,
  };
  let initialState = { ...coreInitialState,
    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})
  };

  instance._features.forEach(feature => {
    var _feature$getInitialSt;

    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });

  const queued = [];
  let queuedTimeout = false;
  const midInstance = { ...instance,
    // init: () => {
    //   startWork()
    // },
    // willUpdate: () => {
    //   startWork()
    // },
    // destroy: () => {
    //   stopWork()
    // },
    options: { ...defaultOptions,
      ...options
    },
    initialState,
    _queue: cb => {
      queued.push(cb);

      if (!queuedTimeout) {
        queuedTimeout = true; // Schedule a microtask to run the queued callbacks after
        // the current call stack (render, etc) has finished.

        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }

          queuedTimeout = false;
        }).catch(error => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      instance.setState(instance.initialState);
    },
    setOptions: updater => {
      const newOptions = utils.functionalUpdate(updater, instance.options);
      instance.options = mergeOptions(newOptions);
    },
    _render: (template, props) => {
      if (typeof instance.options.render === 'function') {
        return instance.options.render(template, props);
      }

      if (typeof template === 'function') {
        return template(props);
      }

      return template;
    },
    getState: () => {
      return instance.options.state;
    },
    setState: updater => {
      instance.options.onStateChange == null ? void 0 : instance.options.onStateChange(updater);
    } // getOverallProgress: () => {
    //   const { coreProgress, filtersProgress, facetProgress } =
    //     instance.getState()
    //   return mean(() =>
    //     [coreProgress, filtersProgress].filter(d => d < 1)
    //   ) as number
    // },
    // getProgressStage: () => {
    //   const { coreProgress, filtersProgress, facetProgress } =
    //     instance.getState()
    //   if (coreProgress < 1) {
    //     return 'coreRowModel'
    //   }
    //   if (filtersProgress < 1) {
    //     return 'filteredRowModel'
    //   }
    //   if (Object.values(facetProgress).some(d => d < 1)) {
    //     return 'facetedRowModel'
    //   }
    // },

  };
  instance = Object.assign(instance, midInstance);

  instance._features.forEach(feature => {
    return Object.assign(instance, feature.createInstance == null ? void 0 : feature.createInstance(instance));
  });

  return instance;
}

exports.createTableInstance = createTableInstance;
//# sourceMappingURL=core.js.map
