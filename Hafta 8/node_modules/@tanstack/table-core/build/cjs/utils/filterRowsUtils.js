/**
 * table-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function filterRows(rows, filterRowImpl, instance) {
  if (instance.options.filterFromLeafRows) {
    return filterRowModelFromLeafs(rows, filterRowImpl, instance);
  }

  return filterRowModelFromRoot(rows, filterRowImpl, instance);
}
function filterRowModelFromLeafs(rowsToFilter, filterRow, instance) {
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  let row;
  let newRow;

  const recurseFilterRows = function (rowsToFilter, depth) {
    if (depth === void 0) {
      depth = 0;
    }

    const rows = []; // Filter from children up first

    for (let i = 0; i < rowsToFilter.length; i++) {
      var _row$subRows;

      row = rowsToFilter[i];

      if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
        newRow = instance.createRow(row.id, row.original, row.index, row.depth);
        newRow.columnFilters = row.columnFilters;
        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);

        if (!newRow.subRows.length) {
          continue;
        }

        row = newRow;
      }

      if (filterRow(row)) {
        rows.push(row);
        newFilteredRowsById[row.id] = row;
        newFilteredRowsById[i] = row;
      }
    }

    return rows;
  };

  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function filterRowModelFromRoot(rowsToFilter, filterRow, instance) {
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  let rows;
  let row;
  let newRow; // Filters top level and nested rows

  const recurseFilterRows = function (rowsToFilter, depth) {
    if (depth === void 0) {
      depth = 0;
    }

    // Filter from parents downward first
    rows = []; // Apply the filter to any subRows

    for (let i = 0; i < rowsToFilter.length; i++) {
      row = rowsToFilter[i];
      const pass = filterRow(row);

      if (pass) {
        var _row$subRows2;

        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
          newRow = instance.createRow(row.id, row.original, row.index, row.depth);
          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
          row = newRow;
        }

        rows.push(row);
        newFilteredFlatRows.push(row);
        newFilteredRowsById[row.id] = row;
      }
    }

    return rows;
  };

  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}

exports.filterRowModelFromLeafs = filterRowModelFromLeafs;
exports.filterRowModelFromRoot = filterRowModelFromRoot;
exports.filterRows = filterRows;
//# sourceMappingURL=filterRowsUtils.js.map
