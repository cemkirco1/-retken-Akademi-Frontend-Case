/**
 * table-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('../utils.js');

//
const Columns = {
  createInstance: instance => {
    return {
      getDefaultColumn: utils.memo(() => [instance.options.defaultColumn], defaultColumn => {
        var _defaultColumn;

        defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
        return {
          header: props => props.header.column.id,
          footer: props => props.header.column.id,
          cell: props => {
            var _props$getValue$toStr, _props$getValue$toStr2, _props$getValue;

            return (_props$getValue$toStr = (_props$getValue$toStr2 = (_props$getValue = props.getValue()).toString) == null ? void 0 : _props$getValue$toStr2.call(_props$getValue)) != null ? _props$getValue$toStr : null;
          },
          ...instance._features.reduce((obj, feature) => {
            return Object.assign(obj, feature.getDefaultColumn == null ? void 0 : feature.getDefaultColumn());
          }, {}),
          ...defaultColumn
        };
      }, {
        debug: () => {
          var _instance$options$deb;

          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugColumns;
        },
        key: process.env.NODE_ENV === 'development' && 'getDefaultColumn'
      }),
      getColumnDefs: () => instance.options.columns,
      createColumn: (columnDef, depth, parent) => {
        var _ref, _columnDef$id;

        const defaultColumn = instance.getDefaultColumn();
        let id = (_ref = (_columnDef$id = columnDef.id) != null ? _columnDef$id : columnDef.accessorKey) != null ? _ref : typeof columnDef.header === 'string' ? columnDef.header : undefined;
        let accessorFn;

        if (columnDef.accessorFn) {
          accessorFn = columnDef.accessorFn;
        } else if (columnDef.accessorKey) {
          accessorFn = originalRow => originalRow[columnDef.accessorKey];
        }

        if (!id) {
          if (process.env.NODE_ENV !== 'production') {
            throw new Error(columnDef.accessorFn ? "Columns require an id when using an accessorFn" : "Columns require an id when using a non-string header");
          }

          throw new Error();
        }

        let column = { ...defaultColumn,
          ...columnDef,
          id: "" + id,
          accessorFn,
          parent: parent,
          depth,
          columnDef,
          columnDefType: columnDef.columnDefType,
          columns: [],
          getFlatColumns: utils.memo(() => [true], () => {
            var _column$columns;

            return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];
          }, {
            key: process.env.NODE_ENV === 'production' && 'column.getFlatColumns',
            debug: () => {
              var _instance$options$deb2;

              return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugColumns;
            }
          }),
          getLeafColumns: utils.memo(() => [instance._getOrderColumnsFn()], orderColumns => {
            var _column$columns2;

            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
              let leafColumns = column.columns.flatMap(column => column.getLeafColumns());
              return orderColumns(leafColumns);
            }

            return [column];
          }, {
            key: process.env.NODE_ENV === 'production' && 'column.getLeafColumns',
            debug: () => {
              var _instance$options$deb3;

              return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugColumns;
            }
          })
        };
        column = instance._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.createColumn == null ? void 0 : feature.createColumn(column, instance));
        }, column); // Yes, we have to convert instance to uknown, because we know more than the compiler here.

        return column;
      },
      getAllColumns: utils.memo(() => [instance.getColumnDefs()], columnDefs => {
        const recurseColumns = function (columnDefs, parent, depth) {
          if (depth === void 0) {
            depth = 0;
          }

          return columnDefs.map(columnDef => {
            const column = instance.createColumn(columnDef, depth, parent);
            column.columns = columnDef.columns ? recurseColumns(columnDef.columns, column, depth + 1) : [];
            return column;
          });
        };

        return recurseColumns(columnDefs);
      }, {
        key: process.env.NODE_ENV === 'development' && 'getAllColumns',
        debug: () => {
          var _instance$options$deb4;

          return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugColumns;
        }
      }),
      getAllFlatColumns: utils.memo(() => [instance.getAllColumns()], allColumns => {
        return allColumns.flatMap(column => {
          return column.getFlatColumns();
        });
      }, {
        key: process.env.NODE_ENV === 'development' && 'getAllFlatColumns',
        debug: () => {
          var _instance$options$deb5;

          return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugColumns;
        }
      }),
      getAllFlatColumnsById: utils.memo(() => [instance.getAllFlatColumns()], flatColumns => {
        return flatColumns.reduce((acc, column) => {
          acc[column.id] = column;
          return acc;
        }, {});
      }, {
        key: process.env.NODE_ENV === 'development' && 'getAllFlatColumnsById',
        debug: () => {
          var _instance$options$deb6;

          return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugColumns;
        }
      }),
      getAllLeafColumns: utils.memo(() => [instance.getAllColumns(), instance._getOrderColumnsFn()], (allColumns, orderColumns) => {
        let leafColumns = allColumns.flatMap(column => column.getLeafColumns());
        return orderColumns(leafColumns);
      }, {
        key: process.env.NODE_ENV === 'development' && 'getAllLeafColumns',
        debug: () => {
          var _instance$options$deb7;

          return (_instance$options$deb7 = instance.options.debugAll) != null ? _instance$options$deb7 : instance.options.debugColumns;
        }
      }),
      getColumn: columnId => {
        const column = instance.getAllFlatColumnsById()[columnId];

        if (!column) {
          if (process.env.NODE_ENV !== 'production') {
            console.warn("[Table] Column with id " + columnId + " does not exist.");
          }

          throw new Error();
        }

        return column;
      }
    };
  }
};

exports.Columns = Columns;
//# sourceMappingURL=Columns.js.map
