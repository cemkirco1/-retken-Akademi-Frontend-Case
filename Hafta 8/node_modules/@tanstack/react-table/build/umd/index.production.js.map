{"version":3,"file":"index.production.js","sources":["../../../table-core/build/esm/index.js","../../src/index.tsx"],"sourcesContent":["/**\n * table-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction noop() {//\n}\nfunction makeStateUpdater(key, instance) {\n  return updater => {\n    instance.setState(old => {\n      return { ...old,\n        [key]: functionalUpdate(updater, old[key])\n      };\n    });\n  };\n}\nfunction isFunction(d) {\n  return d instanceof Function;\n}\nfunction flattenBy(arr, getChildren) {\n  const flat = [];\n\n  const recurse = subArr => {\n    subArr.forEach(item => {\n      flat.push(item);\n      const children = getChildren(item);\n\n      if (children != null && children.length) {\n        recurse(children);\n      }\n    });\n  };\n\n  recurse(arr);\n  return flat;\n}\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return () => {\n    let depTime;\n    if (opts.key && opts.debug) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n\n    if (!depsChanged) {\n      return result;\n    }\n\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);\n\n    if (opts.key && opts.debug) {\n      if (opts != null && opts.debug()) {\n        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n        const resultFpsPercentage = resultEndTime / 16;\n\n        const pad = (str, num) => {\n          str = String(str);\n\n          while (str.length < num) {\n            str = ' ' + str;\n          }\n\n          return str;\n        };\n\n        console.info(\"%c\\u23F1 \" + pad(resultEndTime, 5) + \" /\" + pad(depEndTime, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + \"deg 100% 31%);\", opts == null ? void 0 : opts.key);\n      }\n    }\n\n    return result;\n  };\n}\n\n//\nconst Columns = {\n  createInstance: instance => {\n    return {\n      getDefaultColumn: memo(() => [instance.options.defaultColumn], defaultColumn => {\n        var _defaultColumn;\n\n        defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n        return {\n          header: props => props.header.column.id,\n          footer: props => props.header.column.id,\n          cell: props => {\n            var _props$getValue$toStr, _props$getValue$toStr2, _props$getValue;\n\n            return (_props$getValue$toStr = (_props$getValue$toStr2 = (_props$getValue = props.getValue()).toString) == null ? void 0 : _props$getValue$toStr2.call(_props$getValue)) != null ? _props$getValue$toStr : null;\n          },\n          ...instance._features.reduce((obj, feature) => {\n            return Object.assign(obj, feature.getDefaultColumn == null ? void 0 : feature.getDefaultColumn());\n          }, {}),\n          ...defaultColumn\n        };\n      }, {\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugColumns;\n        },\n        key: process.env.NODE_ENV === 'development' && 'getDefaultColumn'\n      }),\n      getColumnDefs: () => instance.options.columns,\n      createColumn: (columnDef, depth, parent) => {\n        var _ref, _columnDef$id;\n\n        const defaultColumn = instance.getDefaultColumn();\n        let id = (_ref = (_columnDef$id = columnDef.id) != null ? _columnDef$id : columnDef.accessorKey) != null ? _ref : typeof columnDef.header === 'string' ? columnDef.header : undefined;\n        let accessorFn;\n\n        if (columnDef.accessorFn) {\n          accessorFn = columnDef.accessorFn;\n        } else if (columnDef.accessorKey) {\n          accessorFn = originalRow => originalRow[columnDef.accessorKey];\n        }\n\n        if (!id) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(columnDef.accessorFn ? \"Columns require an id when using an accessorFn\" : \"Columns require an id when using a non-string header\");\n          }\n\n          throw new Error();\n        }\n\n        let column = { ...defaultColumn,\n          ...columnDef,\n          id: \"\" + id,\n          accessorFn,\n          parent: parent,\n          depth,\n          columnDef,\n          columnDefType: columnDef.columnDefType,\n          columns: [],\n          getFlatColumns: memo(() => [true], () => {\n            var _column$columns;\n\n            return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];\n          }, {\n            key: process.env.NODE_ENV === 'production' && 'column.getFlatColumns',\n            debug: () => {\n              var _instance$options$deb2;\n\n              return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugColumns;\n            }\n          }),\n          getLeafColumns: memo(() => [instance._getOrderColumnsFn()], orderColumns => {\n            var _column$columns2;\n\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n              let leafColumns = column.columns.flatMap(column => column.getLeafColumns());\n              return orderColumns(leafColumns);\n            }\n\n            return [column];\n          }, {\n            key: process.env.NODE_ENV === 'production' && 'column.getLeafColumns',\n            debug: () => {\n              var _instance$options$deb3;\n\n              return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugColumns;\n            }\n          })\n        };\n        column = instance._features.reduce((obj, feature) => {\n          return Object.assign(obj, feature.createColumn == null ? void 0 : feature.createColumn(column, instance));\n        }, column); // Yes, we have to convert instance to uknown, because we know more than the compiler here.\n\n        return column;\n      },\n      getAllColumns: memo(() => [instance.getColumnDefs()], columnDefs => {\n        const recurseColumns = function (columnDefs, parent, depth) {\n          if (depth === void 0) {\n            depth = 0;\n          }\n\n          return columnDefs.map(columnDef => {\n            const column = instance.createColumn(columnDef, depth, parent);\n            column.columns = columnDef.columns ? recurseColumns(columnDef.columns, column, depth + 1) : [];\n            return column;\n          });\n        };\n\n        return recurseColumns(columnDefs);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getAllColumns',\n        debug: () => {\n          var _instance$options$deb4;\n\n          return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugColumns;\n        }\n      }),\n      getAllFlatColumns: memo(() => [instance.getAllColumns()], allColumns => {\n        return allColumns.flatMap(column => {\n          return column.getFlatColumns();\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getAllFlatColumns',\n        debug: () => {\n          var _instance$options$deb5;\n\n          return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugColumns;\n        }\n      }),\n      getAllFlatColumnsById: memo(() => [instance.getAllFlatColumns()], flatColumns => {\n        return flatColumns.reduce((acc, column) => {\n          acc[column.id] = column;\n          return acc;\n        }, {});\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getAllFlatColumnsById',\n        debug: () => {\n          var _instance$options$deb6;\n\n          return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugColumns;\n        }\n      }),\n      getAllLeafColumns: memo(() => [instance.getAllColumns(), instance._getOrderColumnsFn()], (allColumns, orderColumns) => {\n        let leafColumns = allColumns.flatMap(column => column.getLeafColumns());\n        return orderColumns(leafColumns);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getAllLeafColumns',\n        debug: () => {\n          var _instance$options$deb7;\n\n          return (_instance$options$deb7 = instance.options.debugAll) != null ? _instance$options$deb7 : instance.options.debugColumns;\n        }\n      }),\n      getColumn: columnId => {\n        const column = instance.getAllFlatColumnsById()[columnId];\n\n        if (!column) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\"[Table] Column with id \" + columnId + \" does not exist.\");\n          }\n\n          throw new Error();\n        }\n\n        return column;\n      }\n    };\n  }\n};\n\n//\nconst Rows = {\n  // createRow: <TGenerics extends TableGenerics>(\n  //   row: Row<TGenerics>,\n  //   instance: TableInstance<TGenerics>\n  // ): CellsRow<TGenerics> => {\n  //   return {}\n  // },\n  createInstance: instance => {\n    return {\n      getRowId: (row, index, parent) => {\n        var _instance$options$get;\n\n        return (_instance$options$get = instance.options.getRowId == null ? void 0 : instance.options.getRowId(row, index, parent)) != null ? _instance$options$get : \"\" + (parent ? [parent.id, index].join('.') : index);\n      },\n      createRow: (id, original, rowIndex, depth, subRows) => {\n        let row = {\n          id,\n          index: rowIndex,\n          original,\n          depth,\n          valuesCache: {},\n          getValue: columnId => {\n            if (row.valuesCache.hasOwnProperty(columnId)) {\n              return row.valuesCache[columnId];\n            }\n\n            const column = instance.getColumn(columnId);\n\n            if (!column.accessorFn) {\n              return undefined;\n            }\n\n            row.valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row.valuesCache[columnId];\n          },\n          subRows: subRows != null ? subRows : [],\n          getLeafRows: () => flattenBy(row.subRows, d => d.subRows)\n        };\n\n        for (let i = 0; i < instance._features.length; i++) {\n          const feature = instance._features[i];\n          Object.assign(row, feature == null ? void 0 : feature.createRow == null ? void 0 : feature.createRow(row, instance));\n        }\n\n        return row;\n      },\n      getCoreRowModel: () => {\n        if (!instance._getCoreRowModel) {\n          instance._getCoreRowModel = instance.options.getCoreRowModel(instance);\n        }\n\n        return instance._getCoreRowModel();\n      },\n      // The final calls start at the bottom of the model,\n      // expanded rows, which then work their way up\n      getRowModel: () => {\n        return instance.getPaginationRowModel();\n      },\n      getRow: id => {\n        const row = instance.getRowModel().rowsById[id];\n\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\"getRow expected an ID, but got \" + id);\n          }\n\n          throw new Error();\n        }\n\n        return row;\n      }\n    };\n  }\n};\n\n//\nconst Cells = {\n  createRow: (row, instance) => {\n    return {\n      getAllCells: memo(() => [instance.getAllLeafColumns()], leafColumns => {\n        return leafColumns.map(column => {\n          return instance.createCell(row, column, column.id);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'row.getAllCells',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n        }\n      }),\n      getAllCellsByColumnId: memo(() => [row.getAllCells()], allCells => {\n        return allCells.reduce((acc, cell) => {\n          acc[cell.columnId] = cell;\n          return acc;\n        }, {});\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getAllCellsByColumnId',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n        }\n      })\n    };\n  },\n  createInstance: instance => {\n    return {\n      createCell: (row, column, columnId) => {\n        const cell = {\n          id: row.id + \"_\" + column.id,\n          rowId: row.id,\n          columnId,\n          row,\n          column,\n          getValue: () => row.getValue(columnId),\n          renderCell: () => column.cell ? instance._render(column.cell, {\n            instance,\n            column,\n            row,\n            cell: cell,\n            getValue: cell.getValue\n          }) : null\n        };\n\n        instance._features.forEach(feature => {\n          Object.assign(cell, feature.createCell == null ? void 0 : feature.createCell(cell, column, row, instance));\n        }, {});\n\n        return cell;\n      },\n      getCell: (rowId, columnId) => {\n        const row = instance.getRow(rowId);\n\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\"[Table] could not find row with id \" + rowId);\n          }\n\n          throw new Error();\n        }\n\n        const cell = row.getAllCellsByColumnId()[columnId];\n\n        if (!cell) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\"[Table] could not find cell \" + columnId + \" in row \" + rowId);\n          }\n\n          throw new Error();\n        }\n\n        return cell;\n      }\n    };\n  }\n};\n\n//\nconst defaultColumnSizing = {\n  size: 150,\n  minSize: 20,\n  maxSize: Number.MAX_SAFE_INTEGER\n};\n\nconst getDefaultColumnSizingInfoState = () => ({\n  startOffset: null,\n  startSize: null,\n  deltaOffset: null,\n  deltaPercentage: null,\n  isResizingColumn: false,\n  columnSizingStart: []\n});\n\nconst ColumnSizing = {\n  getDefaultColumn: () => {\n    return defaultColumnSizing;\n  },\n  getInitialState: state => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: getDefaultColumnSizingInfoState(),\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      columnResizeMode: 'onEnd',\n      onColumnSizingChange: makeStateUpdater('columnSizing', instance),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', instance)\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      getSize: () => {\n        var _column$minSize, _ref, _column$maxSize;\n\n        const columnSize = instance.getState().columnSizing[column.id];\n        return Math.min(Math.max((_column$minSize = column.minSize) != null ? _column$minSize : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.size) != null ? _ref : defaultColumnSizing.size), (_column$maxSize = column.maxSize) != null ? _column$maxSize : defaultColumnSizing.maxSize);\n      },\n      getStart: position => {\n        const columns = !position ? instance.getVisibleLeafColumns() : position === 'left' ? instance.getLeftVisibleLeafColumns() : instance.getRightVisibleLeafColumns();\n        const index = columns.findIndex(d => d.id === column.id);\n\n        if (index > 0) {\n          const prevSiblingColumn = columns[index - 1];\n          return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();\n        }\n\n        return 0;\n      },\n      resetSize: () => {\n        instance.setColumnSizing(_ref2 => {\n          let {\n            [column.id]: _,\n            ...rest\n          } = _ref2;\n          return rest;\n        });\n      },\n      getCanResize: () => {\n        var _column$enableResizin, _instance$options$ena;\n\n        return ((_column$enableResizin = column.enableResizing) != null ? _column$enableResizin : true) && ((_instance$options$ena = instance.options.enableColumnResizing) != null ? _instance$options$ena : true);\n      },\n      getIsResizing: () => {\n        return instance.getState().columnSizingInfo.isResizingColumn === column.id;\n      }\n    };\n  },\n  createHeader: (header, instance) => {\n    return {\n      getSize: () => {\n        let sum = 0;\n\n        const recurse = header => {\n          if (header.subHeaders.length) {\n            header.subHeaders.forEach(recurse);\n          } else {\n            var _header$column$getSiz;\n\n            sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n          }\n        };\n\n        recurse(header);\n        return sum;\n      },\n      getStart: () => {\n        if (header.index > 0) {\n          const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n          return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n        }\n\n        return 0;\n      },\n      getResizeHandler: () => {\n        const column = instance.getColumn(header.column.id);\n        const canResize = column.getCanResize();\n        return e => {\n          if (!canResize) {\n            return;\n          }\n          e.persist == null ? void 0 : e.persist();\n\n          if (isTouchStartEvent(e)) {\n            // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n            if (e.touches && e.touches.length > 1) {\n              return;\n            }\n          }\n\n          const startSize = header.getSize();\n          const columnSizingStart = header ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];\n          const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n\n          const updateOffset = (eventType, clientXPos) => {\n            if (typeof clientXPos !== 'number') {\n              return;\n            }\n\n            let newColumnSizing = {};\n            instance.setColumnSizingInfo(old => {\n              var _old$startOffset, _old$startSize;\n\n              const deltaOffset = clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0);\n              const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n              old.columnSizingStart.forEach(_ref3 => {\n                let [columnId, headerSize] = _ref3;\n                newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n              });\n              return { ...old,\n                deltaOffset,\n                deltaPercentage\n              };\n            });\n\n            if (instance.options.columnResizeMode === 'onChange' || eventType === 'end') {\n              instance.setColumnSizing(old => ({ ...old,\n                ...newColumnSizing\n              }));\n            }\n          };\n\n          const onMove = clientXPos => updateOffset('move', clientXPos);\n\n          const onEnd = clientXPos => {\n            updateOffset('end', clientXPos);\n            instance.setColumnSizingInfo(old => ({ ...old,\n              isResizingColumn: false,\n              startOffset: null,\n              startSize: null,\n              deltaOffset: null,\n              deltaPercentage: null,\n              columnSizingStart: []\n            }));\n          };\n\n          const mouseEvents = {\n            moveHandler: e => onMove(e.clientX),\n            upHandler: e => {\n              document.removeEventListener('mousemove', mouseEvents.moveHandler);\n              document.removeEventListener('mouseup', mouseEvents.upHandler);\n              onEnd(e.clientX);\n            }\n          };\n          const passiveIfSupported = passiveEventSupported() ? {\n            passive: false\n          } : false;\n\n          if (isTouchStartEvent(e)) ; else {\n            document.addEventListener('mousemove', mouseEvents.moveHandler, passiveIfSupported);\n            document.addEventListener('mouseup', mouseEvents.upHandler, passiveIfSupported);\n          }\n\n          instance.setColumnSizingInfo(old => ({ ...old,\n            startOffset: clientX,\n            startSize,\n            deltaOffset: 0,\n            deltaPercentage: 0,\n            columnSizingStart,\n            isResizingColumn: column.id\n          }));\n        };\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnSizing: updater => instance.options.onColumnSizingChange == null ? void 0 : instance.options.onColumnSizingChange(updater),\n      setColumnSizingInfo: updater => instance.options.onColumnSizingInfoChange == null ? void 0 : instance.options.onColumnSizingInfoChange(updater),\n      resetColumnSizing: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnSizing(defaultState ? {} : (_instance$initialStat = instance.initialState.columnSizing) != null ? _instance$initialStat : {});\n      },\n      resetHeaderSizeInfo: defaultState => {\n        var _instance$initialStat2;\n\n        instance.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_instance$initialStat2 = instance.initialState.columnSizingInfo) != null ? _instance$initialStat2 : getDefaultColumnSizingInfoState());\n      },\n      getTotalSize: () => {\n        var _instance$getHeaderGr, _instance$getHeaderGr2;\n\n        return (_instance$getHeaderGr = (_instance$getHeaderGr2 = instance.getHeaderGroups()[0]) == null ? void 0 : _instance$getHeaderGr2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getHeaderGr : 0;\n      },\n      getLeftTotalSize: () => {\n        var _instance$getLeftHead, _instance$getLeftHead2;\n\n        return (_instance$getLeftHead = (_instance$getLeftHead2 = instance.getLeftHeaderGroups()[0]) == null ? void 0 : _instance$getLeftHead2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getLeftHead : 0;\n      },\n      getCenterTotalSize: () => {\n        var _instance$getCenterHe, _instance$getCenterHe2;\n\n        return (_instance$getCenterHe = (_instance$getCenterHe2 = instance.getCenterHeaderGroups()[0]) == null ? void 0 : _instance$getCenterHe2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getCenterHe : 0;\n      },\n      getRightTotalSize: () => {\n        var _instance$getRightHea, _instance$getRightHea2;\n\n        return (_instance$getRightHea = (_instance$getRightHea2 = instance.getRightHeaderGroups()[0]) == null ? void 0 : _instance$getRightHea2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getRightHea : 0;\n      }\n    };\n  }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported;\n  let supported = false;\n\n  try {\n    const options = {\n      get passive() {\n        supported = true;\n        return false;\n      }\n\n    };\n\n    const noop = () => {};\n\n    window.addEventListener('test', noop, options);\n    window.removeEventListener('test', noop);\n  } catch (err) {\n    supported = false;\n  }\n\n  passiveSupported = supported;\n  return passiveSupported;\n}\n\nfunction isTouchStartEvent(e) {\n  return e.type === 'touchstart';\n}\n\n//\nconst Expanding = {\n  getInitialState: state => {\n    return {\n      expanded: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', instance),\n      autoResetExpanded: true,\n      expandSubRows: true,\n      paginateExpandedRows: true\n    };\n  },\n  createInstance: instance => {\n    let registered = false;\n    let queued = false;\n    return {\n      _autoResetExpanded: () => {\n        if (!registered) {\n          instance._queue(() => {\n            registered = true;\n          });\n\n          return;\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return;\n        }\n\n        if (instance.options.autoResetAll === true || instance.options.autoResetExpanded) {\n          if (queued) return;\n          queued = true;\n\n          instance._queue(() => {\n            instance.resetExpanded();\n            queued = false;\n          });\n        }\n      },\n      setExpanded: updater => instance.options.onExpandedChange == null ? void 0 : instance.options.onExpandedChange(updater),\n      toggleAllRowsExpanded: expanded => {\n        if (expanded != null ? expanded : !instance.getIsAllRowsExpanded()) {\n          instance.setExpanded(true);\n        } else {\n          instance.setExpanded({});\n        }\n      },\n      resetExpanded: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setExpanded(defaultState ? {} : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.expanded) != null ? _instance$initialStat : {});\n      },\n      getCanSomeRowsExpand: () => {\n        return instance.getRowModel().flatRows.some(row => row.getCanExpand());\n      },\n      getToggleAllRowsExpandedHandler: () => {\n        return e => {\n          e.persist == null ? void 0 : e.persist();\n          instance.toggleAllRowsExpanded();\n        };\n      },\n      getIsSomeRowsExpanded: () => {\n        const expanded = instance.getState().expanded;\n        return expanded === true || Object.values(expanded).some(Boolean);\n      },\n      getIsAllRowsExpanded: () => {\n        const expanded = instance.getState().expanded; // If expanded is true, save some cycles and return true\n\n        if (expanded === true) {\n          return true;\n        } // If any row is not expanded, return false\n\n\n        if (instance.getRowModel().flatRows.some(row => row.getIsExpanded())) {\n          return false;\n        } // They must all be expanded :shrug:\n\n\n        return true;\n      },\n      getExpandedDepth: () => {\n        let maxDepth = 0;\n        const rowIds = instance.getState().expanded === true ? Object.keys(instance.getRowModel().rowsById) : Object.keys(instance.getState().expanded);\n        rowIds.forEach(id => {\n          const splitId = id.split('.');\n          maxDepth = Math.max(maxDepth, splitId.length);\n        });\n        return maxDepth;\n      },\n      getPreExpandedRowModel: () => instance.getGroupedRowModel(),\n      getExpandedRowModel: () => {\n        if (!instance._getExpandedRowModel && instance.options.getExpandedRowModel) {\n          instance._getExpandedRowModel = instance.options.getExpandedRowModel(instance);\n        }\n\n        if (instance.options.manualExpanding || !instance._getExpandedRowModel) {\n          return instance.getPreExpandedRowModel();\n        }\n\n        return instance._getExpandedRowModel();\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      toggleExpanded: expanded => {\n        instance.setExpanded(old => {\n          var _expanded;\n\n          const exists = old === true ? true : !!(old != null && old[row.id]);\n          let oldExpanded = {};\n\n          if (old === true) {\n            Object.keys(instance.getRowModel().rowsById).forEach(rowId => {\n              oldExpanded[rowId] = true;\n            });\n          } else {\n            oldExpanded = old;\n          }\n\n          expanded = (_expanded = expanded) != null ? _expanded : !exists;\n\n          if (!exists && expanded) {\n            return { ...oldExpanded,\n              [row.id]: true\n            };\n          }\n\n          if (exists && !expanded) {\n            const {\n              [row.id]: _,\n              ...rest\n            } = oldExpanded;\n            return rest;\n          }\n\n          return old;\n        });\n      },\n      getIsExpanded: () => {\n        var _instance$options$get;\n\n        const expanded = instance.getState().expanded;\n        return !!((_instance$options$get = instance.options.getIsRowExpanded == null ? void 0 : instance.options.getIsRowExpanded(row)) != null ? _instance$options$get : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n      },\n      getCanExpand: () => {\n        var _instance$options$get2, _instance$options$ena, _row$subRows;\n\n        return ((_instance$options$get2 = instance.options.getRowCanExpand == null ? void 0 : instance.options.getRowCanExpand(row)) != null ? _instance$options$get2 : true) && ((_instance$options$ena = instance.options.enableExpanding) != null ? _instance$options$ena : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n      },\n      getToggleExpandedHandler: () => {\n        const canExpand = row.getCanExpand();\n        return () => {\n          if (!canExpand) return;\n          row.toggleExpanded();\n        };\n      }\n    };\n  }\n};\n\nconst includesString = (row, columnId, filterValue) => {\n  const search = filterValue.toLowerCase();\n  return row.getValue(columnId).toLowerCase().includes(search);\n};\n\nincludesString.autoRemove = val => testFalsey(val);\n\nconst includesStringSensitive = (row, columnId, filterValue) => {\n  return row.getValue(columnId).includes(filterValue);\n};\n\nincludesStringSensitive.autoRemove = val => testFalsey(val);\n\nconst equalsString = (row, columnId, filterValue) => {\n  return row.getValue(columnId).toLowerCase() === filterValue.toLowerCase();\n};\n\nequalsString.autoRemove = val => testFalsey(val);\n\nconst arrIncludes = (row, columnId, filterValue) => {\n  return row.getValue(columnId).includes(filterValue);\n};\n\narrIncludes.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst arrIncludesAll = (row, columnId, filterValue) => {\n  return !filterValue.some(val => !row.getValue(columnId).includes(val));\n};\n\narrIncludesAll.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst arrIncludesSome = (row, columnId, filterValue) => {\n  return filterValue.some(val => row.getValue(columnId).includes(val));\n};\n\narrIncludesSome.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst equals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) === filterValue;\n};\n\nequals.autoRemove = val => testFalsey(val);\n\nconst weakEquals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) == filterValue;\n};\n\nweakEquals.autoRemove = val => testFalsey(val);\n\nconst inNumberRange = (row, columnId, filterValue) => {\n  let [min, max] = filterValue;\n  const rowValue = row.getValue(columnId);\n  return rowValue >= min && rowValue <= max;\n};\n\ninNumberRange.resolveFilterValue = val => {\n  let [unsafeMin, unsafeMax] = val;\n  let parsedMin = typeof unsafeMin !== 'number' ? parseFloat(unsafeMin) : unsafeMin;\n  let parsedMax = typeof unsafeMax !== 'number' ? parseFloat(unsafeMax) : unsafeMax;\n  let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n\n  if (min > max) {\n    const temp = min;\n    min = max;\n    max = temp;\n  }\n\n  return [min, max];\n};\n\ninNumberRange.autoRemove = val => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]); // Export\n\n\nconst filterFns = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  arrIncludes,\n  arrIncludesAll,\n  arrIncludesSome,\n  equals,\n  weakEquals,\n  inNumberRange\n};\n\n// Utils\nfunction testFalsey(val) {\n  return val === undefined || val === null || val === '';\n}\n\n//\nconst Filters = {\n  getDefaultColumn: () => {\n    return {\n      filterFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      columnFilters: [],\n      globalFilter: undefined,\n      // filtersProgress: 1,\n      // facetProgress: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', instance),\n      onGlobalFilterChange: makeStateUpdater('globalFilter', instance),\n      filterFromLeafRows: false,\n      globalFilterFn: 'auto',\n      getColumnCanGlobalFilter: column => {\n        var _instance$getCoreRowM, _instance$getCoreRowM2;\n\n        const value = (_instance$getCoreRowM = instance.getCoreRowModel().flatRows[0]) == null ? void 0 : (_instance$getCoreRowM2 = _instance$getCoreRowM.getAllCellsByColumnId()[column.id]) == null ? void 0 : _instance$getCoreRowM2.getValue();\n        return typeof value === 'string';\n      }\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      filterFn: column.filterFn,\n      getAutoFilterFn: () => {\n        const firstRow = instance.getCoreRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'string') {\n          return filterFns.includesString;\n        }\n\n        if (typeof value === 'number') {\n          return filterFns.inNumberRange;\n        }\n\n        if (value !== null && typeof value === 'object') {\n          return filterFns.equals;\n        }\n\n        if (Array.isArray(value)) {\n          return filterFns.arrIncludes;\n        }\n\n        return filterFns.weakEquals;\n      },\n      getFilterFn: () => {\n        var _ref;\n\n        const userFilterFns = instance.options.filterFns;\n        return isFunction(column.filterFn) ? column.filterFn : column.filterFn === 'auto' ? column.getAutoFilterFn() : (_ref = userFilterFns == null ? void 0 : userFilterFns[column.filterFn]) != null ? _ref : filterFns[column.filterFn];\n      },\n      getCanFilter: () => {\n        var _column$enableColumnF, _instance$options$ena, _instance$options$ena2;\n\n        return ((_column$enableColumnF = column.enableColumnFilter) != null ? _column$enableColumnF : true) && ((_instance$options$ena = instance.options.enableColumnFilters) != null ? _instance$options$ena : true) && ((_instance$options$ena2 = instance.options.enableFilters) != null ? _instance$options$ena2 : true) && !!column.accessorFn;\n      },\n      getCanGlobalFilter: () => {\n        var _column$enableGlobalF, _instance$options$ena3, _instance$options$ena4, _instance$options$get;\n\n        return ((_column$enableGlobalF = column.enableGlobalFilter) != null ? _column$enableGlobalF : true) && ((_instance$options$ena3 = instance.options.enableGlobalFilter) != null ? _instance$options$ena3 : true) && ((_instance$options$ena4 = instance.options.enableFilters) != null ? _instance$options$ena4 : true) && ((_instance$options$get = instance.options.getColumnCanGlobalFilter == null ? void 0 : instance.options.getColumnCanGlobalFilter(column)) != null ? _instance$options$get : true) && !!column.accessorFn;\n      },\n      getIsFiltered: () => column.getFilterIndex() > -1,\n      getFilterValue: () => {\n        var _instance$getState$co, _instance$getState$co2;\n\n        return (_instance$getState$co = instance.getState().columnFilters) == null ? void 0 : (_instance$getState$co2 = _instance$getState$co.find(d => d.id === column.id)) == null ? void 0 : _instance$getState$co2.value;\n      },\n      getFilterIndex: () => {\n        var _instance$getState$co3, _instance$getState$co4;\n\n        return (_instance$getState$co3 = (_instance$getState$co4 = instance.getState().columnFilters) == null ? void 0 : _instance$getState$co4.findIndex(d => d.id === column.id)) != null ? _instance$getState$co3 : -1;\n      },\n      setFilterValue: value => {\n        instance.setColumnFilters(old => {\n          const filterFn = column.getFilterFn();\n          const previousfilter = old == null ? void 0 : old.find(d => d.id === column.id);\n          const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined); //\n\n          if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n            var _old$filter;\n\n            return (_old$filter = old == null ? void 0 : old.filter(d => d.id !== column.id)) != null ? _old$filter : [];\n          }\n\n          const newFilterObj = {\n            id: column.id,\n            value: newFilter\n          };\n\n          if (previousfilter) {\n            var _old$map;\n\n            return (_old$map = old == null ? void 0 : old.map(d => {\n              if (d.id === column.id) {\n                return newFilterObj;\n              }\n\n              return d;\n            })) != null ? _old$map : [];\n          }\n\n          if (old != null && old.length) {\n            return [...old, newFilterObj];\n          }\n\n          return [newFilterObj];\n        });\n      },\n      _getFacetedRowModel: instance.options.getFacetedRowModel && instance.options.getFacetedRowModel(instance, column.id),\n      getFacetedRowModel: () => {\n        if (!column._getFacetedRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return column._getFacetedRowModel();\n      },\n      _getFacetedUniqueValues: instance.options.getFacetedUniqueValues && instance.options.getFacetedUniqueValues(instance, column.id),\n      getFacetedUniqueValues: () => {\n        if (!column._getFacetedUniqueValues) {\n          return new Map();\n        }\n\n        return column._getFacetedUniqueValues();\n      },\n      _getFacetedMinMaxValues: instance.options.getFacetedMinMaxValues && instance.options.getFacetedMinMaxValues(instance, column.id),\n      getFacetedMinMaxValues: () => {\n        if (!column._getFacetedMinMaxValues) {\n          return undefined;\n        }\n\n        return column._getFacetedMinMaxValues();\n      } // () => [column.getFacetedRowModel()],\n      // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      columnFilters: {},\n      columnFiltersMeta: {},\n      subRowsByFacetId: {}\n    };\n  },\n  createInstance: instance => {\n    return {\n      getGlobalAutoFilterFn: () => {\n        return filterFns.includesString;\n      },\n      getGlobalFilterFn: () => {\n        var _ref2;\n\n        const {\n          filterFns: userFilterFns,\n          globalFilterFn: globalFilterFn\n        } = instance.options;\n        return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === 'auto' ? instance.getGlobalAutoFilterFn() : (_ref2 = userFilterFns == null ? void 0 : userFilterFns[globalFilterFn]) != null ? _ref2 : filterFns[globalFilterFn];\n      },\n      setColumnFilters: updater => {\n        const leafColumns = instance.getAllLeafColumns();\n\n        const updateFn = old => {\n          var _functionalUpdate;\n\n          return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter(filter => {\n            const column = leafColumns.find(d => d.id === filter.id);\n\n            if (column) {\n              const filterFn = column.getFilterFn();\n\n              if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                return false;\n              }\n            }\n\n            return true;\n          });\n        };\n\n        instance.options.onColumnFiltersChange == null ? void 0 : instance.options.onColumnFiltersChange(updateFn);\n      },\n      setGlobalFilter: updater => {\n        instance.options.onGlobalFilterChange == null ? void 0 : instance.options.onGlobalFilterChange(updater);\n      },\n      resetGlobalFilter: defaultState => {\n        instance.setGlobalFilter(defaultState ? undefined : instance.initialState.globalFilter);\n      },\n      resetColumnFilters: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setColumnFilters(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.columnFilters) != null ? _instance$initialStat : []);\n      },\n      getPreFilteredRowModel: () => instance.getCoreRowModel(),\n      _getFilteredRowModel: instance.options.getFilteredRowModel && instance.options.getFilteredRowModel(instance),\n      getFilteredRowModel: () => {\n        if (instance.options.manualFiltering || !instance._getFilteredRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return instance._getFilteredRowModel();\n      },\n      _getGlobalFacetedRowModel: instance.options.getFacetedRowModel && instance.options.getFacetedRowModel(instance, '__global__'),\n      getGlobalFacetedRowModel: () => {\n        if (instance.options.manualFiltering || !instance._getGlobalFacetedRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return instance._getGlobalFacetedRowModel();\n      },\n      _getGlobalFacetedUniqueValues: instance.options.getFacetedUniqueValues && instance.options.getFacetedUniqueValues(instance, '__global__'),\n      getGlobalFacetedUniqueValues: () => {\n        if (!instance._getGlobalFacetedUniqueValues) {\n          return new Map();\n        }\n\n        return instance._getGlobalFacetedUniqueValues();\n      },\n      _getGlobalFacetedMinMaxValues: instance.options.getFacetedMinMaxValues && instance.options.getFacetedMinMaxValues(instance, '__global__'),\n      getGlobalFacetedMinMaxValues: () => {\n        if (!instance._getGlobalFacetedMinMaxValues) {\n          return;\n        }\n\n        return instance._getGlobalFacetedMinMaxValues();\n      }\n    };\n  }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === 'undefined' || typeof value === 'string' && !value;\n}\n\nconst aggregationFns = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count\n};\n\nfunction sum(_getLeafValues, getChildValues) {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return getChildValues().reduce((sum, next) => sum + (typeof next === 'number' ? next : 0), 0);\n}\n\nfunction min(_getLeafValues, getChildValues) {\n  let min;\n\n  for (const value of getChildValues()) {\n    if (value != null && (min > value || min === undefined && value >= value)) {\n      min = value;\n    }\n  }\n\n  return min;\n}\n\nfunction max(_getLeafValues, getChildValues) {\n  let max;\n\n  for (const value of getChildValues()) {\n    if (value != null && (max < value || max === undefined && value >= value)) {\n      max = value;\n    }\n  }\n\n  return max;\n}\n\nfunction extent(_getLeafValues, getChildValues) {\n  let min;\n  let max;\n\n  for (const value of getChildValues()) {\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value;\n      } else {\n        if (min > value) min = value;\n        if (max < value) max = value;\n      }\n    }\n  }\n\n  return [min, max];\n}\n\nfunction mean(getLeafValues) {\n  let count = 0;\n  let sum = 0;\n\n  for (let value of getLeafValues()) {\n    if (value != null && (value = +value) >= value) {\n      ++count, sum += value;\n    }\n  }\n\n  if (count) return sum / count;\n  return;\n}\n\nfunction median(getLeafValues) {\n  const leafValues = getLeafValues();\n\n  if (!leafValues.length) {\n    return;\n  }\n\n  let min = 0;\n  let max = 0;\n  leafValues.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n    }\n  });\n  return (min + max) / 2;\n}\n\nfunction unique(getLeafValues) {\n  return Array.from(new Set(getLeafValues()).values());\n}\n\nfunction uniqueCount(getLeafValues) {\n  return new Set(getLeafValues()).size;\n}\n\nfunction count(getLeafValues) {\n  return getLeafValues().length;\n}\n\n//\nconst Grouping = {\n  getDefaultColumn: () => {\n    return {\n      aggregationFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      grouping: [],\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', instance),\n      groupedColumnMode: 'reorder'\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      toggleGrouping: () => {\n        instance.setGrouping(old => {\n          // Find any existing grouping for this column\n          if (old != null && old.includes(column.id)) {\n            return old.filter(d => d !== column.id);\n          }\n\n          return [...(old != null ? old : []), column.id];\n        });\n      },\n      getCanGroup: () => {\n        var _ref, _ref2, _ref3, _column$enableGroupin;\n\n        return (_ref = (_ref2 = (_ref3 = (_column$enableGroupin = column.enableGrouping) != null ? _column$enableGroupin : true) != null ? _ref3 : instance.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n      },\n      getIsGrouped: () => {\n        var _instance$getState$gr;\n\n        return (_instance$getState$gr = instance.getState().grouping) == null ? void 0 : _instance$getState$gr.includes(column.id);\n      },\n      getGroupedIndex: () => {\n        var _instance$getState$gr2;\n\n        return (_instance$getState$gr2 = instance.getState().grouping) == null ? void 0 : _instance$getState$gr2.indexOf(column.id);\n      },\n      getToggleGroupingHandler: () => {\n        const canGroup = column.getCanGroup();\n        return () => {\n          if (!canGroup) return;\n          column.toggleGrouping();\n        };\n      },\n      getColumnAutoAggregationFn: () => {\n        const firstRow = instance.getCoreRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'number') {\n          return aggregationFns.sum;\n        }\n\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return aggregationFns.extent;\n        }\n\n        return aggregationFns.count;\n      },\n      getColumnAggregationFn: () => {\n        var _ref4;\n\n        const userAggregationFns = instance.options.aggregationFns;\n\n        if (!column) {\n          throw new Error();\n        }\n\n        return isFunction(column.aggregationFn) ? column.aggregationFn : column.aggregationFn === 'auto' ? column.getColumnAutoAggregationFn() : (_ref4 = userAggregationFns == null ? void 0 : userAggregationFns[column.aggregationFn]) != null ? _ref4 : aggregationFns[column.aggregationFn];\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setGrouping: updater => instance.options.onGroupingChange == null ? void 0 : instance.options.onGroupingChange(updater),\n      resetGrouping: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setGrouping(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.grouping) != null ? _instance$initialStat : []);\n      },\n      getPreGroupedRowModel: () => instance.getSortedRowModel(),\n      getGroupedRowModel: () => {\n        if (!instance._getGroupedRowModel && instance.options.getGroupedRowModel) {\n          instance._getGroupedRowModel = instance.options.getGroupedRowModel(instance);\n        }\n\n        if (instance.options.manualGrouping || !instance._getGroupedRowModel) {\n          return instance.getPreGroupedRowModel();\n        }\n\n        return instance._getGroupedRowModel();\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      getIsGrouped: () => !!row.groupingColumnId,\n      groupingValuesCache: {}\n    };\n  },\n  createCell: (cell, column, row, instance) => {\n    return {\n      getIsGrouped: () => column.getIsGrouped() && column.id === row.groupingColumnId,\n      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),\n      getIsAggregated: () => {\n        var _row$subRows;\n\n        return !cell.getIsGrouped() && !cell.getIsPlaceholder() && ((_row$subRows = row.subRows) == null ? void 0 : _row$subRows.length) > 1;\n      },\n      renderAggregatedCell: () => {\n        var _column$aggregatedCel;\n\n        const template = (_column$aggregatedCel = column.aggregatedCell) != null ? _column$aggregatedCel : column.cell;\n        return template ? instance._render(template, {\n          instance,\n          column,\n          row,\n          cell,\n          getValue: cell.getValue\n        }) : null;\n      }\n    };\n  }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n  if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n    return leafColumns;\n  }\n\n  const nonGroupingColumns = leafColumns.filter(col => !grouping.includes(col.id));\n\n  if (groupedColumnMode === 'remove') {\n    return nonGroupingColumns;\n  }\n\n  const groupingColumns = grouping.map(g => leafColumns.find(col => col.id === g)).filter(Boolean);\n  return [...groupingColumns, ...nonGroupingColumns];\n}\n\n//\nconst Ordering = {\n  getInitialState: state => {\n    return {\n      columnOrder: [],\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', instance)\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnOrder: updater => instance.options.onColumnOrderChange == null ? void 0 : instance.options.onColumnOrderChange(updater),\n      resetColumnOrder: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnOrder(defaultState ? [] : (_instance$initialStat = instance.initialState.columnOrder) != null ? _instance$initialStat : []);\n      },\n      _getOrderColumnsFn: memo(() => [instance.getState().columnOrder, instance.getState().grouping, instance.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => columns => {\n        // Sort grouped columns to the start of the column list\n        // before the headers are built\n        let orderedColumns = []; // If there is no order, return the normal columns\n\n        if (!(columnOrder != null && columnOrder.length)) {\n          orderedColumns = columns;\n        } else {\n          const columnOrderCopy = [...columnOrder]; // If there is an order, make a copy of the columns\n\n          const columnsCopy = [...columns]; // And make a new ordered array of the columns\n          // Loop over the columns and place them in order into the new array\n\n          while (columnsCopy.length && columnOrderCopy.length) {\n            const targetColumnId = columnOrderCopy.shift();\n            const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnId);\n\n            if (foundIndex > -1) {\n              orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n            }\n          } // If there are any columns left, add them to the end\n\n\n          orderedColumns = [...orderedColumns, ...columnsCopy];\n        }\n\n        return orderColumns(orderedColumns, grouping, groupedColumnMode);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getOrderColumnsFn' // debug: () => instance.options.debugAll ?? instance.options.debugTable,\n\n      })\n    };\n  }\n};\n\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\n\nconst getDefaultPaginationState = () => ({\n  pageIndex: defaultPageIndex,\n  pageSize: defaultPageSize\n});\n\nconst Pagination = {\n  getInitialState: state => {\n    return { ...state,\n      pagination: { ...getDefaultPaginationState(),\n        ...(state == null ? void 0 : state.pagination)\n      }\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', instance)\n    };\n  },\n  createInstance: instance => {\n    let registered = false;\n    let queued = false;\n    return {\n      _autoResetPageIndex: () => {\n        var _ref, _instance$options$aut;\n\n        if (!registered) {\n          instance._queue(() => {\n            registered = true;\n          });\n\n          return;\n        }\n\n        if ((_ref = (_instance$options$aut = instance.options.autoResetAll) != null ? _instance$options$aut : instance.options.autoResetPageIndex) != null ? _ref : !instance.options.manualPagination) {\n          if (queued) return;\n          queued = true;\n\n          instance._queue(() => {\n            instance.resetPageIndex();\n            queued = false;\n          });\n        }\n      },\n      setPagination: updater => {\n        const safeUpdater = old => {\n          let newState = functionalUpdate(updater, old);\n          return newState;\n        };\n\n        return instance.options.onPaginationChange == null ? void 0 : instance.options.onPaginationChange(safeUpdater);\n      },\n      resetPagination: defaultState => {\n        var _instance$initialStat;\n\n        instance.setPagination(defaultState ? getDefaultPaginationState() : (_instance$initialStat = instance.initialState.pagination) != null ? _instance$initialStat : getDefaultPaginationState());\n      },\n      setPageIndex: updater => {\n        instance.setPagination(old => {\n          let pageIndex = functionalUpdate(updater, old.pageIndex);\n          const maxPageIndex = typeof old.pageCount !== 'undefined' ? old.pageCount - 1 : Number.MAX_SAFE_INTEGER;\n          pageIndex = Math.min(Math.max(0, pageIndex), maxPageIndex);\n          return { ...old,\n            pageIndex\n          };\n        });\n      },\n      resetPageIndex: defaultState => {\n        var _instance$initialStat2, _instance$initialStat3, _instance$initialStat4;\n\n        instance.setPageIndex(defaultState ? defaultPageIndex : (_instance$initialStat2 = (_instance$initialStat3 = instance.initialState) == null ? void 0 : (_instance$initialStat4 = _instance$initialStat3.pagination) == null ? void 0 : _instance$initialStat4.pageIndex) != null ? _instance$initialStat2 : defaultPageIndex);\n      },\n      resetPageSize: defaultState => {\n        var _instance$initialStat5, _instance$initialStat6, _instance$initialStat7;\n\n        instance.setPageSize(defaultState ? defaultPageSize : (_instance$initialStat5 = (_instance$initialStat6 = instance.initialState) == null ? void 0 : (_instance$initialStat7 = _instance$initialStat6.pagination) == null ? void 0 : _instance$initialStat7.pageSize) != null ? _instance$initialStat5 : defaultPageSize);\n      },\n      setPageSize: updater => {\n        instance.setPagination(old => {\n          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n          const topRowIndex = old.pageSize * old.pageIndex;\n          const pageIndex = Math.floor(topRowIndex / pageSize);\n          return { ...old,\n            pageIndex,\n            pageSize\n          };\n        });\n      },\n      setPageCount: updater => instance.setPagination(old => {\n        var _old$pageCount;\n\n        let newPageCount = functionalUpdate(updater, (_old$pageCount = old.pageCount) != null ? _old$pageCount : -1);\n\n        if (typeof newPageCount === 'number') {\n          newPageCount = Math.max(-1, newPageCount);\n        }\n\n        return { ...old,\n          pageCount: newPageCount\n        };\n      }),\n      getPageOptions: memo(() => [instance.getState().pagination.pageSize, instance.getState().pagination.pageCount], (pageSize, pageCount) => {\n        let pageOptions = [];\n\n        if (pageCount && pageCount > 0) {\n          pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);\n        }\n\n        return pageOptions;\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getPageOptions',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n        }\n      }),\n      getCanPreviousPage: () => instance.getState().pagination.pageIndex > 0,\n      getCanNextPage: () => {\n        const {\n          pageIndex\n        } = instance.getState().pagination;\n        const pageCount = instance.getPageCount();\n\n        if (pageCount === -1) {\n          return true;\n        }\n\n        if (pageCount === 0) {\n          return false;\n        }\n\n        return pageIndex < pageCount - 1;\n      },\n      previousPage: () => {\n        return instance.setPageIndex(old => old - 1);\n      },\n      nextPage: () => {\n        return instance.setPageIndex(old => {\n          return old + 1;\n        });\n      },\n      getPrePaginationRowModel: () => instance.getExpandedRowModel(),\n      getPaginationRowModel: () => {\n        if (!instance._getPaginationRowModel && instance.options.getPaginationRowModel) {\n          instance._getPaginationRowModel = instance.options.getPaginationRowModel(instance);\n        }\n\n        if (instance.options.manualPagination || !instance._getPaginationRowModel) {\n          return instance.getPrePaginationRowModel();\n        }\n\n        return instance._getPaginationRowModel();\n      },\n      getPageCount: () => {\n        const {\n          pageCount\n        } = instance.getState().pagination;\n\n        if (typeof pageCount !== 'undefined') {\n          return pageCount;\n        }\n\n        return Math.ceil(instance.getPrePaginationRowModel().rows.length / instance.getState().pagination.pageSize);\n      }\n    };\n  }\n};\n\n//\nconst getDefaultPinningState = () => ({\n  left: [],\n  right: []\n});\n\nconst Pinning = {\n  getInitialState: state => {\n    return {\n      columnPinning: getDefaultPinningState(),\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', instance)\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      pin: position => {\n        const columnIds = column.getLeafColumns().map(d => d.id).filter(Boolean);\n        instance.setColumnPinning(old => {\n          var _old$left3, _old$right3;\n\n          if (position === 'right') {\n            var _old$left, _old$right;\n\n            return {\n              left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n              right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds]\n            };\n          }\n\n          if (position === 'left') {\n            var _old$left2, _old$right2;\n\n            return {\n              left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds],\n              right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n            };\n          }\n\n          return {\n            left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n            right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n          };\n        });\n      },\n      getCanPin: () => {\n        const leafColumns = column.getLeafColumns();\n        return leafColumns.some(d => {\n          var _d$enablePinning, _instance$options$ena;\n\n          return ((_d$enablePinning = d.enablePinning) != null ? _d$enablePinning : true) && ((_instance$options$ena = instance.options.enablePinning) != null ? _instance$options$ena : true);\n        });\n      },\n      getIsPinned: () => {\n        const leafColumnIds = column.getLeafColumns().map(d => d.id);\n        const {\n          left,\n          right\n        } = instance.getState().columnPinning;\n        const isLeft = leafColumnIds.some(d => left == null ? void 0 : left.includes(d));\n        const isRight = leafColumnIds.some(d => right == null ? void 0 : right.includes(d));\n        return isLeft ? 'left' : isRight ? 'right' : false;\n      },\n      getPinnedIndex: () => {\n        var _instance$getState$co, _instance$getState$co2, _instance$getState$co3;\n\n        const position = column.getIsPinned();\n        return position ? (_instance$getState$co = (_instance$getState$co2 = instance.getState().columnPinning) == null ? void 0 : (_instance$getState$co3 = _instance$getState$co2[position]) == null ? void 0 : _instance$getState$co3.indexOf(column.id)) != null ? _instance$getState$co : -1 : 0;\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      getCenterVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allCells, left, right) => {\n        const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n        return allCells.filter(d => !leftAndRight.includes(d.columnId));\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getCenterVisibleCells',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n        }\n      }),\n      getLeftVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.left,,], (allCells, left) => {\n        const cells = (left != null ? left : []).map(columnId => allCells.find(cell => cell.columnId === columnId)).filter(Boolean).map(d => ({ ...d,\n          position: 'left'\n        }));\n        return cells;\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getLeftVisibleCells',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n        }\n      }),\n      getRightVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.right], (allCells, right) => {\n        const cells = (right != null ? right : []).map(columnId => allCells.find(cell => cell.columnId === columnId)).filter(Boolean).map(d => ({ ...d,\n          position: 'left'\n        }));\n        return cells;\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getRightVisibleCells',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugRows;\n        }\n      })\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnPinning: updater => instance.options.onColumnPinningChange == null ? void 0 : instance.options.onColumnPinningChange(updater),\n      resetColumnPinning: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        return instance.setColumnPinning(defaultState ? getDefaultPinningState() : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.columnPinning) != null ? _instance$initialStat : getDefaultPinningState());\n      },\n      getIsSomeColumnsPinned: () => {\n        const {\n          left,\n          right\n        } = instance.getState().columnPinning;\n        return Boolean((left == null ? void 0 : left.length) || (right == null ? void 0 : right.length));\n      },\n      getLeftLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.left], (allColumns, left) => {\n        return (left != null ? left : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftLeafColumns',\n        debug: () => {\n          var _instance$options$deb4;\n\n          return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugColumns;\n        }\n      }),\n      getRightLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.right], (allColumns, right) => {\n        return (right != null ? right : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightLeafColumns',\n        debug: () => {\n          var _instance$options$deb5;\n\n          return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugColumns;\n        }\n      }),\n      getCenterLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, left, right) => {\n        const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n        return allColumns.filter(d => !leftAndRight.includes(d.id));\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterLeafColumns',\n        debug: () => {\n          var _instance$options$deb6;\n\n          return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugColumns;\n        }\n      })\n    };\n  }\n};\n\n//\nconst RowSelection = {\n  getInitialState: state => {\n    return {\n      rowSelection: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', instance),\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\n\n    };\n  },\n  createInstance: instance => {\n    return {\n      setRowSelection: updater => instance.options.onRowSelectionChange == null ? void 0 : instance.options.onRowSelectionChange(updater),\n      resetRowSelection: defaultState => {\n        var _instance$initialStat;\n\n        return instance.setRowSelection(defaultState ? {} : (_instance$initialStat = instance.initialState.rowSelection) != null ? _instance$initialStat : {});\n      },\n      toggleAllRowsSelected: value => {\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !instance.getIsAllRowsSelected();\n          const rowSelection = { ...old\n          };\n          const preGroupedFlatRows = instance.getPreGroupedRowModel().flatRows; // We don't use `mutateRowIsSelected` here for performance reasons.\n          // All of the rows are flat already, so it wouldn't be worth it\n\n          if (value) {\n            preGroupedFlatRows.forEach(row => {\n              rowSelection[row.id] = true;\n            });\n          } else {\n            preGroupedFlatRows.forEach(row => {\n              delete rowSelection[row.id];\n            });\n          }\n\n          return rowSelection;\n        });\n      },\n      toggleAllPageRowsSelected: value => instance.setRowSelection(old => {\n        typeof value !== 'undefined' ? value : !instance.getIsAllPageRowsSelected();\n        const rowSelection = { ...old\n        };\n        instance.getRowModel().rows.forEach(row => {\n          mutateRowIsSelected(rowSelection, row.id, value, instance);\n        });\n        return rowSelection;\n      }),\n      // addRowSelectionRange: rowId => {\n      //   const {\n      //     rows,\n      //     rowsById,\n      //     options: { selectGroupingRows, selectSubRows },\n      //   } = instance\n      //   const findSelectedRow = (rows: Row[]) => {\n      //     let found\n      //     rows.find(d => {\n      //       if (d.getIsSelected()) {\n      //         found = d\n      //         return true\n      //       }\n      //       const subFound = findSelectedRow(d.subRows || [])\n      //       if (subFound) {\n      //         found = subFound\n      //         return true\n      //       }\n      //       return false\n      //     })\n      //     return found\n      //   }\n      //   const firstRow = findSelectedRow(rows) || rows[0]\n      //   const lastRow = rowsById[rowId]\n      //   let include = false\n      //   const selectedRowIds = {}\n      //   const addRow = (row: Row) => {\n      //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n      //       rowsById,\n      //       selectGroupingRows: selectGroupingRows!,\n      //       selectSubRows: selectSubRows!,\n      //     })\n      //   }\n      //   instance.rows.forEach(row => {\n      //     const isFirstRow = row.id === firstRow.id\n      //     const isLastRow = row.id === lastRow.id\n      //     if (isFirstRow || isLastRow) {\n      //       if (!include) {\n      //         include = true\n      //       } else if (include) {\n      //         addRow(row)\n      //         include = false\n      //       }\n      //     }\n      //     if (include) {\n      //       addRow(row)\n      //     }\n      //   })\n      //   instance.setRowSelection(selectedRowIds)\n      // },\n      getPreSelectedRowModel: () => instance.getCoreRowModel(),\n      getSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getCoreRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n        }\n      }),\n      getFilteredSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getFilteredRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'getFilteredSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugTable;\n        }\n      }),\n      getGroupedSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getGroupedRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'getGroupedSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugTable;\n        }\n      }),\n      ///\n      // getGroupingRowCanSelect: rowId => {\n      //   const row = instance.getRow(rowId)\n      //   if (!row) {\n      //     throw new Error()\n      //   }\n      //   if (typeof instance.options.enableGroupingRowSelection === 'function') {\n      //     return instance.options.enableGroupingRowSelection(row)\n      //   }\n      //   return instance.options.enableGroupingRowSelection ?? false\n      // },\n      getIsAllRowsSelected: () => {\n        const preFilteredFlatRows = instance.getPreFilteredRowModel().flatRows;\n        const {\n          rowSelection\n        } = instance.getState();\n        let isAllRowsSelected = Boolean(preFilteredFlatRows.length && Object.keys(rowSelection).length);\n\n        if (isAllRowsSelected) {\n          if (preFilteredFlatRows.some(row => !rowSelection[row.id])) {\n            isAllRowsSelected = false;\n          }\n        }\n\n        return isAllRowsSelected;\n      },\n      getIsAllPageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows;\n        const {\n          rowSelection\n        } = instance.getState();\n        let isAllPageRowsSelected = !!paginationFlatRows.length;\n\n        if (isAllPageRowsSelected && paginationFlatRows.some(row => !rowSelection[row.id])) {\n          isAllPageRowsSelected = false;\n        }\n\n        return isAllPageRowsSelected;\n      },\n      getIsSomeRowsSelected: () => {\n        var _instance$getState$ro;\n\n        return !instance.getIsAllRowsSelected() && !!Object.keys((_instance$getState$ro = instance.getState().rowSelection) != null ? _instance$getState$ro : {}).length;\n      },\n      getIsSomePageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows;\n        return instance.getIsAllPageRowsSelected() ? false : !!(paginationFlatRows != null && paginationFlatRows.length);\n      },\n      getToggleAllRowsSelectedHandler: () => {\n        return e => {\n          instance.toggleAllRowsSelected(e.target.checked);\n        };\n      },\n      getToggleAllPageRowsSelectedHandler: () => {\n        return e => {\n          instance.toggleAllPageRowsSelected(e.target.checked);\n        };\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      toggleSelected: value => {\n        const isSelected = row.getIsSelected();\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !isSelected;\n\n          if (isSelected === value) {\n            return old;\n          }\n\n          const selectedRowIds = { ...old\n          };\n          mutateRowIsSelected(selectedRowIds, row.id, value, instance);\n          return selectedRowIds;\n        });\n      },\n      getIsSelected: () => {\n        const {\n          rowSelection\n        } = instance.getState();\n        return isRowSelected(row, rowSelection) === true;\n      },\n      getIsSomeSelected: () => {\n        const {\n          rowSelection\n        } = instance.getState();\n        return isRowSelected(row, rowSelection) === 'some';\n      },\n      getCanSelect: () => {\n        var _instance$options$ena;\n\n        if (typeof instance.options.enableRowSelection === 'function') {\n          return instance.options.enableRowSelection(row);\n        }\n\n        return (_instance$options$ena = instance.options.enableRowSelection) != null ? _instance$options$ena : true;\n      },\n      getCanSelectSubRows: () => {\n        var _instance$options$ena2;\n\n        if (typeof instance.options.enableSubRowSelection === 'function') {\n          return instance.options.enableSubRowSelection(row);\n        }\n\n        return (_instance$options$ena2 = instance.options.enableSubRowSelection) != null ? _instance$options$ena2 : true;\n      },\n      getCanMultiSelect: () => {\n        var _instance$options$ena3;\n\n        if (typeof instance.options.enableMultiRowSelection === 'function') {\n          return instance.options.enableMultiRowSelection(row);\n        }\n\n        return (_instance$options$ena3 = instance.options.enableMultiRowSelection) != null ? _instance$options$ena3 : true;\n      },\n      getToggleSelectedHandler: () => {\n        const canSelect = row.getCanSelect();\n        return e => {\n          var _target;\n\n          if (!canSelect) return;\n          row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n        };\n      }\n    };\n  }\n};\n\nconst mutateRowIsSelected = (selectedRowIds, id, value, instance) => {\n  var _row$subRows;\n\n  const row = instance.getRow(id);\n  row.getIsGrouped(); // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && instance.options.enableGroupingRowSelection)\n  // ) {\n\n  if (value) {\n    selectedRowIds[id] = true;\n  } else {\n    delete selectedRowIds[id];\n  } // }\n\n\n  if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n    row.subRows.forEach(row => mutateRowIsSelected(selectedRowIds, row.id, value, instance));\n  }\n};\n\nfunction selectRowsFn(instance, rowModel) {\n  const rowSelection = instance.getState().rowSelection;\n  const newSelectedFlatRows = [];\n  const newSelectedRowsById = {}; // Filters top level and nested rows\n\n  const recurseRows = function (rows, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    return rows.map(row => {\n      var _row$subRows2;\n\n      const isSelected = isRowSelected(row, rowSelection) === true;\n\n      if (isSelected) {\n        newSelectedFlatRows.push(row);\n        newSelectedRowsById[row.id] = row;\n      }\n\n      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n        row = { ...row,\n          subRows: recurseRows(row.subRows, depth + 1)\n        };\n      }\n\n      if (isSelected) {\n        return row;\n      }\n    }).filter(Boolean);\n  };\n\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById\n  };\n}\nfunction isRowSelected(row, selection, instance) {\n  if (selection[row.id]) {\n    return true;\n  }\n\n  if (row.subRows && row.subRows.length) {\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach(subRow => {\n      // Bail out early if we know both of these\n      if (someSelected && !allChildrenSelected) {\n        return;\n      }\n\n      if (isRowSelected(subRow, selection)) {\n        someSelected = true;\n      } else {\n        allChildrenSelected = false;\n      }\n    });\n    return allChildrenSelected ? true : someSelected ? 'some' : false;\n  }\n\n  return false;\n}\n\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst sortingFns = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic\n};\n\nfunction alphanumeric(rowA, rowB, columnId) {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n}\n\nfunction alphanumericCaseSensitive(rowA, rowB, columnId) {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n} // Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\n\n\nfunction compareAlphanumeric(aStr, bStr) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean); // While\n\n  while (a.length && b.length) {\n    const aa = a.shift();\n    const bb = b.shift();\n    const an = parseInt(aa, 10);\n    const bn = parseInt(bb, 10);\n    const combo = [an, bn].sort(); // Both are string\n\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1;\n      }\n\n      if (bb > aa) {\n        return -1;\n      }\n\n      continue;\n    } // One is a string, one is a number\n\n\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1;\n    } // Both are numbers\n\n\n    if (an > bn) {\n      return 1;\n    }\n\n    if (bn > an) {\n      return -1;\n    }\n  }\n\n  return a.length - b.length;\n} // The text filter is more basic (less numeric support)\n// but is much faster\n\n\nfunction text(rowA, rowB, columnId) {\n  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n} // The text filter is more basic (less numeric support)\n// but is much faster\n\n\nfunction textCaseSensitive(rowA, rowB, columnId) {\n  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n}\n\nfunction datetime(rowA, rowB, columnId) {\n  return compareBasic(rowA.getValue(columnId).getTime(), rowB.getValue(columnId).getTime());\n}\n\nfunction basic(rowA, rowB, columnId) {\n  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n} // Utils\n\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return '';\n    }\n\n    return String(a);\n  }\n\n  if (typeof a === 'string') {\n    return a;\n  }\n\n  return '';\n}\n\n//\nconst Sorting = {\n  getInitialState: state => {\n    return {\n      sorting: [],\n      ...state\n    };\n  },\n  getDefaultColumn: () => {\n    return {\n      sortingFn: 'auto'\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', instance),\n      isMultiSortEvent: e => {\n        return e.shiftKey;\n      }\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      getAutoSortingFn: () => {\n        const firstRows = instance.getFilteredRowModel().flatRows.slice(10);\n        let isString = false;\n\n        for (const row of firstRows) {\n          const value = row == null ? void 0 : row.getValue(column.id);\n\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            return sortingFns.datetime;\n          }\n\n          if (typeof value === 'string') {\n            isString = true;\n\n            if (value.split(reSplitAlphaNumeric).length > 1) {\n              return sortingFns.alphanumeric;\n            }\n          }\n        }\n\n        if (isString) {\n          return sortingFns.text;\n        }\n\n        return sortingFns.basic;\n      },\n      getAutoSortDir: () => {\n        const firstRow = instance.getFilteredRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'string') {\n          return 'asc';\n        }\n\n        return 'desc';\n      },\n      getSortingFn: () => {\n        var _ref;\n\n        const userSortingFn = instance.options.sortingFns;\n\n        if (!column) {\n          throw new Error();\n        }\n\n        return isFunction(column.sortingFn) ? column.sortingFn : column.sortingFn === 'auto' ? column.getAutoSortingFn() : (_ref = userSortingFn == null ? void 0 : userSortingFn[column.sortingFn]) != null ? _ref : sortingFns[column.sortingFn];\n      },\n      toggleSorting: (desc, multi) => {\n        // if (column.columns.length) {\n        //   column.columns.forEach((c, i) => {\n        //     if (c.id) {\n        //       instance.toggleColumnSorting(c.id, undefined, multi || !!i)\n        //     }\n        //   })\n        //   return\n        // }\n        instance.setSorting(old => {\n          var _ref2, _column$sortDescFirst, _instance$options$ena, _instance$options$ena2;\n\n          // Find any existing sorting for this column\n          const existingSorting = old == null ? void 0 : old.find(d => d.id === column.id);\n          const existingIndex = old == null ? void 0 : old.findIndex(d => d.id === column.id);\n          const hasDescDefined = typeof desc !== 'undefined' && desc !== null;\n          let newSorting = []; // What should we do with this sort action?\n\n          let sortAction;\n\n          if (column.getCanMultiSort() && multi) {\n            if (existingSorting) {\n              sortAction = 'toggle';\n            } else {\n              sortAction = 'add';\n            }\n          } else {\n            // Normal mode\n            if (old != null && old.length && existingIndex !== old.length - 1) {\n              sortAction = 'replace';\n            } else if (existingSorting) {\n              sortAction = 'toggle';\n            } else {\n              sortAction = 'replace';\n            }\n          }\n\n          const sortDescFirst = (_ref2 = (_column$sortDescFirst = column.sortDescFirst) != null ? _column$sortDescFirst : instance.options.sortDescFirst) != null ? _ref2 : column.getAutoSortDir() === 'desc'; // Handle toggle states that will remove the sorting\n\n          if (sortAction === 'toggle' && ( // Must be toggling\n          (_instance$options$ena = instance.options.enableSortingRemoval) != null ? _instance$options$ena : true) && // If enableSortRemove, enable in general\n          !hasDescDefined && ( // Must not be setting desc\n          multi ? (_instance$options$ena2 = instance.options.enableMultiRemove) != null ? _instance$options$ena2 : true : true) && ( // If multi, don't allow if enableMultiRemove\n          existingSorting != null && existingSorting.desc // Finally, detect if it should indeed be removed\n          ? !sortDescFirst : sortDescFirst)) {\n            sortAction = 'remove';\n          }\n\n          if (sortAction === 'replace') {\n            newSorting = [{\n              id: column.id,\n              desc: hasDescDefined ? desc : !!sortDescFirst\n            }];\n          } else if (sortAction === 'add' && old != null && old.length) {\n            var _instance$options$max;\n\n            newSorting = [...old, {\n              id: column.id,\n              desc: hasDescDefined ? desc : !!sortDescFirst\n            }]; // Take latest n columns\n\n            newSorting.splice(0, newSorting.length - ((_instance$options$max = instance.options.maxMultiSortColCount) != null ? _instance$options$max : Number.MAX_SAFE_INTEGER));\n          } else if (sortAction === 'toggle' && old != null && old.length) {\n            // This flips (or sets) the\n            newSorting = old.map(d => {\n              if (d.id === column.id) {\n                return { ...d,\n                  desc: hasDescDefined ? desc : !(existingSorting != null && existingSorting.desc)\n                };\n              }\n\n              return d;\n            });\n          } else if (sortAction === 'remove' && old != null && old.length) {\n            newSorting = old.filter(d => d.id !== column.id);\n          }\n\n          return newSorting;\n        });\n      },\n      getCanSort: () => {\n        var _column$enableSorting, _instance$options$ena3;\n\n        return ((_column$enableSorting = column.enableSorting) != null ? _column$enableSorting : true) && ((_instance$options$ena3 = instance.options.enableSorting) != null ? _instance$options$ena3 : true) && !!column.accessorFn;\n      },\n      getCanMultiSort: () => {\n        var _ref3, _column$enableMultiSo;\n\n        return (_ref3 = (_column$enableMultiSo = column.enableMultiSort) != null ? _column$enableMultiSo : instance.options.enableMultiSort) != null ? _ref3 : !!column.accessorFn;\n      },\n      getIsSorted: () => {\n        var _instance$getState$so;\n\n        const columnSort = (_instance$getState$so = instance.getState().sorting) == null ? void 0 : _instance$getState$so.find(d => d.id === column.id);\n        return !columnSort ? false : columnSort.desc ? 'desc' : 'asc';\n      },\n      getSortIndex: () => {\n        var _instance$getState$so2, _instance$getState$so3;\n\n        return (_instance$getState$so2 = (_instance$getState$so3 = instance.getState().sorting) == null ? void 0 : _instance$getState$so3.findIndex(d => d.id === column.id)) != null ? _instance$getState$so2 : -1;\n      },\n      clearSorting: () => {\n        //clear sorting for just 1 column\n        instance.setSorting(old => old != null && old.length ? old.filter(d => d.id !== column.id) : []);\n      },\n      getToggleSortingHandler: () => {\n        const canSort = column.getCanSort();\n        return e => {\n          if (!canSort) return;\n          e.persist == null ? void 0 : e.persist();\n          column.toggleSorting == null ? void 0 : column.toggleSorting(undefined, column.getCanMultiSort() ? instance.options.isMultiSortEvent == null ? void 0 : instance.options.isMultiSortEvent(e) : false);\n        };\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setSorting: updater => instance.options.onSortingChange == null ? void 0 : instance.options.onSortingChange(updater),\n      resetSorting: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setSorting(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.sorting) != null ? _instance$initialStat : []);\n      },\n      getPreSortedRowModel: () => instance.getFilteredRowModel(),\n      getSortedRowModel: () => {\n        if (!instance._getSortedRowModel && instance.options.getSortedRowModel) {\n          instance._getSortedRowModel = instance.options.getSortedRowModel(instance);\n        }\n\n        if (instance.options.manualSorting || !instance._getSortedRowModel) {\n          return instance.getPreSortedRowModel();\n        }\n\n        return instance._getSortedRowModel();\n      }\n    };\n  }\n};\n\n//\nconst Visibility = {\n  getInitialState: state => {\n    return {\n      columnVisibility: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', instance)\n    };\n  },\n  getDefaultColumn: () => {\n    return {\n      defaultIsVisible: true\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      toggleVisibility: value => {\n        if (column.getCanHide()) {\n          instance.setColumnVisibility(old => ({ ...old,\n            [column.id]: value != null ? value : !column.getIsVisible()\n          }));\n        }\n      },\n      getIsVisible: () => {\n        var _instance$getState$co, _instance$getState$co2;\n\n        return (_instance$getState$co = (_instance$getState$co2 = instance.getState().columnVisibility) == null ? void 0 : _instance$getState$co2[column.id]) != null ? _instance$getState$co : true;\n      },\n      getCanHide: () => {\n        var _column$enableHiding, _instance$options$ena;\n\n        return ((_column$enableHiding = column.enableHiding) != null ? _column$enableHiding : true) && ((_instance$options$ena = instance.options.enableHiding) != null ? _instance$options$ena : true);\n      },\n      getToggleVisibilityHandler: () => {\n        return e => {\n          column.toggleVisibility == null ? void 0 : column.toggleVisibility(e.target.checked);\n        };\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      _getAllVisibleCells: memo(() => [row.getAllCells().filter(cell => cell.column.getIsVisible()).map(d => d.id).join('_')], _ => {\n        return row.getAllCells().filter(cell => cell.column.getIsVisible());\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row._getAllVisibleCells',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n        }\n      }),\n      getVisibleCells: memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], {\n        key: process.env.NODE_ENV === 'development' && 'row.getVisibleCells',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n        }\n      })\n    };\n  },\n  createInstance: instance => {\n    const makeVisibleColumnsMethod = (key, getColumns) => {\n      return memo(() => [getColumns(), getColumns().filter(d => d.getIsVisible()).map(d => d.id).join('_')], columns => {\n        return columns.filter(d => d.getIsVisible == null ? void 0 : d.getIsVisible());\n      }, {\n        key,\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugColumns;\n        }\n      });\n    };\n\n    return {\n      getVisibleFlatColumns: makeVisibleColumnsMethod('getVisibleFlatColumns', () => instance.getAllFlatColumns()),\n      getVisibleLeafColumns: makeVisibleColumnsMethod('getVisibleLeafColumns', () => instance.getAllLeafColumns()),\n      getLeftVisibleLeafColumns: makeVisibleColumnsMethod('getLeftVisibleLeafColumns', () => instance.getLeftLeafColumns()),\n      getRightVisibleLeafColumns: makeVisibleColumnsMethod('getRightVisibleLeafColumns', () => instance.getRightLeafColumns()),\n      getCenterVisibleLeafColumns: makeVisibleColumnsMethod('getCenterVisibleLeafColumns', () => instance.getCenterLeafColumns()),\n      setColumnVisibility: updater => instance.options.onColumnVisibilityChange == null ? void 0 : instance.options.onColumnVisibilityChange(updater),\n      resetColumnVisibility: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnVisibility(defaultState ? {} : (_instance$initialStat = instance.initialState.columnVisibility) != null ? _instance$initialStat : {});\n      },\n      toggleAllColumnsVisible: value => {\n        var _value;\n\n        value = (_value = value) != null ? _value : !instance.getIsAllColumnsVisible();\n        instance.setColumnVisibility(instance.getAllLeafColumns().reduce((obj, column) => ({ ...obj,\n          [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n        }), {}));\n      },\n      getIsAllColumnsVisible: () => !instance.getAllLeafColumns().some(column => !(column.getIsVisible != null && column.getIsVisible())),\n      getIsSomeColumnsVisible: () => instance.getAllLeafColumns().some(column => column.getIsVisible == null ? void 0 : column.getIsVisible()),\n      getToggleAllColumnsVisibilityHandler: () => {\n        return e => {\n          var _target;\n\n          instance.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n        };\n      }\n    };\n  }\n};\n\n//\nconst Headers = {\n  createInstance: instance => {\n    return {\n      createHeader: (column, options) => {\n        var _options$id;\n\n        const id = (_options$id = options.id) != null ? _options$id : column.id;\n        let header = {\n          id,\n          column,\n          index: options.index,\n          isPlaceholder: options.isPlaceholder,\n          placeholderId: options.placeholderId,\n          depth: options.depth,\n          subHeaders: [],\n          colSpan: 0,\n          rowSpan: 0,\n          headerGroup: null,\n          getLeafHeaders: () => {\n            const leafHeaders = [];\n\n            const recurseHeader = h => {\n              if (h.subHeaders && h.subHeaders.length) {\n                h.subHeaders.map(recurseHeader);\n              }\n\n              leafHeaders.push(h);\n            };\n\n            recurseHeader(header);\n            return leafHeaders;\n          },\n          renderHeader: () => column.header ? instance._render(column.header, {\n            instance,\n            header: header,\n            column\n          }) : null,\n          renderFooter: () => column.footer ? instance._render(column.footer, {\n            instance,\n            header: header,\n            column\n          }) : null\n        };\n\n        instance._features.forEach(feature => {\n          Object.assign(header, feature.createHeader == null ? void 0 : feature.createHeader(header, instance));\n        });\n\n        return header;\n      },\n      // Header Groups\n      getHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n        var _left$map$filter, _right$map$filter;\n\n        const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n        const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n        const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n        const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], instance);\n        return headerGroups;\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getHeaderGroups',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugHeaders;\n        }\n      }),\n      getCenterHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n        leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n        return buildHeaderGroups(allColumns, leafColumns, instance, 'center');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterHeaderGroups',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left], (allColumns, leafColumns, left) => {\n        var _left$map$filter2;\n\n        const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n        return buildHeaderGroups(allColumns, orderedLeafColumns, instance, 'left');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftHeaderGroups',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugHeaders;\n        }\n      }),\n      getRightHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.right], (allColumns, leafColumns, right) => {\n        var _right$map$filter2;\n\n        const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n        return buildHeaderGroups(allColumns, orderedLeafColumns, instance, 'right');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightHeaderGroups',\n        debug: () => {\n          var _instance$options$deb4;\n\n          return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugHeaders;\n        }\n      }),\n      // Footer Groups\n      getFooterGroups: memo(() => [instance.getHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getFooterGroups',\n        debug: () => {\n          var _instance$options$deb5;\n\n          return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftFooterGroups: memo(() => [instance.getLeftHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftFooterGroups',\n        debug: () => {\n          var _instance$options$deb6;\n\n          return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugHeaders;\n        }\n      }),\n      getCenterFooterGroups: memo(() => [instance.getCenterHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterFooterGroups',\n        debug: () => {\n          var _instance$options$deb7;\n\n          return (_instance$options$deb7 = instance.options.debugAll) != null ? _instance$options$deb7 : instance.options.debugHeaders;\n        }\n      }),\n      getRightFooterGroups: memo(() => [instance.getRightHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightFooterGroups',\n        debug: () => {\n          var _instance$options$deb8;\n\n          return (_instance$options$deb8 = instance.options.debugAll) != null ? _instance$options$deb8 : instance.options.debugHeaders;\n        }\n      }),\n      // Flat Headers\n      getFlatHeaders: memo(() => [instance.getHeaderGroups()], headerGroups => {\n        return headerGroups.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getFlatHeaders',\n        debug: () => {\n          var _instance$options$deb9;\n\n          return (_instance$options$deb9 = instance.options.debugAll) != null ? _instance$options$deb9 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftFlatHeaders: memo(() => [instance.getLeftHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftFlatHeaders',\n        debug: () => {\n          var _instance$options$deb10;\n\n          return (_instance$options$deb10 = instance.options.debugAll) != null ? _instance$options$deb10 : instance.options.debugHeaders;\n        }\n      }),\n      getCenterFlatHeaders: memo(() => [instance.getCenterHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterFlatHeaders',\n        debug: () => {\n          var _instance$options$deb11;\n\n          return (_instance$options$deb11 = instance.options.debugAll) != null ? _instance$options$deb11 : instance.options.debugHeaders;\n        }\n      }),\n      getRightFlatHeaders: memo(() => [instance.getRightHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightFlatHeaders',\n        debug: () => {\n          var _instance$options$deb12;\n\n          return (_instance$options$deb12 = instance.options.debugAll) != null ? _instance$options$deb12 : instance.options.debugHeaders;\n        }\n      }),\n      // Leaf Headers\n      getCenterLeafHeaders: memo(() => [instance.getCenterFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders;\n\n          return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterLeafHeaders',\n        debug: () => {\n          var _instance$options$deb13;\n\n          return (_instance$options$deb13 = instance.options.debugAll) != null ? _instance$options$deb13 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftLeafHeaders: memo(() => [instance.getLeftFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders2;\n\n          return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftLeafHeaders',\n        debug: () => {\n          var _instance$options$deb14;\n\n          return (_instance$options$deb14 = instance.options.debugAll) != null ? _instance$options$deb14 : instance.options.debugHeaders;\n        }\n      }),\n      getRightLeafHeaders: memo(() => [instance.getRightFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders3;\n\n          return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightLeafHeaders',\n        debug: () => {\n          var _instance$options$deb15;\n\n          return (_instance$options$deb15 = instance.options.debugAll) != null ? _instance$options$deb15 : instance.options.debugHeaders;\n        }\n      }),\n      getLeafHeaders: memo(() => [instance.getLeftHeaderGroups(), instance.getCenterHeaderGroups(), instance.getRightHeaderGroups()], (left, center, right) => {\n        var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n\n        return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : [])].map(header => {\n          return header.getLeafHeaders();\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeafHeaders',\n        debug: () => {\n          var _instance$options$deb16;\n\n          return (_instance$options$deb16 = instance.options.debugAll) != null ? _instance$options$deb16 : instance.options.debugHeaders;\n        }\n      }),\n      getHeader: id => {\n        const header = [...instance.getFlatHeaders(), ...instance.getCenterFlatHeaders(), ...instance.getLeftFlatHeaders(), ...instance.getRightFlatHeaders()].find(d => d.id === id);\n\n        if (!header) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\"Could not find header with id: \" + id);\n          }\n\n          throw new Error();\n        }\n\n        return header;\n      }\n    };\n  }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, instance, headerFamily) {\n  var _headerGroups$0$heade, _headerGroups$;\n\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n  let maxDepth = 0;\n\n  const findMaxDepth = function (columns, depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n\n    maxDepth = Math.max(maxDepth, depth);\n    columns.filter(column => column.getIsVisible()).forEach(column => {\n      var _column$columns;\n\n      if ((_column$columns = column.columns) != null && _column$columns.length) {\n        findMaxDepth(column.columns, depth + 1);\n      }\n    }, 0);\n  };\n\n  findMaxDepth(allColumns);\n  let headerGroups = [];\n\n  const createHeaderGroup = (headersToGroup, depth) => {\n    // The header group we are creating\n    const headerGroup = {\n      depth,\n      id: [headerFamily, \"\" + depth].filter(Boolean).join('_'),\n      headers: []\n    }; // The parent columns we're going to scan next\n\n    const pendingParentHeaders = []; // Scan each column for parents\n\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n      let column;\n      let isPlaceholder = false;\n\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent;\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column;\n        isPlaceholder = true;\n      }\n\n      if ((latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n        // This column is repeated. Add it as a sub header to the next batch\n        latestPendingParentHeader.subHeaders.push(headerToGroup);\n      } else {\n        // This is a new header. Let's create it\n        const header = instance.createHeader(column, {\n          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join('_'),\n          isPlaceholder,\n          placeholderId: isPlaceholder ? \"\" + pendingParentHeaders.filter(d => d.column === column).length : undefined,\n          depth,\n          index: pendingParentHeaders.length\n        }); // Add the headerToGroup as a subHeader of the new header\n\n        header.subHeaders.push(headerToGroup); // Add the new header to the pendingParentHeaders to get grouped\n        // in the next batch\n\n        pendingParentHeaders.push(header);\n      }\n\n      headerGroup.headers.push(headerToGroup);\n      headerToGroup.headerGroup = headerGroup;\n    });\n    headerGroups.push(headerGroup);\n\n    if (depth > 0) {\n      createHeaderGroup(pendingParentHeaders, depth - 1);\n    }\n  };\n\n  const bottomHeaders = columnsToGroup.map((column, index) => instance.createHeader(column, {\n    depth: maxDepth,\n    index\n  }));\n  createHeaderGroup(bottomHeaders, maxDepth - 1);\n  headerGroups.reverse(); // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = headers => {\n    const filteredHeaders = headers.filter(header => header.column.getIsVisible());\n    return filteredHeaders.map(header => {\n      let colSpan = 0;\n      let rowSpan = 0;\n      let childRowSpans = [0];\n\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = [];\n        recurseHeadersForSpans(header.subHeaders).forEach(_ref => {\n          let {\n            colSpan: childColSpan,\n            rowSpan: childRowSpan\n          } = _ref;\n          colSpan += childColSpan;\n          childRowSpans.push(childRowSpan);\n        });\n      } else {\n        colSpan = 1;\n      }\n\n      const minChildRowSpan = Math.min(...childRowSpans);\n      rowSpan = rowSpan + minChildRowSpan;\n      header.colSpan = colSpan > 0 ? colSpan : undefined;\n      header.rowSpan = rowSpan > 0 ? rowSpan : undefined;\n      return {\n        colSpan,\n        rowSpan\n      };\n    });\n  };\n\n  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n  return headerGroups;\n}\n\n// export type Batch = {\n//   id: number\n//   priority: keyof CoreBatches\n//   tasks: (() => void)[]\n//   schedule: (cb: () => void) => void\n//   cancel: () => void\n// }\n// type CoreBatches = {\n//   data: Batch[]\n//   facets: Batch[]\n// }\nfunction createTableInstance(options) {\n  var _options$initialState;\n\n  if (options.debugAll || options.debugTable) {\n    console.info('Creating Table Instance...');\n  }\n\n  let instance = {\n    _features: [Columns, Rows, Cells, Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing]\n  };\n\n  const defaultOptions = instance._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(instance));\n  }, {});\n\n  const mergeOptions = options => {\n    if (instance.options.mergeOptions) {\n      return instance.options.mergeOptions(defaultOptions, options);\n    }\n\n    return { ...defaultOptions,\n      ...options\n    };\n  };\n\n  const coreInitialState = {// coreProgress: 1,\n  };\n  let initialState = { ...coreInitialState,\n    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})\n  };\n\n  instance._features.forEach(feature => {\n    var _feature$getInitialSt;\n\n    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n  });\n\n  const queued = [];\n  let queuedTimeout = false;\n  const midInstance = { ...instance,\n    // init: () => {\n    //   startWork()\n    // },\n    // willUpdate: () => {\n    //   startWork()\n    // },\n    // destroy: () => {\n    //   stopWork()\n    // },\n    options: { ...defaultOptions,\n      ...options\n    },\n    initialState,\n    _queue: cb => {\n      queued.push(cb);\n\n      if (!queuedTimeout) {\n        queuedTimeout = true; // Schedule a microtask to run the queued callbacks after\n        // the current call stack (render, etc) has finished.\n\n        Promise.resolve().then(() => {\n          while (queued.length) {\n            queued.shift()();\n          }\n\n          queuedTimeout = false;\n        }).catch(error => setTimeout(() => {\n          throw error;\n        }));\n      }\n    },\n    reset: () => {\n      instance.setState(instance.initialState);\n    },\n    setOptions: updater => {\n      const newOptions = functionalUpdate(updater, instance.options);\n      instance.options = mergeOptions(newOptions);\n    },\n    _render: (template, props) => {\n      if (typeof instance.options.render === 'function') {\n        return instance.options.render(template, props);\n      }\n\n      if (typeof template === 'function') {\n        return template(props);\n      }\n\n      return template;\n    },\n    getState: () => {\n      return instance.options.state;\n    },\n    setState: updater => {\n      instance.options.onStateChange == null ? void 0 : instance.options.onStateChange(updater);\n    } // getOverallProgress: () => {\n    //   const { coreProgress, filtersProgress, facetProgress } =\n    //     instance.getState()\n    //   return mean(() =>\n    //     [coreProgress, filtersProgress].filter(d => d < 1)\n    //   ) as number\n    // },\n    // getProgressStage: () => {\n    //   const { coreProgress, filtersProgress, facetProgress } =\n    //     instance.getState()\n    //   if (coreProgress < 1) {\n    //     return 'coreRowModel'\n    //   }\n    //   if (filtersProgress < 1) {\n    //     return 'filteredRowModel'\n    //   }\n    //   if (Object.values(facetProgress).some(d => d < 1)) {\n    //     return 'facetedRowModel'\n    //   }\n    // },\n\n  };\n  instance = Object.assign(instance, midInstance);\n\n  instance._features.forEach(feature => {\n    return Object.assign(instance, feature.createInstance == null ? void 0 : feature.createInstance(instance));\n  });\n\n  return instance;\n}\n\n//\nfunction createTableFactory(opts) {\n  return () => createTable(undefined, undefined, opts);\n} // A lot of returns in here are `as any` for a reason. Unless you\n// can find a better way to do this, then don't worry about them\n\nfunction createTable(_, __, options) {\n  const table = {\n    generics: undefined,\n    options: options != null ? options : {\n      render: (() => {\n        throw new Error('');\n      })()\n    },\n    setGenerics: () => table,\n    setRowType: () => table,\n    setTableMetaType: () => table,\n    setColumnMetaType: () => table,\n    setFilterMetaType: () => table,\n    setOptions: newOptions => createTable(_, __, { ...options,\n      ...newOptions\n    }),\n    createDisplayColumn: column => ({ ...column,\n      columnDefType: 'display'\n    }),\n    createGroup: column => ({ ...column,\n      columnDefType: 'group'\n    }),\n    createDataColumn: (accessor, column) => {\n      column = { ...column,\n        columnDefType: 'data',\n        id: column.id\n      };\n\n      if (typeof accessor === 'string') {\n        var _column$id;\n\n        return { ...column,\n          id: (_column$id = column.id) != null ? _column$id : accessor,\n          accessorKey: accessor\n        };\n      }\n\n      if (typeof accessor === 'function') {\n        return { ...column,\n          accessorFn: accessor\n        };\n      }\n\n      throw new Error('Invalid accessor');\n    }\n  };\n  return table;\n}\n\nfunction getCoreRowModel() {\n  return instance => memo(() => [instance.options.data], data => {\n    const rowModel = {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    };\n    let rows;\n    let row;\n    let originalRow;\n\n    const accessRows = function (originalRows, depth, parent) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      rows = [];\n\n      for (let i = 0; i < originalRows.length; i++) {\n        originalRow = originalRows[i]; // This could be an expensive check at scale, so we should move it somewhere else, but where?\n        // if (!id) {\n        //   if (process.env.NODE_ENV !== 'production') {\n        //     throw new Error(`getRowId expected an ID, but got ${id}`)\n        //   }\n        // }\n        // Make the row\n\n        row = instance.createRow(instance.getRowId(originalRow, i, parent), originalRow, i, depth); // Keep track of every row in a flat array\n\n        rowModel.flatRows.push(row); // Also keep track of every row by its ID\n\n        rowModel.rowsById[row.id] = row; // Push instance row into parent\n\n        rows.push(row); // Get the original subrows\n\n        if (instance.options.getSubRows) {\n          var _row$originalSubRows;\n\n          row.originalSubRows = instance.options.getSubRows(originalRow, i); // Then recursively access them\n\n          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n          }\n        }\n      }\n\n      return rows;\n    };\n\n    rowModel.rows = accessRows(data);\n    return rowModel;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction filterRows(rows, filterRowImpl, instance) {\n  if (instance.options.filterFromLeafRows) {\n    return filterRowModelFromLeafs(rows, filterRowImpl, instance);\n  }\n\n  return filterRowModelFromRoot(rows, filterRowImpl, instance);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, instance) {\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  let row;\n  let newRow;\n\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    const rows = []; // Filter from children up first\n\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      var _row$subRows;\n\n      row = rowsToFilter[i];\n\n      if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n        newRow = instance.createRow(row.id, row.original, row.index, row.depth);\n        newRow.columnFilters = row.columnFilters;\n        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n\n        if (!newRow.subRows.length) {\n          continue;\n        }\n\n        row = newRow;\n      }\n\n      if (filterRow(row)) {\n        rows.push(row);\n        newFilteredRowsById[row.id] = row;\n        newFilteredRowsById[i] = row;\n      }\n    }\n\n    return rows;\n  };\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, instance) {\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  let rows;\n  let row;\n  let newRow; // Filters top level and nested rows\n\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    // Filter from parents downward first\n    rows = []; // Apply the filter to any subRows\n\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      row = rowsToFilter[i];\n      const pass = filterRow(row);\n\n      if (pass) {\n        var _row$subRows2;\n\n        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n          newRow = instance.createRow(row.id, row.original, row.index, row.depth);\n          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n          row = newRow;\n        }\n\n        rows.push(row);\n        newFilteredFlatRows.push(row);\n        newFilteredRowsById[row.id] = row;\n      }\n    }\n\n    return rows;\n  };\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\n\nfunction getFilteredRowModel() {\n  return instance => memo(() => [instance.getPreFilteredRowModel(), instance.getState().columnFilters, instance.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {\n    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      for (let i = 0; i < rowModel.flatRows.length; i++) {\n        rowModel.flatRows[i].columnFilters = {};\n        rowModel.flatRows[i].columnFiltersMeta = {};\n      }\n\n      return rowModel;\n    }\n\n    const resolvedColumnFilters = [];\n    const resolvedGlobalFilters = [];\n    (columnFilters != null ? columnFilters : []).forEach(d => {\n      var _filterFn$resolveFilt;\n\n      const column = instance.getColumn(d.id);\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"Table: Could not find a column to filter with columnId: \" + d.id);\n        }\n      }\n\n      const filterFn = column.getFilterFn();\n\n      if (!filterFn) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"Could not find a valid 'column.filterFn' for column with the ID: \" + column.id + \".\");\n        }\n\n        return;\n      }\n\n      resolvedColumnFilters.push({\n        id: d.id,\n        filterFn,\n        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n      });\n    });\n    const filterableIds = columnFilters.map(d => d.id);\n    const globalFilterFn = instance.getGlobalFilterFn();\n    const globallyFilterableColumns = instance.getAllLeafColumns().filter(column => column.getCanGlobalFilter());\n\n    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n      filterableIds.push('__global__');\n      globallyFilterableColumns.forEach(column => {\n        var _globalFilterFn$resol;\n\n        resolvedGlobalFilters.push({\n          id: column.id,\n          filterFn: globalFilterFn,\n          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n        });\n      });\n    }\n\n    let currentColumnFilter;\n    let currentGlobalFilter; // Flag the prefiltered row model with each filter state\n\n    for (let j = 0; j < rowModel.flatRows.length; j++) {\n      const row = rowModel.flatRows[j];\n      row.columnFilters = {};\n\n      if (resolvedColumnFilters.length) {\n        for (let i = 0; i < resolvedColumnFilters.length; i++) {\n          currentColumnFilter = resolvedColumnFilters[i];\n          const id = currentColumnFilter.id; // Tag the row with the column filter state\n\n          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          });\n        }\n      }\n\n      if (resolvedGlobalFilters.length) {\n        for (let i = 0; i < resolvedGlobalFilters.length; i++) {\n          currentGlobalFilter = resolvedGlobalFilters[i];\n          const id = currentGlobalFilter.id; // Tag the row with the first truthy global filter state\n\n          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          })) {\n            row.columnFilters.__global__ = true;\n            break;\n          }\n        }\n\n        if (row.columnFilters.__global__ !== true) {\n          row.columnFilters.__global__ = false;\n        }\n      }\n    }\n\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }; // Filter final rows using all of the active filters\n\n\n    return filterRows(rowModel.rows, filterRowsImpl, instance);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFilteredRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction getFacetedRowModel() {\n  return (instance, columnId) => memo(() => [instance.getPreFilteredRowModel(), instance.getState().columnFilters, instance.getState().globalFilter, instance.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {\n    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      return preRowModel;\n    }\n\n    const filterableIds = [...columnFilters.map(d => d.id).filter(d => d !== columnId), globalFilter ? '__global__' : undefined].filter(Boolean);\n\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    return filterRows(preRowModel.rows, filterRowsImpl, instance);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedRowModel_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getFacetedUniqueValues() {\n  return (instance, columnId) => memo(() => [instance.getColumn(columnId).getFacetedRowModel()], facetedRowModel => {\n    let facetedUniqueValues = new Map();\n\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      var _facetedRowModel$flat;\n\n      const value = (_facetedRowModel$flat = facetedRowModel.flatRows[i]) == null ? void 0 : _facetedRowModel$flat.getValue(columnId);\n\n      if (facetedUniqueValues.has(value)) {\n        var _facetedUniqueValues$;\n\n        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n      } else {\n        facetedUniqueValues.set(value, 1);\n      }\n    }\n\n    return facetedUniqueValues;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedUniqueValues_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getFacetedMinMaxValues() {\n  return (instance, columnId) => memo(() => [instance.getColumn(columnId).getFacetedRowModel()], facetedRowModel => {\n    var _facetedRowModel$flat;\n\n    const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getValue(columnId);\n\n    if (typeof firstValue === 'undefined') {\n      return undefined;\n    }\n\n    let facetedMinMaxValues = [firstValue, firstValue];\n\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      var _facetedRowModel$flat2;\n\n      const value = (_facetedRowModel$flat2 = facetedRowModel.flatRows[i]) == null ? void 0 : _facetedRowModel$flat2.getValue(columnId);\n\n      if (value < facetedMinMaxValues[0]) {\n        facetedMinMaxValues[0] = value;\n      } else if (value > facetedMinMaxValues[1]) {\n        facetedMinMaxValues[1] = value;\n      }\n    }\n\n    return facetedMinMaxValues;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedMinMaxValues_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getSortedRowModel() {\n  return instance => memo(() => [instance.getState().sorting, instance.getPreSortedRowModel()], (sorting, rowModel) => {\n    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n      return rowModel;\n    }\n\n    const sortingState = instance.getState().sorting;\n    const sortedFlatRows = []; // Filter out sortings that correspond to non existing columns\n\n    const availableSorting = sortingState.filter(sort => instance.getColumn(sort.id).getCanSort());\n    const columnInfoById = {};\n    availableSorting.forEach(sortEntry => {\n      const column = instance.getColumn(sortEntry.id);\n      columnInfoById[sortEntry.id] = {\n        sortUndefined: column.sortUndefined,\n        invertSorting: column.invertSorting,\n        sortingFn: column.getSortingFn()\n      };\n    });\n\n    const sortData = rows => {\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = rows.slice();\n      sortedData.sort((rowA, rowB) => {\n        for (let i = 0; i < availableSorting.length; i += 1) {\n          var _sortEntry$desc;\n\n          const sortEntry = availableSorting[i];\n          const columnInfo = columnInfoById[sortEntry.id];\n          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n\n          if (columnInfo.sortUndefined) {\n            const aValue = rowA.getValue(sortEntry.id);\n            const bValue = rowB.getValue(sortEntry.id);\n            const aUndefined = typeof aValue === 'undefined';\n            const bUndefined = typeof bValue === 'undefined';\n\n            if (aUndefined || bUndefined) {\n              return aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n            }\n          } // This function should always return in ascending order\n\n\n          let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n\n          if (sortInt !== 0) {\n            if (isDesc) {\n              sortInt *= -1;\n            }\n\n            if (columnInfo.invertSorting) {\n              sortInt *= -1;\n            }\n\n            return sortInt;\n          }\n        }\n\n        return rowA.index - rowB.index;\n      }); // If there are sub-rows, sort them\n\n      sortedData.forEach(row => {\n        sortedFlatRows.push(row);\n\n        if (!row.subRows || row.subRows.length <= 1) {\n          return;\n        }\n\n        row.subRows = sortData(row.subRows);\n      });\n      return sortedData;\n    };\n\n    return {\n      rows: sortData(rowModel.rows),\n      flatRows: sortedFlatRows,\n      rowsById: rowModel.rowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getSortedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction getGroupedRowModel() {\n  return instance => memo(() => [instance.getState().grouping, instance.getPreGroupedRowModel()], (grouping, rowModel) => {\n    if (!rowModel.rows.length || !grouping.length) {\n      return rowModel;\n    } // Filter the grouping list down to columns that exist\n\n\n    const existingGrouping = grouping.filter(columnId => instance.getColumn(columnId));\n    const groupedFlatRows = [];\n    const groupedRowsById = {}; // const onlyGroupedFlatRows: Row[] = [];\n    // const onlyGroupedRowsById: Record<RowId, Row> = {};\n    // const nonGroupedFlatRows: Row[] = [];\n    // const nonGroupedRowsById: Record<RowId, Row> = {};\n    // Recursively group the data\n\n    const groupUpRecursively = function (rows, depth, parentId) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      // This is the last level, just return the rows\n      if (depth === existingGrouping.length) {\n        return rows;\n      }\n\n      const columnId = existingGrouping[depth]; // Group the rows together for this level\n\n      const rowGroupsMap = groupBy(rows, columnId); // Peform aggregations for each group\n\n      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {\n        let [groupingValue, groupedRows] = _ref;\n        let id = columnId + \":\" + groupingValue;\n        id = parentId ? parentId + \">\" + id : id; // First, Recurse to group sub rows before aggregation\n\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group\n\n        const leafRows = depth ? flattenBy(groupedRows, row => row.subRows) : groupedRows;\n        const row = instance.createRow(id, undefined, index, depth);\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n          getValue: columnId => {\n            // Don't aggregate columns that are in the grouping\n            if (existingGrouping.includes(columnId)) {\n              if (row.valuesCache.hasOwnProperty(columnId)) {\n                return row.valuesCache[columnId];\n              }\n\n              if (groupedRows[0]) {\n                var _groupedRows$0$getVal;\n\n                row.valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n              }\n\n              return row.valuesCache[columnId];\n            }\n\n            if (row.groupingValuesCache.hasOwnProperty(columnId)) {\n              return row.groupingValuesCache[columnId];\n            } // Aggregate the values\n\n\n            const column = instance.getColumn(columnId);\n            const aggregateFn = column.getColumnAggregationFn();\n\n            if (aggregateFn) {\n              row.groupingValuesCache[columnId] = aggregateFn(() => leafRows.map(row => {\n                let columnValue = row.getValue(columnId);\n\n                if (!depth && column.aggregateValue) {\n                  columnValue = column.aggregateValue(columnValue);\n                }\n\n                return columnValue;\n              }), () => groupedRows.map(row => row.getValue(columnId)));\n              return row.groupingValuesCache[columnId];\n            } else if (column.aggregationFn) {\n              console.info({\n                column\n              });\n              throw new Error(process.env.NODE_ENV !== 'production' ? \"Table: Invalid column.aggregateType option for column listed above\" : '');\n            }\n          }\n        });\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow);\n          groupedRowsById[subRow.id] = subRow; // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        });\n        return row;\n      });\n      return aggregatedGroupedRows;\n    };\n\n    const groupedRows = groupUpRecursively(rowModel.rows, 0, '');\n    groupedRows.forEach(subRow => {\n      groupedFlatRows.push(subRow);\n      groupedRowsById[subRow.id] = subRow; // if (subRow.getIsGrouped?.()) {\n      //   onlyGroupedFlatRows.push(subRow);\n      //   onlyGroupedRowsById[subRow.id] = subRow;\n      // } else {\n      //   nonGroupedFlatRows.push(subRow);\n      //   nonGroupedRowsById[subRow.id] = subRow;\n      // }\n    });\n    return {\n      rows: groupedRows,\n      flatRows: groupedFlatRows,\n      rowsById: groupedRowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getGroupedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._queue(() => {\n        instance._autoResetExpanded();\n\n        instance._autoResetPageIndex();\n      });\n    }\n  });\n}\n\nfunction groupBy(rows, columnId) {\n  const groupMap = new Map();\n  return rows.reduce((map, row) => {\n    const resKey = \"\" + row.getValue(columnId);\n    const previous = map.get(resKey);\n\n    if (!previous) {\n      map.set(resKey, [row]);\n    } else {\n      map.set(resKey, [...previous, row]);\n    }\n\n    return map;\n  }, groupMap);\n}\n\nfunction getExpandedRowModel() {\n  return instance => memo(() => [instance.getState().expanded, instance.getPreExpandedRowModel(), instance.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {\n    if (!rowModel.rows.length || // Do not expand if rows are not included in pagination\n    !paginateExpandedRows || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n      return rowModel;\n    }\n\n    return expandRows(rowModel, instance);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getExpandedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    }\n  });\n}\nfunction expandRows(rowModel, instance) {\n  const expandedRows = [];\n\n  const handleRow = row => {\n    var _row$subRows;\n\n    expandedRows.push(row);\n\n    if (instance.options.expandSubRows && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n      row.subRows.forEach(handleRow);\n    }\n  };\n\n  rowModel.rows.forEach(handleRow);\n  return {\n    rows: expandedRows,\n    flatRows: rowModel.flatRows,\n    rowsById: rowModel.rowsById\n  };\n}\n\nfunction getPaginationRowModel(opts) {\n  return instance => memo(() => [instance.getState().pagination, instance.getPrePaginationRowModel()], (pagination, rowModel) => {\n    if (!rowModel.rows.length) {\n      return rowModel;\n    }\n\n    const {\n      pageSize,\n      pageIndex\n    } = pagination;\n    let {\n      rows,\n      flatRows,\n      rowsById\n    } = rowModel;\n    const pageStart = pageSize * pageIndex;\n    const pageEnd = pageStart + pageSize;\n    rows = rows.slice(pageStart, pageEnd);\n\n    if (!instance.options.paginateExpandedRows) {\n      return expandRows({\n        rows,\n        flatRows,\n        rowsById\n      }, instance);\n    }\n\n    return {\n      rows,\n      flatRows,\n      rowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getPaginationRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    }\n  });\n}\n\nexport { ColumnSizing, Expanding, Filters, Grouping, Headers, Ordering, Pagination, Pinning, RowSelection, Sorting, Visibility, aggregationFns, buildHeaderGroups, createTableFactory, createTableInstance, defaultColumnSizing, expandRows, filterFns, flattenBy, functionalUpdate, getCoreRowModel, getExpandedRowModel, getFacetedMinMaxValues, getFacetedRowModel, getFacetedUniqueValues, getFilteredRowModel, getGroupedRowModel, getPaginationRowModel, getSortedRowModel, isFunction, isRowSelected, makeStateUpdater, mean, memo, noop, orderColumns, passiveEventSupported, reSplitAlphaNumeric, selectRowsFn, shouldAutoRemoveFilter, sortingFns };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\nexport * from '@tanstack/table-core'\n\nimport {\n  createTableInstance,\n  TableOptions,\n  TableInstance,\n  Table,\n  TableGenerics,\n  createTableFactory,\n  Overwrite,\n  PartialKeys,\n} from '@tanstack/table-core'\n\nexport type Renderable<TProps> =\n  | React.ReactNode\n  | React.FunctionComponent<TProps>\n  | React.Component<TProps>\n\nexport type Render = <TProps extends {}>(\n  Comp: Renderable<TProps>,\n  props: TProps\n) => React.ReactNode | JSX.Element\n\nexport type ReactTableGenerics = Overwrite<\n  TableGenerics,\n  { Renderer: Render; Rendered: ReturnType<Render> }\n>\n\n//\n\nexport const render: Render = (Comp, props) =>\n  !Comp ? null : isReactComponent(Comp) ? <Comp {...props} /> : Comp\n\nfunction isReactComponent(component: unknown): component is React.FC {\n  return (\n    isClassComponent(component) ||\n    typeof component === 'function' ||\n    isExoticComponent(component)\n  )\n}\n\nfunction isClassComponent(component: any) {\n  return (\n    typeof component === 'function' &&\n    (() => {\n      const proto = Object.getPrototypeOf(component)\n      return proto.prototype && proto.prototype.isReactComponent\n    })()\n  )\n}\n\nfunction isExoticComponent(component: any) {\n  return (\n    typeof component === 'object' &&\n    typeof component.$$typeof === 'symbol' &&\n    ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description)\n  )\n}\n\nexport const createTable = createTableFactory({ render })\n\n// const useIsomorphicLayoutEffect =\n//   typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport type UseTableInstanceOptions<TGenerics extends ReactTableGenerics> =\n  PartialKeys<\n    Omit<TableOptions<TGenerics>, 'render'>,\n    'state' | 'onStateChange'\n  >\n\nexport function useTableInstance<TGenerics extends ReactTableGenerics>(\n  table: Table<TGenerics>,\n  options: UseTableInstanceOptions<TGenerics>\n): TableInstance<TGenerics> {\n  // Compose in the generic options to the user options\n  const resolvedOptions: TableOptions<TGenerics> = {\n    ...table.options,\n    state: {}, // Dummy state\n    onStateChange: () => {}, // noop\n    render,\n    ...options,\n  }\n\n  // Create a new table instance and store it in state\n  const [instanceRef] = React.useState(() => ({\n    current: createTableInstance<TGenerics>(resolvedOptions),\n  }))\n\n  // By default, manage table state here using the instance's initial state\n  const [state, setState] = React.useState(\n    () => instanceRef.current.initialState\n  )\n\n  // Compose the default state above with any user state. This will allow the user\n  // to only control a subset of the state if desired.\n  instanceRef.current.setOptions(prev => ({\n    ...prev,\n    ...options,\n    state: {\n      ...state,\n      ...options.state,\n    },\n    // Similarly, we'll maintain both our internal state and any user-provided\n    // state.\n    onStateChange: updater => {\n      setState(updater)\n      options.onStateChange?.(updater)\n    },\n  }))\n\n  return instanceRef.current\n}\n"],"names":["functionalUpdate","updater","input","makeStateUpdater","key","instance","setState","old","isFunction","d","Function","flattenBy","arr","getChildren","flat","recurse","subArr","forEach","item","push","children","length","memo","getDeps","fn","opts","result","deps","depTime","debug","Date","now","newDeps","some","dep","index","resultTime","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","Columns","createInstance","getDefaultColumn","options","defaultColumn","_defaultColumn","header","props","column","id","footer","cell","_props$getValue$toStr","_props$getValue$toStr2","_props$getValue","getValue","toString","call","_features","reduce","obj","feature","Object","assign","_instance$options$deb","debugAll","debugColumns","getColumnDefs","columns","createColumn","columnDef","depth","parent","_ref","_columnDef$id","accessorFn","accessorKey","undefined","originalRow","Error","columnDefType","getFlatColumns","_column$columns","flatMap","_instance$options$deb2","getLeafColumns","_getOrderColumnsFn","orderColumns","_column$columns2","leafColumns","_instance$options$deb3","getAllColumns","columnDefs","recurseColumns","map","_instance$options$deb4","getAllFlatColumns","allColumns","_instance$options$deb5","getAllFlatColumnsById","flatColumns","acc","_instance$options$deb6","getAllLeafColumns","_instance$options$deb7","getColumn","columnId","Rows","getRowId","row","_instance$options$get","join","createRow","original","rowIndex","subRows","valuesCache","hasOwnProperty","getLeafRows","i","getCoreRowModel","_getCoreRowModel","getRowModel","getPaginationRowModel","getRow","rowsById","Cells","getAllCells","createCell","debugRows","getAllCellsByColumnId","allCells","rowId","renderCell","_render","getCell","defaultColumnSizing","size","minSize","maxSize","Number","MAX_SAFE_INTEGER","ColumnSizing","getInitialState","state","columnSizing","columnSizingInfo","startOffset","startSize","deltaOffset","deltaPercentage","isResizingColumn","columnSizingStart","getDefaultOptions","columnResizeMode","onColumnSizingChange","onColumnSizingInfoChange","getSize","_column$minSize","_column$maxSize","columnSize","getState","getStart","position","getLeftVisibleLeafColumns","getRightVisibleLeafColumns","getVisibleLeafColumns","findIndex","prevSiblingColumn","resetSize","setColumnSizing","_ref2","_","rest","getCanResize","_column$enableResizin","_instance$options$ena","enableResizing","enableColumnResizing","getIsResizing","createHeader","sum","_header$column$getSiz","subHeaders","prevSiblingHeader","headerGroup","headers","getResizeHandler","canResize","e","persist","isTouchStartEvent","touches","getLeafHeaders","clientX","updateOffset","eventType","clientXPos","newColumnSizing","setColumnSizingInfo","_old$startOffset","_old$startSize","_ref3","headerSize","mouseEvents","moveHandler","onMove","upHandler","document","removeEventListener","passiveIfSupported","passiveEventSupported","passive","addEventListener","resetColumnSizing","defaultState","_instance$initialStat","initialState","resetHeaderSizeInfo","_instance$initialStat2","getTotalSize","_instance$getHeaderGr","_instance$getHeaderGr2","getHeaderGroups","getLeftTotalSize","_instance$getLeftHead","_instance$getLeftHead2","getLeftHeaderGroups","getCenterTotalSize","_instance$getCenterHe","_instance$getCenterHe2","getCenterHeaderGroups","getRightTotalSize","_instance$getRightHea","_instance$getRightHea2","getRightHeaderGroups","passiveSupported","supported","noop","window","err","type","Expanding","expanded","onExpandedChange","autoResetExpanded","expandSubRows","paginateExpandedRows","registered","queued","_autoResetExpanded","autoResetAll","_queue","resetExpanded","setExpanded","toggleAllRowsExpanded","getIsAllRowsExpanded","getCanSomeRowsExpand","flatRows","getCanExpand","getToggleAllRowsExpandedHandler","getIsSomeRowsExpanded","values","Boolean","getIsExpanded","getExpandedDepth","maxDepth","keys","splitId","split","getPreExpandedRowModel","getGroupedRowModel","getExpandedRowModel","_getExpandedRowModel","manualExpanding","toggleExpanded","_expanded","exists","oldExpanded","getIsRowExpanded","_instance$options$get2","_row$subRows","getRowCanExpand","enableExpanding","getToggleExpandedHandler","canExpand","includesString","filterValue","search","toLowerCase","includes","autoRemove","val","testFalsey","includesStringSensitive","equalsString","arrIncludes","arrIncludesAll","arrIncludesSome","equals","weakEquals","inNumberRange","rowValue","resolveFilterValue","unsafeMin","unsafeMax","parsedMin","parseFloat","parsedMax","isNaN","Infinity","temp","filterFns","Filters","filterFn","columnFilters","globalFilter","onColumnFiltersChange","onGlobalFilterChange","filterFromLeafRows","globalFilterFn","getColumnCanGlobalFilter","_instance$getCoreRowM","_instance$getCoreRowM2","getAutoFilterFn","firstRow","value","Array","isArray","getFilterFn","userFilterFns","getCanFilter","_column$enableColumnF","_instance$options$ena2","enableColumnFilter","enableColumnFilters","enableFilters","getCanGlobalFilter","_column$enableGlobalF","_instance$options$ena3","_instance$options$ena4","enableGlobalFilter","getIsFiltered","getFilterIndex","getFilterValue","_instance$getState$co","_instance$getState$co2","find","_instance$getState$co3","_instance$getState$co4","setFilterValue","setColumnFilters","previousfilter","newFilter","_old$filter","shouldAutoRemoveFilter","filter","newFilterObj","_old$map","_getFacetedRowModel","getFacetedRowModel","getPreFilteredRowModel","_getFacetedUniqueValues","getFacetedUniqueValues","Map","_getFacetedMinMaxValues","getFacetedMinMaxValues","columnFiltersMeta","subRowsByFacetId","getGlobalAutoFilterFn","getGlobalFilterFn","_functionalUpdate","setGlobalFilter","resetGlobalFilter","resetColumnFilters","_getFilteredRowModel","getFilteredRowModel","manualFiltering","_getGlobalFacetedRowModel","getGlobalFacetedRowModel","_getGlobalFacetedUniqueValues","getGlobalFacetedUniqueValues","_getGlobalFacetedMinMaxValues","getGlobalFacetedMinMaxValues","aggregationFns","_getLeafValues","getChildValues","next","extent","mean","median","getLeafValues","leafValues","unique","from","Set","uniqueCount","count","Grouping","aggregationFn","grouping","onGroupingChange","groupedColumnMode","toggleGrouping","setGrouping","getCanGroup","_column$enableGroupin","enableGrouping","getIsGrouped","_instance$getState$gr","getGroupedIndex","_instance$getState$gr2","indexOf","getToggleGroupingHandler","canGroup","getColumnAutoAggregationFn","prototype","getColumnAggregationFn","_ref4","userAggregationFns","resetGrouping","getPreGroupedRowModel","getSortedRowModel","_getGroupedRowModel","manualGrouping","groupingColumnId","groupingValuesCache","getIsPlaceholder","getIsAggregated","renderAggregatedCell","_column$aggregatedCel","template","aggregatedCell","nonGroupingColumns","col","g","Ordering","columnOrder","onColumnOrderChange","setColumnOrder","resetColumnOrder","orderedColumns","columnOrderCopy","columnsCopy","targetColumnId","shift","foundIndex","splice","Pagination","pagination","pageIndex","pageSize","onPaginationChange","_autoResetPageIndex","_instance$options$aut","autoResetPageIndex","manualPagination","resetPageIndex","setPagination","resetPagination","setPageIndex","maxPageIndex","pageCount","_instance$initialStat3","_instance$initialStat4","resetPageSize","_instance$initialStat5","_instance$initialStat6","_instance$initialStat7","setPageSize","topRowIndex","floor","setPageCount","_old$pageCount","newPageCount","getPageOptions","pageOptions","fill","debugTable","getCanPreviousPage","getCanNextPage","getPageCount","previousPage","nextPage","getPrePaginationRowModel","_getPaginationRowModel","ceil","rows","Pinning","columnPinning","left","right","onColumnPinningChange","pin","columnIds","setColumnPinning","_old$left3","_old$right3","_old$left","_old$right","_old$left2","_old$right2","getCanPin","_d$enablePinning","enablePinning","getIsPinned","leafColumnIds","isLeft","isRight","getPinnedIndex","getCenterVisibleCells","_getAllVisibleCells","leftAndRight","getLeftVisibleCells","getRightVisibleCells","resetColumnPinning","getIsSomeColumnsPinned","getLeftLeafColumns","getRightLeafColumns","getCenterLeafColumns","RowSelection","rowSelection","onRowSelectionChange","enableRowSelection","enableMultiRowSelection","enableSubRowSelection","setRowSelection","resetRowSelection","toggleAllRowsSelected","getIsAllRowsSelected","preGroupedFlatRows","toggleAllPageRowsSelected","getIsAllPageRowsSelected","mutateRowIsSelected","getPreSelectedRowModel","getSelectedRowModel","rowModel","selectRowsFn","getFilteredSelectedRowModel","getGroupedSelectedRowModel","preFilteredFlatRows","isAllRowsSelected","paginationFlatRows","isAllPageRowsSelected","getIsSomeRowsSelected","_instance$getState$ro","getIsSomePageRowsSelected","getToggleAllRowsSelectedHandler","target","checked","getToggleAllPageRowsSelectedHandler","toggleSelected","isSelected","getIsSelected","selectedRowIds","isRowSelected","getIsSomeSelected","getCanSelect","getCanSelectSubRows","getCanMultiSelect","getToggleSelectedHandler","canSelect","_target","newSelectedFlatRows","newSelectedRowsById","recurseRows","_row$subRows2","selection","allChildrenSelected","someSelected","subRow","reSplitAlphaNumeric","sortingFns","alphanumeric","rowA","rowB","compareAlphanumeric","alphanumericCaseSensitive","text","compareBasic","textCaseSensitive","datetime","getTime","basic","aStr","bStr","a","b","aa","bb","an","parseInt","bn","combo","sort","Sorting","sorting","sortingFn","onSortingChange","isMultiSortEvent","shiftKey","getAutoSortingFn","firstRows","slice","isString","getAutoSortDir","getSortingFn","userSortingFn","toggleSorting","desc","multi","setSorting","_column$sortDescFirst","existingSorting","existingIndex","hasDescDefined","sortAction","newSorting","getCanMultiSort","sortDescFirst","enableSortingRemoval","enableMultiRemove","_instance$options$max","maxMultiSortColCount","getCanSort","_column$enableSorting","enableSorting","_column$enableMultiSo","enableMultiSort","getIsSorted","_instance$getState$so","columnSort","getSortIndex","_instance$getState$so2","_instance$getState$so3","clearSorting","getToggleSortingHandler","canSort","resetSorting","getPreSortedRowModel","_getSortedRowModel","manualSorting","Visibility","columnVisibility","onColumnVisibilityChange","defaultIsVisible","toggleVisibility","getCanHide","setColumnVisibility","getIsVisible","_column$enableHiding","enableHiding","getToggleVisibilityHandler","getVisibleCells","center","makeVisibleColumnsMethod","getColumns","getVisibleFlatColumns","getCenterVisibleLeafColumns","resetColumnVisibility","toggleAllColumnsVisible","_value","getIsAllColumnsVisible","getIsSomeColumnsVisible","getToggleAllColumnsVisibilityHandler","Headers","_options$id","isPlaceholder","placeholderId","colSpan","rowSpan","leafHeaders","recurseHeader","h","renderHeader","renderFooter","_left$map$filter","_right$map$filter","leftColumns","rightColumns","buildHeaderGroups","debugHeaders","_left$map$filter2","_right$map$filter2","getFooterGroups","headerGroups","reverse","getLeftFooterGroups","getCenterFooterGroups","getRightFooterGroups","_instance$options$deb8","getFlatHeaders","_instance$options$deb9","getLeftFlatHeaders","_instance$options$deb10","getCenterFlatHeaders","_instance$options$deb11","getRightFlatHeaders","_instance$options$deb12","getCenterLeafHeaders","flatHeaders","_header$subHeaders","_instance$options$deb13","getLeftLeafHeaders","_header$subHeaders2","_instance$options$deb14","getRightLeafHeaders","_header$subHeaders3","_instance$options$deb15","_left$0$headers","_left$","_center$0$headers","_center$","_right$0$headers","_right$","_instance$options$deb16","getHeader","columnsToGroup","headerFamily","_headerGroups$0$heade","_headerGroups$","findMaxDepth","createHeaderGroup","headersToGroup","pendingParentHeaders","headerToGroup","latestPendingParentHeader","bottomHeaders","recurseHeadersForSpans","childRowSpans","childColSpan","childRowSpan","createTableInstance","_options$initialState","defaultOptions","_feature$getInitialSt","queuedTimeout","midInstance","cb","Promise","resolve","then","catch","error","setTimeout","reset","setOptions","newOptions","mergeOptions","render","onStateChange","createTableFactory","createTable","__","table","generics","setGenerics","setRowType","setTableMetaType","setColumnMetaType","setFilterMetaType","createDisplayColumn","createGroup","createDataColumn","accessor","_column$id","filterRows","filterRowImpl","rowsToFilter","filterRow","newFilteredFlatRows","newFilteredRowsById","newRow","recurseFilterRows","filterRowModelFromLeafs","filterRowModelFromRoot","expandRows","expandedRows","handleRow","Comp","component","proto","getPrototypeOf","isReactComponent","isClassComponent","$$typeof","description","isExoticComponent","React","createElement","data","accessRows","originalRows","_row$originalSubRows","getSubRows","originalSubRows","facetedRowModel","_facetedRowModel$flat","firstValue","facetedMinMaxValues","_facetedRowModel$flat2","preRowModel","filterableIds","facetedUniqueValues","_facetedUniqueValues$","has","set","get","resolvedColumnFilters","resolvedGlobalFilters","_filterFn$resolveFilt","resolvedValue","globallyFilterableColumns","currentColumnFilter","currentGlobalFilter","_globalFilterFn$resol","j","filterMeta","__global__","existingGrouping","groupedFlatRows","groupedRowsById","groupUpRecursively","parentId","rowGroupsMap","groupMap","resKey","previous","groupBy","aggregatedGroupedRows","entries","groupingValue","groupedRows","leafRows","_groupedRows$0$getVal","aggregateFn","columnValue","aggregateValue","pageStart","pageEnd","sortingState","sortedFlatRows","availableSorting","columnInfoById","sortEntry","sortUndefined","invertSorting","sortData","sortedData","_sortEntry$desc","columnInfo","isDesc","aUndefined","bUndefined","sortInt","resolvedOptions","instanceRef","useState","current","prev"],"mappings":"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"}